[{"title":"Text3怎么修改侧边栏的颜色和内容一致","date":"2017-09-03T02:04:58.000Z","path":"2017/09/03/Text3怎么修改侧边栏的颜色和内容一致/","text":"sublime text3刚安装完成之后打开文件夹显示的样式如下 这样子看起来眼睛会很难受,那么我们怎样才能使得引导菜单的颜色和编辑器底色一样呢? 解决方法如下: Ctrl+Shift+P -&gt; install -&gt; 搜索安装包SyncedSidebarBg，自动同步侧边栏底色为编辑窗口底色。PS：有时改完后侧边栏颜色没变化，不知什么原因，打开包控制，然后列一下已安装包就刷新了。 安装完成之后,效果是这样子的: 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Program","slug":"Program","permalink":"https://kotlinandroid.net/tags/Program/"}]},{"title":"Ubuntu扁平化主题Flatabulous安装教程","date":"2017-09-03T01:25:48.000Z","path":"2017/09/03/Ubuntu扁平化主题Flatabulous安装教程/","text":"不知道大家对Ubuntu自带的主题效果怎么看，反正我自己觉得自带的主题看起来挺难受的，所以网上找了许多法子，终于把主题美化成自己喜欢的样子。 Flatabulous: 一个超好看的扁平化 Ubuntu 桌面主题 安装此主题步骤： 一、TweeakTool123sudo add-apt-repository ppa:tualatrix/ppa sudo apt-get updatesudo apt-get install ubuntu-tweak 该工具是用来设置各种Ubuntu偏好使用的 二、安装Flatabulous下载地址或者直接在Github上 Clone下来1https://github.com/anmoljagetia/Flatabulous 把下载下来的zip包解压，移动到/usr/share/themes/下 1sudo mv Flatabulous-master /usr/share/themes/ 三、安装扁平化图标ultra-flat-icons123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 或者到http://ppa.launchpad.net/noobslab/icons/ubuntu/pool/main/u/ultra-flat-icons/自己下载安装 注意，在Ubuntu15.04会提示找不到ultra-flat-icons这个包解决方法：在软件和更新中把ultra-flat-icons源中的vivid改成trusty，即可安装成功，最后记得改回来过 或者你也可以运行sudo apt-get install ultra-flat-icons-orange或者 sudo apt-get install ultra-flat-icons-green 根据你自己喜欢的颜色选择。 最后完成以上设置的效果图 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Linux","slug":"Linux","permalink":"https://kotlinandroid.net/tags/Linux/"}]},{"title":"决策","date":"2017-09-02T12:16:15.000Z","path":"2017/09/02/决策/","text":"什么是我们一生中耗时最多、最让人纠结的事?是做出大大小小的决策。 我们的生活无时无刻的都充满了各种决策，比如午餐我要吃什么，到了商场我要买什么，今天衣服穿什么等等。 我们时常陷入个人主观感情或者是非理性感情中做出错误的决定，以致于做出让我们后悔终生的判断。 有一个很有趣的问题“扎克伯格为什么总是穿同一件衣服？” 其实扎克伯格的衣柜里的衣服是这样子的 而扎克伯格自己的回答则是 “我想通过清空我的生活来让我在除了如何更好服务社会这件事情以外的任何事情上都做尽可能少的决策。” 作为一个富豪，扎克伯格不是为了有趣才每天穿同一款式的衣服，他这样做确实是行之有效,每一个决定都会减少我们的意志力“血槽”。每一个决定都会让我们少一丝创造力、控制力和专注力。 引用一位名人的话 “我们必须尽早将尽可能多且有用的行动变成我们自发的和习以为常的决策……我们通过毫不费力的下意识行为解决的日常细节越多，我们就能解放越多应该用来处理高级事务的精神意志力。”——威廉·詹姆斯 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"生活随笔","slug":"生活随笔","permalink":"https://kotlinandroid.net/tags/生活随笔/"}]},{"title":"Android开发工具大全","date":"2017-07-29T06:35:32.000Z","path":"2017/07/29/Android开发工具大全/","text":"AndroidDevTools Android Dev Tools官网地址：www.androiddevtools.cn 收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材等。 欢迎大家推荐自己在Android开发过程中用的好用的工具、学习开发教程、用到设计素材，欢迎Star、Fork 😄。 Android Tools Android SDK在线更新镜像服务器 中国科学院开源协会镜像站地址: IPV4/IPV6: mirrors.opencas.cn 端口：80 IPV4/IPV6: mirrors.opencas.org 端口：80 IPV4/IPV6: mirrors.opencas.ac.cn 端口：80 上海GDG镜像服务器地址: sdk.gdgshanghai.com 端口：8000 北京化工大学镜像服务器地址: IPv4: ubuntu.buct.edu.cn/ 端口：80 IPv4: ubuntu.buct.cn/ 端口：80 IPv6: ubuntu.buct6.edu.cn/ 端口：80 大连东软信息学院镜像服务器地址: mirrors.neusoft.edu.cn 端口：80 腾讯Bugly 镜像: android-mirror.bugly.qq.com 端口：8080 腾讯镜像使用方法: http://android-mirror.bugly.qq.com:8080/include/usage.html 使用方法： 启动 Android SDK Manager ，打开主界面，依次选择『Tools』、『Options…』，弹出『Android SDK Manager - Settings』窗口； 在『Android SDK Manager - Settings』窗口中，在『HTTP Proxy Server」和「HTTP Proxy Port』输入框内填入上面镜像服务器地址(不包含http://，如下图)和端口，并且选中『Force https://… sources to be fetched using http://…』复选框。设置完成后单击『Close』按钮关闭『Android SDK Manager - Settings』窗口返回到主界面； 依次选择『Packages』、『Reload』。 Android Studio 注意:以下 Android Studio 下载链接全是 dl.google.com 开头的官方下载，无需tizi，建议用浏览器直接从官方原始链接下载，不要用迅雷下载、不要用迅雷下载、不要用迅雷下载，重要的事情说三遍，避免类似XCodeGhost的事件！！！ 版本号 Windows Mac OSX Linux SHA-1校验码 官方SHA-1校验码截图 2.1.3 正式版 下载 (推荐) 下载 (不含SDK Tools) 下载 下载 下载 Win: 10d319c772b80f3cb0cde952451af8429ea1b68b 43f84de7e61f37880a126c3d567b7fa6cb90c90e 8ad212c55c7f4dc7ab490e4b7e77ec48001ae224 Mac: 06166759b0e1e1ee91a147dcf5227d897a184277 Linux: 8729e6f2f1fa58f04df9f8d1caac2f5be9dfc549 查看 2.2 Beta 下载 下载 下载 Win: 7d2c9861e90dc985b1e6ba78ebd8497b610a8620 Mac:050a443ffee51922eabddbcd260c845a8e06e4a9 Linux: bafb5d7029d2678e8274e24da1c7ce0a00f3a644 查看 2.2 Preview7 下载 下载 下载 Win: e6ea4c9d9bf4ae46dbea82e3cc5638fd93194c33 Mac: 56327a0f97d999a6b7a15f3e9e513aa42881c989 Linux: b85c4e27401f7f18af19e39e453cca8575041dbb 查看 2.1.2 正式版 下载(推荐) 下载(不含SDK Tools) 下载 下载 下载 Win: 10d319c772b80f3cb0cde952451af8429ea1b68b 43f84de7e61f37880a126c3d567b7fa6cb90c90e 8ad212c55c7f4dc7ab490e4b7e77ec48001ae224 Mac: Linux: 查看 SDK Tools 版本号 Windows Mac OSX Linux SHA-1校验码 官方SHA-1校验码截图 24.4.1 installer_r24.4.1-windows.exe android-sdk_r24.4.1-windows.zip android-sdk_r24.4.1-macosx.zip android-sdk_r24.4.1-linux.tgz Win:f9b59d72413649d31e633207e31f456443e7ea0b 66b6a6433053c152b22bf8cab19c0f3fef4eba49 Mac: 85a9cccb0b1f9e6f1f616335c5f07107553840cd Linux: 725bb360f0f7d04eaccff5a2d57abdd49061326d 查看 24.3.4 installer_r24.3.4-windows.exe android-sdk_r24.3.4-windows.zip android-sdk_r24.3.4-macosx.zip android-sdk_r24.3.4-linux.tgz Win: 094dd45f98a31f839feae898b48f23704f2878dd 4a8718fb4a2bf2128d34b92f23ddd79fc65839e7 Mac: 128f10fba668ea490cc94a08e505a48a608879b9 Linux: fb293d7bca42e05580be56b1adc22055d46603dd 查看 SDK Platform-Tools这是 adb, fastboot 等工具包。把解压出来的 platform-tools 文件夹放在 android sdk 根目录下，并把 adb所在的目录添加到系统 PATH 路径里，即可在命令行里直接访问了 adb, fastboot 等工具。 版本号 Windows Mac OSX Linux platform-tools-r22 platform-tools_r22-windows.zip platform-tools_r22-mac.zip platform-tools_r22-linux.zip platform-tools-r21 platform-tools_r21-windows.zip platform-tools_r21-mac.zip platform-tools_r21-linux.zip platform-tools-r20 platform-tools_r20-windows.zip platform-tools_r20-mac.zip platform-tools_r20-linux.zip Build-Tools这是Android开发所需的Build-Tools，下载并解压后，将解压出的整个文件夹复制或者移动到 your sdk 路径/build-tools 文件夹即可。 版本号 Windows Mac OSX Linux 22.0.0 下载 下载 下载 21.1.2 下载 下载 21.1.1 下载 下载 21.1.0 下载 下载 21.0.2 下载 下载 21.0.1 下载 下载 21.0.0 下载 下载 20.0.0 下载 19.1.0 下载 下载 19.0.3 下载 下载 19.0.2 下载 下载 19.0.1 下载 下载 19.0.0 下载 下载 SDK这是Android开发所需的sdk，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/platforms文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 5.0 下载 下载 下载 android L Rev3 下载 下载 下载 android L 下载 下载 下载 android 4.4W 下载 下载 下载 android 4.4.2 下载 下载 下载 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 android 3.2 下载 下载 下载 android 3.1 下载 下载 下载 android 3.0 下载 下载 下载 android 2.3.3 下载 下载 下载 android 2.2 下载 下载 下载 SDK System images这是在创建模拟器时需要的system image，也就是在创建模拟器时CPU/ABI项需要选择的，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/system-images文件夹下即可， 如果没有system-images目录就先创建此文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 5.0 下载 下载 下载 android L 下载 下载 下载 android 4.4W 下载 下载 下载 android 4.4.2 下载 下载 下载 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 GoogleMap APIs SDK这是GoogleMap APIs SDK，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本号 Windows Mac OSX Linux android 4.4.2 下载ARM版 下载x86版 下载ARM版 下载x86版 下载ARM版 下载x86版 android 4.3 下载 下载 下载 android 4.2.2 下载 下载 下载 android 4.1.2 下载 下载 下载 android 4.0.3 下载 下载 下载 android 4.0 下载 下载 下载 android 3.2 下载 下载 下载 android 3.1 下载 下载 下载 android 3.0 下载 下载 下载 android 2.3.3 下载 下载 下载 android 2.2 下载 下载 下载 Google Glass SDK这是GDK，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本 Windows Mac OSX Linux android 4.4.2 下载 下载 下载 android 4.0.3 下载 Google TV Addon这是Google TV Addon，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/add-ons文件夹，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 系统版本 Windows Mac OSX Linux android 3.2 下载 下载 下载 ####Android Framework Source Code这是Android Framework Source Code，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/sources文件夹下，然后重启Eclipse(或Android Studio)，这样当你在Eclipse里面按住Ctrl键点击某个系统类时就可以打开该类的源码文件查看源码了。 系统版本 android 5.0 android 4.4W android 4.4.2 android 4.3 android 4.2.2 android 4.1.2 android 4.0.3 android 4.0 android 3.0 android 2.3.3 android 2.2 Android SDK Extras包含 Android Support Library 、 Google Cloud Messaging for Android Library 、Google Play services 、 Google Play services for fit preview 、Google Play services for Froyo 、Google Play APK Expansion Library、Google Play Billing Library 、Google Play Licensing Library 等，下载解压后将解压出的整个文件夹复制或者移动到your sdk根目录下下，如果已经存在extras文件夹就替换掉。 版本号 21.0.3 21.0.2 21 20 Support Library包含support v4、v7、v13、v17、multidex和m2repository，下载解压后将解压出的整个文件夹复制或者移动到your sdk 路径/extras下，然后打开SDK Manager，打开Tools(工具)菜单选择Options(选项)菜单项打开Android SDK Manager Setting对话框，点击Clear Cache(清除缓存)按钮，然后重启Eclipse(或Android Studio)和SDK Manager。 版本号 21.0.3 21.0.2 21 20 SDK Samples这是Android SDK自带的示例代码，下载并解压后，将解压出的整个文件夹复制或者移动到your sdk 路径/samples文件夹下，然后重启Eclipse(或Android Studio)。。 系统版本 android 21 android L android 4.4W android 4.4.2 android 4.3 android 4.2.2 android 4.1.2 android 4.0.3 android 4.0 android 3.2 android 3.1 android 3.0 android 2.3.3 android 2.2 NDKC/C++开发Android应用工具包,Linux/Mac OS X 下NDK r10c的安装方法请戳 这里 版本号 Windows Mac OSX Linux MD5/SHA-1校验码 官方SHA-1校验码截图 ndk-r11b 32位 64位 64位 64位 Win:b42da395440cc1c5dc4eeeb383679331addeb3ea 480eca1b29cfe73a5b35374730e6a82ca65c2aa6 Mac: c64fb355fec4da57d329ab45bf0aa29a1aec58dc Linux: cf0658956945c81d3d3fad5f9a24fa062d4c9d41 查看 ndk-r10e 32位 64位 64位 32位 64位 Win: 1a82445baaf62aec3a46386ab1e5772c 8412bb4991a95e08fda50b5a44d95df7 Mac: 2cb8893a5701603519d38a7e04c50e81 Linux: c3edd3273029da1cbd2f62c48249e978 19af543b068bdb7f27787c2bc69aba7f 查看 Additional Download (32-, 64-bit) Package r10 STL debug info android-ndk-r10-cxx-stl-libs-with-debug-info.zip r9 STL debug info android-ndk-r9-cxx-stl-libs-with-debug-info.zip Android L Preview System Image这个是Android L Preview系统的刷机镜像。 设备 下载 Nexus 5 (GSM/LTE) “hammerhead” hammerhead-lpv79-preview-ac1d8a8e.tgz Nexus 7 (Wifi) “razor” razor-lpv79-preview-d0ddf8ce.tgz JDK 版本号 Windows Mac OSX Linux 1.8 u77 32位 64位 64位 32位 64位 1.8 u74 32位 64位 64位 32位 64位 1.7 u80 32位 64位 64位 32位 64位 1.6 u45 32位 64位 64位 32位 64位 ADT BundleADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。 版本号 Windows Mac OSX Linux 23.0.2 32位 64位 64位 32位 64位 23.0.0 32位 64位 64位 32位 64位 ADT Plugin离线安装ADT插件请戳项目wiki 版本号 ADT-23.0.7 ADT-23.0.6 ADT-23.0.4 ADT-23.0.3 ADT-23.0.2 ADT-23.0.0 ADT-22.6.3 AdT-22.6.1 Gradle 版本号 gradle-2.12-all.zip gradle-2.11-all.zip gradle-2.10-all.zip gradle-2.9-all.zip gradle-2.8-all.zip gradle-2.7-all.zip gradle-2.6-all.zip gradle-2.5-all.zip gradle-2.4-all.zip gradle-2.3-all.zip gradle-2.2.1-all.zip gradle-2.2-all.zip gradle-2.1-all.zip gradle-2.0-all.zip gradle-1.12-all.zip gradle-1.11-all.zip gradle-1.10-all.zip gradle-1.9-all.zip gradle-1.8-all.zip gradle-1.7-all.zip Android Gradle Plugin DSL 在线文档http://google.github.io/android-gradle-dsl/ Gradle Dependencies Configuration Generator（需要梯子）http://gradleplease.appspot.com 版本控制工具Git 版本号 Windows Mac OSX Linux Git-2.0.1 下载 下载 Git-1.9.4 下载 下载 Git-1.8.5.2 下载 下载 下载 SVN Plugin For Eclipse 版本号 1.10.5 1.8.22 1.6.18 反编译工具 名称 简介 下载地址 使用教程 Enjarify Enjarify 是一个用 Python 写的， Google 官方开源的可以将 Dalvik 字节码转换为 Java 字节码的工具。 下载 JEB Android Decompiler 下载 Virtuous Ten Studio 下载 Apk文件修改工具Root Tools 下载 Dex文件反编译工具Dedexer 下载 APK+Dex文件反编译及回编译工具 下载 android-apktool 下载 Onekey Decompile Apk] 下载 Baksmali 下载 Smali 下载 AXMLPrinter2 下载 JAD Java Decompiler 下载 JD-GUI Decompiler 下载 XJad V2.2 下载 Android APK Decompiler 在线反编译工具 下载 JADX - Dex to Java decompiler 下载 dex2jar 下载 SmaliViewer 是一款免费的APK分析软件，无论从分析的深度还是广度来看，都是一款能够满足用户需求的产品，使您在APK分析的过程中，更加得心应手。 下载 使用指南 Android逆向助手 Android逆向助手是一功能强大的逆向辅助软件。该软件可以帮助用户来进行apk反编译打包签名；dex/jar互转替换提取修复；so反编译；xml、txt加密；字符串编码等等，操作简单，只需要直接将文件拖放到源和目标文件。 下载 使用指南 Android Killer Android Killer 是一款可视化的安卓应用逆向工具，集Apk反编译、Apk打包、Apk签名，编码互转，ADB通信（应用安装-卸载-运行-设备文件管理）等特色功能于一 身，支持logcat日志输出，语法高亮，基于关键字（支持单行代码或多行代码段）项目内搜索，可自定义外部工具；吸收融汇多种工具功能与特点，打造一站 式逆向工具操作体验，大大简化了用户在安卓应用/游戏修改过程中的各类繁琐工作。 下载1下载2 使用指南 DexExtractor android dex extractor ，anti-shell，android 脱壳。 下载 jadx Dex to Java decompiler 下载 android-classyshark a handy Android and Java executables viewer 下载 ShakaApktool 下载 安全工具 名称 下载地址 使用教程 APKfuscator 下载 ApkAnalyser 下载 AppXplore 下载 Android analysis framework 下载 Androguard 下载 Droidbox 下载 dsploit 下载 Androwarn 下载 Anubis 下载 Drozer 下载 VirusTotal 下载 GDB for Android 下载 VisualGDB 下载 静态代码分析工具 名称 简介 下载地址 使用教程 infer Facebook 开源的静态代码分析工具，用于在发布移动应用之前对代码进行分析，找出潜在的问题。 下载 搜索工具 名称 简介 下载地址 使用教程 Structural Java Exception Search Java异常搜索工具 下载 Android Library Finder 最快的方式获取依赖库 下载 Codota 示例代码搜索网站 下载 Debug调试工具 名称 简介 下载地址 使用教程 Stetho Stetho 是Facebook推出的Android 调试平台，基于 Chrome Developer Tools ，调试网络请求方面特别方便。 下载 教程 Augmented Traffic Control Facebook宣布开源移动网络测试工具ATC，该工具支持利用Wi-Fi网络模拟2G、2.5G、3G以及LTE 4G移动网络环境，让测试工程师们能够快速对智能手机和App在不同国家地区和应用环境下的性能表现进行测试。 下载 Api测试工具 名称 简介 下载地址 使用教程 bat 一个用Go写的命令行API测试利器，支持文件下载，文件上传，支持Linux的pipe方式，总之就是炫酷。 下载 使用指南 Eclipse/Android Studio/IDEA插件Eclipse 名称 下载地址 使用教程 SVN 下载 Genymobile模拟器 下载 Memory-Analyzer-Tools 下载 Droidinspector 下载 SQLiteManager 下载 Color Theme 下载 RoboVM 下载 Newrelic 下载 Android Studio/IDEA 名称 下载地址 使用教程 Android Resource Resizer Plugin 下载 Gradle Dependencies Helper Plugin 下载 Android Parcelable code generation Plugin 下载 Android Holo Colors IDEA Plugin 下载 Android Toolbox Plugin 下载 Android Gradle Sign Plugin 下载 Android Permissions Usage Plugin 下载 Android Helper Plugin 下载 Android Studio Prettify Plugin 下载 IDEA ADB Plugin 下载 Otto Intellij Plugin 下载 Dagger intellij Plugin 下载 Gradle Gui Plugin 下载 Android Studio Unit Test Plugin 下载 Android Layout ID Converter Plugin 下载 IDEA protobuf Plugin 下载 Simple Team Code Reviewer Plugin 下载 Android XML Plugin 下载 ADF Plugin 下载 Java2smali Plugin 下载 IDEA gitignore Plugin 下载 IDEA Background Image Plugin 下载 IDEA Maven Plugin 下载 Gradle GooglePlay Publisher Plugin 下载 Drawable Selectors Generates Plugin 下载 Android Drawable Importer 下载 Color themes for IntelliJ IDEA 下载 GsonFormat 下载 ormlite-android-gradle-plugin 下载 Android资源/Themes/Style生成工具 名称 简介 下载地址 使用教程 Android Asset Studio 下载 Android Drawable Factory 下载 Android Action Bar Style Generator 下载 Android Holo Colors Generator 下载 Android Simple Nine-patch Generator 下载 Android Device Frame Generator 下载 Android 9-patch shadow generator 下载 Android资源分析工具 名称 简介 下载地址 使用教程 Android Assets Viewer 下载 Android Layout Parser工具 名称 简介 下载地址 使用教程 Android Layout Binder 下载 Android Content Provider代码生成工具 名称 简介 下载地址 使用教程 Content Provider Code Generator 下载 Android Fragment Code Generator代码生成工具 名称 简介 下载地址 使用教程 Android Fragment Code Generator 下载 代码生成工具 名称 简介 下载地址 使用教程 Android KickstartR AndroidKickstartR帮助您快速创建Android应用程序并使用最流行的库进行配置。它创建和配置你的项目给你。只专注于代码! 下载 Android Button Maker Android Button Maker是一个在线生成Android应用按钮代码的工具。Android的API提供可绘制资源，其中的XML文件定义的几何形状，包括颜色，边框和梯度。这些按钮是在shape drawable XML代码基础上产生的相比通常的PNG按钮加载速度更快。您可以在设置面板中自定义按钮的属性和获得源代码。 下载 DroidDraw 下载 Android SVG to VectorDrawable 一个可以将SVG图片转换为Vector Drawable xml文件的在线工具。 下载 Android Native开发工具 名称 简介 下载地址 使用教程 Android++ 下载 Android测试工具 名称 简介 下载地址 使用教程 Appurify 下载 Monkey 下载 Testin 下载 Spoon 下载 Little Eye 下载 易测云 下载 Emmagee 下载 Apk View Tracer 下载 APT APT是一个Android平台高效性能测试组件，提供丰富实用的功能，适用于开发自测、定位性能瓶颈；测试人员完成性能基准测试、竞品对比测试。 下载 教程 GT GT（随身调）是APP的随身调测平台，它是直接运行在手机上的“集成调测环境”(IDTE, Integrated Debug&amp;Test Environment)。 下载 教程 Mobile-Checker 移动端页面检查工具,可以选择三种屏幕规格，通过工具发现网站在移动端存在的问题。 下载 Android多渠道打包工具 名称 简介 下载地址 使用教程 Umeng多渠道打包工具 下载 AppTools具 下载 package_tool 下载 RyApkTool 下载 兰贝壳儿 下载 教程 Android Bug日志收集工具 名称 简介 下载地址 使用教程 Crashlytics 下载 ACRA 下载 ChkBugReport 下载 Log Collector 下载 Android Crash Catcher 下载 其他语言开发Android应用工具 名称 简介 下载地址 使用教程 Xamarin 下载 Basic4android 下载 Scripting Layer 下载 Ruby Rhodes 移动设备上的Ruby 下载 PHP for Android 下载 Codename One 下载 Touchqode 下载 App Inventor 下载 传感器模拟工具 名称 简介 下载地址 使用教程 Sensor Simulator 独立的Java应用程序，它模拟传感器的数据并将它们传送到Android模拟器。 下载 Android串口开发工具 名称 简介 下载地址 使用教程 Android Serialport Api 下载 图片尺寸处理工具 名称 简介 下载地址 使用教程 9-Patch Resizer 下载 图片压缩工具 名称 简介 下载地址 使用教程 OptiPNG 下载 Pngcrush 下载 ImageOptim 下载 Tinypng 下载 资源清理工具 名称 简介 下载地址 使用教程 Android Lint 下载 Android Resource Cleaner 下载 Android Unused Resources 下载 Android Resource Remover 下载 px和dp转换/计算工具 名称 简介 下载地址 使用教程 Android dp px Calculator 下载 dp px converter 下载 pixelcalc 下载 androidpixels 下载 android dpi calculator 下载 DPI Calculator 下载 Android DPI Calculator插件 下载 Java To iOS 名称 简介 下载地址 使用教程 j2Objc 下载 RoboVM 下载 JSON/XML转换为POJO Class工具 名称 简介 下载地址 使用教程 jsonschema2pojo 下载 Convert XML or JSON to Java Pojo 下载 Java DAO Generate工具 名称 简介 下载地址 使用教程 Generate Java DAO for relational data table 下载 Chrome插件Android插件 名称 简介 下载地址 使用教程 Android SDK Search 下载 Android Resource Navigator 下载 ADB Plugin for remote debugging Chrome on Android 下载 Mobile/RWD Tester 下载 ExtensionAndroid SDK Samples Search 下载 Android Developer Improvements 下载 Android downloader 下载 JSON/XML格式化插件 名称 简介 下载地址 使用教程 JSONView 下载 JSON Formatter 下载 JSON Viewer 下载 JSON Finder 下载 Encode/Decode插件 名称 简介 下载地址 使用教程 Base64 Encode and Decode 下载 Git 名称 简介 下载地址 使用教程 Git Cheat Sheet 下载 GuidesGoogle Java编程风格指南中文版英文地址：http://google-styleguide.googlecode.com/svn/trunk/javaguide.html 地址0：http://hawstein.com/posts/google-java-style.html 地址1：https://github.com/codeset/google-java-styleguide Android Developers 国内镜像站地址: Android Developers 国内镜像站 Android Api中文版地址：http://www.embeddedlinux.org.cn/androidapi/ ####Android API指南中文版 地址：http://api.apkbus.com/guide Android Proguard混淆配置指南地址：https://github.com/inferjay/AndroidProguardGuide/ Gradle插件使用指南中文版地址：http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision Gradle User GuideGradle 1.12用户指南：http://pan.baidu.com/s/1dD7sC2d TutorialsAndroid学习之路地址：http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/ Google Android官方培训课程中文版地址：http://hukai.me/android-training-course-in-chinese/index.html Developing Android Apps地址：https://www.udacity.com/course/ud853 Java Design Patterns Samples in Java.Java Design Patterns Design Design ToolsPhotoshop插件 名称 简介 下载地址 使用教程 Cut&amp;Slice 切图神器 下载 DevRocket 切图神器 下载 Cutterman 最好用的切图工具 下载 Ink 下载 Corner Editor 路径圆角编辑工具 下载1 下载1 GuideGuide 辅助线工具 下载 Assistor PS 下载 Skeuomorphism.it 下载 QuickGuide 下载 Long Shadow Generator 长投影效果生成插件 下载 android_resizer_toolkit 下载 android-ps-tools 一些方便Android UI设计的PhototShop插件。 下载 LayerCraft A Photoshop plugin to export UI assets from layers 下载 矢量图设计工具 名称 简介 下载地址 使用教程 Sketch 3 下载 Affinity Designer 下载 Gravit 下载 Adobe Illustrator 下载 切图工具 名称 简介 下载地址 使用教程 Slicy 下载 设计稿尺寸标注工具 名称 简介 下载地址 使用教程 马克鳗 下载 PxCook像素大厨 UI设计师效率提升利器，让你专注于设计本质，不再为标注切图而烦恼，从设计到实现一气呵成 下载 使用教程 原型设计工具 名称 简介 下载地址 使用教程 Axure 下载 Fluid UI 下载 Briefs 下载 Flinto 下载 Balsamiq Mockups 下载 AppCooker 下载 Proto.io 下载 UXPin 下载 InVision 下载 POP 下载 快现 下载 Composite 下载 OmniGraffle 下载 Marvelapp 下载 Justinmind 下载 Form 下载 Prott 下载 Composite 下载 Avocado 下载 Pixate 下载 交互设计工具 名称 简介 下载地址 使用教程 Framer Studio 下载 Quartz Composer 下载 Origami 下载 jQC 下载 UI效果预览工具 名称 简介 下载地址 使用教程 Android Design Preview 下载 PS Play 下载 Pixl Preview 下载 Skala Preview 下载 LiveView 下载 配色工具 名称 简介 下载地址 使用教程 Android Material Design可视化调色板 下载 Android Material Design Colours.xml 下载 Colorube配色神器 下载 Adobe Kuler 下载 ColorSchemer Studio 下载 Piknik 下载 设计稿版本控制工具 名称 简介 下载地址 使用教程 LayerVault 下载 图标处理工具 名称 简介 下载地址 使用教程 Icon Slate 下载 在线Icon库 名称 简介 下载地址 使用教程 IconFont 下载 NounProject 下载 取色工具 名称 简介 下载地址 使用教程 ColorSnapper 下载 不透明度16进制值 不透明度 16进制值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 出自：http://stackoverflow.com/questions/5445085/understanding-colors-in-android-6-chars 手机To电脑同步预览工具 名称 简介 下载地址 使用教程 Reflector 下载 x-Mirage 下载 AirServer 下载 BBQScreen 下载 Gif图片录制工具 名称 简介 下载地址 使用教程 LICEcap 下载 GifCam 下载 Android Tool 下载 UI Programming LanguageUILang TutorialsHackDesign GamesThe Bezier Game 一个帮助你练习PS里钢笔工具的小游戏。 GuidesAndroid设计指南非官方简体中文版Topfun镜像地址：http://www.topfun.us/adchs/index.html Github镜像地址：http://adchs.github.io ApkBus镜像地址：http://www.apkbus.com/design/ Segmentfault镜像地址：http://mirrors.segmentfault.com/adchs/ 多看阅读镜像地址：http://www.duokan.com/book/47790 Android Cheatsheet for Graphic Designers地址:http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/ Google Material Design 中文版地址：http://design.1sters.com 地址： http://www.ui.cn/Material/ Designer’s Guide To dpi地址：http://sebastien-gabriel.com/designers-guide-to-dpi/home Email Design Guide地址：http://mailchimp.com/resources/email-design-guide/ Free Design ResourcesGoogle Material Design 素材(感谢 @SanityD) Material Design Icon Templates Material Design的图标集 Material Design UI Kit for Sketch Nexus 5 template for Sketch Free Design Resources 434 SVG icons UI Cloun 161个国内外社交网站矢量图标 250 free icons in 5 sizes and 14 colors MINIMALISTIC EVERYDAY ICONS Icons4Android Books Free Programming Books 一堆免费的Android开发相关的电子书。 50 Android Hacks 50 Android Hacks这本书分12个部分介绍了50个Android开发的小技巧。 免费的编程中文书籍索引 Disclaimer 版权归原作者所有，这里仅做收集整理，欢迎自由转载-非商用-非衍生-保持署名和链接。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"你真的了解AsyncTask吗","date":"2017-07-26T12:09:45.000Z","path":"2017/07/26/你真的了解AsyncTask吗/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 你真的了解AsyncTask?虽说现在做网络请求有了Volley全家桶和OkHttp这样好用的库，但是在处理其他后台任务以及与UI交互上，还是需要用到AsyncTask。但是你真的了解AsyncTask吗？ AsyncTask的实现几经修改，因此在不同版本的Android系统上表现各异；我相信，任何一个用户量上千万的产品绝对不会在代码里面使用系统原生的AsynTask，因为它蛋疼的兼容性以及极高的崩溃率实在让人不敢恭维。本文将带你了解AsyncTask背后的原理，并给出一个久经考验的AsyncTask修改版。 AsyncTask是什么？AsyncTask到底是什么呢？很简单，它不过是对线程池和Handler的封装；用线程池来处理后台任务，用Handler来处理与UI的交互。线程池使用的是Executor接口，我们先了解一下线程池的特性。 线程池ThreadPoolExecutorJDK5带来的一大改进就是Java的并发能力，它提供了三种并发武器：并发框架Executor，并发集合类型如ConcurrentHashMap，并发控制类如CountDownLatch等；圣经《Effective Java》也说，尽量使用Exector而不是直接用Thread类进行并发编程。 AsyncTask内部也使用了线程池处理并发；线程池通过ThreadPoolExector类构造，这个构造函数参数比较多，它允许开发者对线程池进行定制，我们先看看这每个参数是什么意思，然后看看Android是以何种方式定制的。 ThreadPoolExecutor的其他构造函数最终都会调用如下的构造函数完成对象创建工作： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize: 核心线程数目，即使线程池没有任务，核心线程也不会终止（除非设置了allowCoreThreadTimeOut参数）可以理解为“常驻线程” maximumPoolSize: 线程池中允许的最大线程数目；一般来说，线程越多，线程调度开销越大；因此一般都有这个限制。 keepAliveTime: 当线程池中的线程数目比核心线程多的时候，如果超过这个keepAliveTime的时间，多余的线程会被回收；这些与核心线程相对的线程通常被称为缓存线程 unit: keepAliveTime的时间单位 workQueue: 任务执行前保存任务的队列；这个队列仅保存由execute提交的Runnable任务 threadFactory: 用来构造线程池的工厂；一般都是使用默认的； handler: 当线程池由于线程数目和队列限制而导致后续任务阻塞的时候，线程池的处理方式。 那么，当一个新的任务到达的时候，线程池中的线程是如何调度的呢？（别慌，讲这么一大段线程池的知识，是为了理解AsyncTask；Be Patient） 如果线程池中线程的数目少于corePoolSize，就算线程池中有其他的没事做的核心线程，线程池还是会重新创建一个核心线程；直到核心线程数目到达corePoolSize（常驻线程就位） 如果线程池中线程的数目大于或者等于corePoolSize，但是工作队列workQueue没有满，那么新的任务会放在队列workQueue中，按照FIFO的原则依次等待执行；（当有核心线程处理完任务空闲出来后，会检查这个工作队列然后取出任务默默执行去） 如果线程池中线程数目大于等于corePoolSize，并且工作队列workQueue满了，但是总线程数目小于maximumPoolSize，那么直接创建一个线程处理被添加的任务。 如果工作队列满了，并且线程池中线程的数目到达了最大数目maximumPoolSize，那么就会用最后一个构造参数handler处理；默认的处理方式是直接丢掉任务，然后抛出一个异常。 总结起来，也即是说，当有新的任务要处理时，先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize。另外，当线程池中的线程数量大于 corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量。 我们以API 22为例，看一看AsyncTask里面的线程池是以什么参数构造的；AsyncTask里面有“两个”线程池；一个THREAD_POOL_EXECUTOR一个SERIAL_EXECUTOR；之所以打引号，是因为其实SERIAL_EXECUTOR也使用THREAD_POOL_EXECUTOR实现的，只不过加了一个队列弄成了串行而已，那么这个THREAD_POOL_EXECUTOR是如何构造的呢？ 123456789private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 可以看到，AsyncTask里面线程池是一个核心线程数为CPU + 1，最大线程数为CPU * 2 + 1，工作队列长度为128的线程池；并且没有传递handler参数，那么使用的就是默认的Handler（拒绝执行). 那么问题来了： 如果任务过多，那么超过了工作队列以及线程数目的限制导致这个线程池发生阻塞，那么悲剧发生，默认的处理方式会直接抛出一个异常导致进程挂掉。假设你自己写一个异步图片加载的框架，然后用AsyncTask实现的话，当你快速滑动ListView的时候很容易发生这种异常；这也是为什么各大ImageLoader都是自己写线程池和Handlder的原因。 这个线程池是一个静态变量；那么在同一个进程之内，所有地方使用到的AsyncTask默认构造函数构造出来的AsyncTask都使用的是同一个线程池，如果App模块比较多并且不加控制的话，很容易满足第一条的崩溃条件；如果你不幸在不同的AsyncTask的doInBackgroud里面访问了共享资源，那么就会发生各种并发编程问题。 在AsyncTask全部执行完毕之后，进程中还是会常驻corePoolSize个线程；在Android 4.4 （API 19）以下，这个corePoolSize是hardcode的，数值是5；API 19改成了cpu + 1；也就是说，在Android 4.4以前；如果你执行了超过五个AsyncTask；然后啥也不干了，进程中还是会有5个AsyncTask线程；不信，你看： HandlerAsyncTask里面的handler很简单，如下（API 22代码）： 12345private static final InternalHandler sHandler = new InternalHandler();public InternalHandler() &#123; super(Looper.getMainLooper());&#125; 注意，这里直接用的主线程的Looper；如果去看API 22以下的代码，会发现它没有这个构造函数，而是使用默认的；默认情况下，Handler会使用当前线程的Looper，如果你的AsyncTask是在子线程创建的，那么很不幸，你的onPreExecute和onPostExecute并非在UI线程执行，而是被Handler post到创建它的那个线程执行；如果你在这两个线程更新了UI，那么直接导致崩溃。这也是大家口口相传的AsyncTask必须在主线程创建的原因。 另外，AsyncTask里面的这个Handler是一个静态变量，也就是说它是在类加载的时候创建的；如果在你的APP进程里面，以前从来没有使用过AsyncTask，然后在子线程使用AsyncTask的相关变量，那么导致静态Handler初始化，如果在API 16以下，那么会出现上面同样的问题；这就是AsyncTask必须在主线程初始化 的原因。 事实上，在Android 4.1(API 16)以后，在APP主线程ActivityThread的main函数里面，直接调用了AscynTask.init函数确保这个类是在主线程初始化的；另外，init这个函数里面获取了InternalHandler的Looper，由于是在主线程执行的，因此，AsyncTask的Handler用的也是主线程的Looper。这个问题从而得到彻底的解决。 AsyncTask是并行执行的吗？现在知道AsyncTask内部有一个线程池，那么派发给AsyncTask的任务是并行执行的吗？ 答案是不确定。在Android 1.5刚引入的时候，AsyncTask的execute是串行执行的；到了Android 1.6直到Android 2.3.2，又被修改为并行执行了，这个执行任务的线程池就是THREAD_POOL_EXECUTOR，因此在一个进程内，所有的AsyncTask都是并行执行的；但是在Android 3.0以后，如果你使用execute函数直接执行AsyncTask，那么这些任务是串行执行的；（你说蛋疼不）源代码如下： 123public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 这个sDefaultExecutor就是用来执行任务的线程池，那么它的值是什么呢？继续看代码： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 因此结论就来了：Android 3.0以上，AsyncTask默认并不是并行执行的； 为什么默认不并行执行？也许你不理解，为什么AsyncTask默认把它设计为串行执行的呢？ 由于一个进程内所有的AsyncTask都是使用的同一个线程池执行任务；如果同时有几个AsyncTask一起并行执行的话，恰好AysncTask的使用者在doInbackgroud里面访问了相同的资源，但是自己没有处理同步问题；那么就有可能导致灾难性的后果！ 由于开发者通常不会意识到需要对他们创建的所有的AsyncTask对象里面的doInbackgroud做同步处理，因此，API的设计者为了避免这种无意中访问并发资源的问题，干脆把这个API设置为默认所有串行执行的了。如果你明确知道自己需要并行处理任务，那么你需要使用executeOnExecutor(Executor exec,Params... params)这个函数来指定你用来执行任务的线程池，同时为自己的行为负责。（处理同步问题） 实际上《Effective Java》里面有一条原则说的就是这种情况：不要在同步块里面调用不可信的外来函数。这里明显违背了这个原则：AsyncTask这个类并不知道使用者会在doInBackgroud这个函数里面做什么，但是对它的行为做了某种假设。 如何让AsyncTask并行执行？正如上面所说，如果你确定自己做好了同步处理，或者你没有在不同的AsyncTask里面访问共享资源，需要AsyncTask能够并行处理任务的话，你可以用带有两个参数的executeOnExecutor执行任务： 1234567new AsyncTask&lt;Void, Void, Vo @Override protected Void doInBackground(Void... params) &#123; // do something return null; &#125;&#125;.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR); 更好的AsyncTask从上面的分析得知，AsyncTask有如下问题： 默认的AsyncTask如果处理的任务过多，会导致程序直接崩溃； AsyncTask类必须在主线程初始化，必须在主线程创建，不然在API 16以下很大概率崩溃。 如果你曾经使用过AsyncTask，以后不用了；在Android 4.4以下，进程内也默认有5个AsyncTask线程；在Android 4.4以上，默认有CPU + 1个线程。 Android 3.0以上的AsyncTask默认是串行执行任务的；如果要并行执行需要调用低版本没有的API，处理麻烦。 因此我们对系统的AsyncTask做了一些修改，在不同Android版本提供一致的行为，并且提高了使用此类的安全性，主要改动如下： 添加对于任务过多导致崩溃的异常保护；在这里进行必要的数据统计上报工作；如果出现这个问题，说明AsyncTask不适合这种场景了，需要考虑重构； 移植API 22对于Handler的处理；这样就算在线程创建异步任务，也不会有任何问题； 提供串行执行和并行执行的execute方法；默认串行执行，如果明确知道自己在干什么，可以使用executeParallel并行执行。 在doInbackgroud里面频繁崩溃的地方加上try..catch；自己处理数据上报工作。 完整代码见gist，BetterAsyncTask 原文地址：http://weishu.me/2016/01/18/dive-into-asynctask/ 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"ViewDragHelper源码解析","date":"2017-07-26T12:08:18.000Z","path":"2017/07/26/ViewDragHelper源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 ViewDragHelper源码解析1. 简介我们了解了ViewDragHelper是可以帮助我们处理各种拖拽事件的类.使用好ViewDragHelper能帮助我们做出各种酷炫的交互,今天我们就来分析一下ViewDragHelper的使用与实现 2. 使用方法我们这里就以翔总的这篇文章中的例子来介绍一下ViewDragHelper的使用.另外,本文中的demo可以在这里找到 首先我们创建一个DragLayout类并继承自LinearLayout,然后我们准备在DragLayout放置三个View第一个用来被我们拖动然后停止在松手的位置,第二个可以被我们拖动,松手的时候滑动到指定位置,第三个只可以通过触摸边缘来进行拖动, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class DragLayout extends LinearLayout &#123; private ViewDragHelper mDragger; private View mDragView; private View mAutoBackView; private View mEdgeTrackerView; private Point mAutoBackOriginPos = new Point(); public DragLayout(Context context) &#123; this(context, null); &#125; public DragLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initViewDragHelper(); &#125; private void initViewDragHelper() &#123; mDragger = ViewDragHelper.create(this,myCallback); mDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL); &#125; ViewDragHelper.Callback myCallback = new ViewDragHelper.Callback() &#123; @Override //child为当前触摸区域下的View,如果返回true,就可以拖拽. public boolean tryCaptureView(View child, int pointerId) &#123; return child == mDragView || child == mAutoBackView; &#125; //松手时的回调 @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; if (releasedChild == mAutoBackView) &#123; mDragger.settleCapturedViewAt(mAutoBackOriginPos.x, mAutoBackOriginPos.y); invalidate(); &#125; &#125; //边缘触摸开始时的回调 @Override public void onEdgeDragStarted(int edgeFlags, int pointerId) &#123; mDragger.captureChildView(mEdgeTrackerView, pointerId); &#125; //获取水平方向允许拖拽的区域,这里是父布局的宽-子控件的宽 @Override public int getViewHorizontalDragRange(View child) &#123; return getMeasuredWidth() - child.getMeasuredWidth(); &#125; //获取垂直方向允许拖拽的范围 @Override public int getViewVerticalDragRange(View child) &#123; return getMeasuredHeight() - child.getMeasuredHeight(); &#125; //left为child即将移动到的水平位置的值,但是返回值会最终决定移动到的值 //这里直接返回了left @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; return left; &#125; //同上只是这里是垂直方向 @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; return top; &#125; &#125;; @Override public void computeScroll() &#123; if (mDragger.continueSettling(true)) &#123; invalidate(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragger.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; mDragger.processTouchEvent(event); return true; &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); mDragView = getChildAt(0); mAutoBackView = getChildAt(1); mEdgeTrackerView = getChildAt(2); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mAutoBackOriginPos.x = mAutoBackView.getLeft(); mAutoBackOriginPos.y = mAutoBackView.getTop(); &#125;&#125; 我们首先在构造方法里传入了当前类的对象和我们定义的ViewDragHelper.Callback对象初始化了我们的ViewDragHelper,然后我们希望所有的边缘触摸都能触发mEdgeTrackerView的拖动,所以我们紧接着调用了mDragger.setEdgeTrackingEnabled(ViewDragHelper.EDGE_ALL);方法. 在我们定义的Callback中,有多个回调方法,每个回调方法都有它的作用,在代码里注释比较清楚了，我们下面也会解析每一个Callback中回调方法的作用. 第三步我们需要在onInterceptTouchEvent()方法和onTouchEvent()将事件委托给ViewDragHelper去处理,这样ViewDragHelper才能根据响应的事件并回调我们自己编写的Callback接口来进行响应的处理, 由于ViewDragHelper中的滑动是交给Srcoller类来处理的所以这里我们要重写computeScroll()方法,配合Scroller完成滚动动画. 最后在onFinishInflate()里获取到我们的View对象即可. 3. 类关系图由于就一个类类图我们就不画了,但是作为一个强迫症患者,这个标题必须有… 4. 源码分析4.1 ViewDragHelper.Callback的实现在分析ViewDragHelper之前,我们先来分析一下Callback的定义,看看Callback都定义了哪些方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public static abstract class Callback &#123; //当View的拖拽状态改变时回调,state为STATE_IDLE,STATE_DRAGGING,STATE_SETTLING的一种 //STATE_IDLE: 当前未被拖拽 //STATE_DRAGGING：正在被拖拽 //STATE_SETTLING: 被拖拽后需要被安放到一个位置中的状态 public void onViewDragStateChanged(int state) &#123;&#125; //当View被拖拽位置发生改变时回调 //changedView ：被拖拽的View //left : 被拖拽后View的left边缘坐标 //top : 被拖拽后View的top边缘坐标 //dx : 拖动的x偏移量 //dy : 拖动的y偏移量 public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123;&#125; //当一个View被捕获到准备开始拖动时回调, //capturedChild : 捕获的View //activePointerId : 对应的PointerId public void onViewCaptured(View capturedChild, int activePointerId) &#123;&#125; //当被捕获拖拽的View被释放是回调 //releasedChild : 被释放的View //xvel : 释放View的x方向上的加速度 //yvel : 释放View的y方向上的加速度 public void onViewReleased(View releasedChild, float xvel, float yvel) &#123;&#125; //如果parentView订阅了边缘触摸,则如果有边缘触摸就回调的接口 //edgeFlags : 当前触摸的flag 有: EDGE_LEFT,EDGE_TOP,EDGE_RIGHT,EDGE_BOTTOM //pointerId : 用来描述边缘触摸操作的id public void onEdgeTouched(int edgeFlags, int pointerId) &#123;&#125; //是否锁定该边缘的触摸,默认返回false,返回true表示锁定 public boolean onEdgeLock(int edgeFlags) &#123; return false; &#125; //边缘触摸开始时回调 //edgeFlags : 当前触摸的flag 有: EDGE_LEFT,EDGE_TOP,EDGE_RIGHT,EDGE_BOTTOM //pointerId : 用来描述边缘触摸操作的id public void onEdgeDragStarted(int edgeFlags, int pointerId) &#123;&#125; //在寻找当前触摸点下的子View时会调用此方法，寻找到的View会提供给tryCaptureViewForDrag()来尝试捕获。 //如果需要改变子View的遍历查询顺序可改写此方法，例如让下层的View优先于上层的View被选中。 public int getOrderedChildIndex(int index) &#123; return index; &#125; //获取被拖拽View child 的水平拖拽范围,返回0表示无法被水平拖拽 public int getViewHorizontalDragRange(View child) &#123; return 0; &#125; //获取被拖拽View child 的垂直拖拽范围,返回0表示无法被水平拖拽 public int getViewVerticalDragRange(View child) &#123; return 0; &#125; //尝试捕获被拖拽的View public abstract boolean tryCaptureView(View child, int pointerId); //决定拖拽View在水平方向上应该移动到的位置 //child : 被拖拽的View //left : 期望移动到位置的View的left值 //dx : 移动的水平距离 //返回值 : 直接决定View在水平方向的位置 public int clampViewPositionHorizontal(View child, int left, int dx) &#123; return 0; &#125; //决定拖拽View在垂直方向上应该移动到的位置 //child : 被拖拽的View //top : 期望移动到位置的View的top值 //dy : 移动的垂直距离 //返回值 : 直接决定View在垂直方向的位置 public int clampViewPositionVertical(View child, int top, int dy) &#123; return 0; &#125;&#125; 想必注释已经很清楚了,正是这些回调方法,再结合ViewDragHelper中的各种方法,来帮助我们实现各种各样的拖拽的效果。 4.2 shouldInterceptTouchEvent()方法的实现在这里我们假设大家都清楚了Android的事件分发机制,如果不清楚请看这里,要想处理触摸事件,我们需要在onInterceptTouchEvent(MotionEvent ev)方法里判断是否需要拦截这次触摸事件,如果此方法返回true则触摸事件将会交给onTouchEvent(MotionEvent event)处理,这样我们就能处理触摸事件了,所以我们在上面的使用方法里会这样写: 1234567891011@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragger.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; mDragger.processTouchEvent(event); return true;&#125; 这样就将是否拦截触摸事件,以及处理触摸事件委托给ViewDragHelper来处理了,所以我们先来看看ViewDragHelper中shouldInterceptTouchEvent();方法的实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public boolean shouldInterceptTouchEvent(MotionEvent ev) &#123; //获取action final int action = MotionEventCompat.getActionMasked(ev); //获取action对应的index final int actionIndex = MotionEventCompat.getActionIndex(ev); //如果是按下的action则重置一些信息,包括各种事件点的数组 if (action == MotionEvent.ACTION_DOWN) &#123; // Reset things for a new event stream, just in case we didn't get // the whole previous stream. cancel(); &#125; //初始化mVelocityTracker if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); //根据action来做相应的处理 switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; final float x = ev.getX(); final float y = ev.getY(); //获取这个事件对应的pointerId,一般情况下只有一个手指触摸时为0 //两个手指触摸时第二个手指触摸返回的pointerId为1，以此类推 final int pointerId = MotionEventCompat.getPointerId(ev, 0); //保存点的数据 //TODO (1) saveInitialMotion(x, y, pointerId); //获取当前触摸点下最顶层的子View //TODO (2) final View toCapture = findTopChildUnder((int) x, (int) y); //如果toCapture是已经捕获的View,而且正在处于被释放状态 //那么就重新捕获 if (toCapture == mCapturedView &amp;&amp; mDragState == STATE_SETTLING) &#123; tryCaptureViewForDrag(toCapture, pointerId); &#125; //如果触摸了边缘,回调callback的onEdgeTouched()方法 final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched &amp; mTrackingEdges) != 0) &#123; mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId); &#125; break; &#125; //当又有一个手指触摸时 case MotionEventCompat.ACTION_POINTER_DOWN: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); final float x = MotionEventCompat.getX(ev, actionIndex); final float y = MotionEventCompat.getY(ev, actionIndex); //保存触摸信息 saveInitialMotion(x, y, pointerId); //因为同一时间ViewDragHelper只能操控一个View,所以当有新的手指触摸时 //只讨论当无触摸发生时,回调边缘触摸的callback //或者正在处于释放状态时重新捕获View if (mDragState == STATE_IDLE) &#123; final int edgesTouched = mInitialEdgesTouched[pointerId]; if ((edgesTouched &amp; mTrackingEdges) != 0) &#123; mCallback.onEdgeTouched(edgesTouched &amp; mTrackingEdges, pointerId); &#125; &#125; else if (mDragState == STATE_SETTLING) &#123; // Catch a settling view if possible. final View toCapture = findTopChildUnder((int) x, (int) y); if (toCapture == mCapturedView) &#123; tryCaptureViewForDrag(toCapture, pointerId); &#125; &#125; break; &#125; //当手指移动时 case MotionEvent.ACTION_MOVE: &#123; if (mInitialMotionX == null || mInitialMotionY == null) break; // First to cross a touch slop over a draggable view wins. Also report edge drags. //得到触摸点的数量,并循环处理,只处理第一个发生了拖拽的事件 final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int pointerId = MotionEventCompat.getPointerId(ev, i); final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); //获得拖拽偏移量 final float dx = x - mInitialMotionX[pointerId]; final float dy = y - mInitialMotionY[pointerId]; //获取当前触摸点下最顶层的子View final View toCapture = findTopChildUnder((int) x, (int) y); //如果找到了最顶层View,并且产生了拖动(checkTouchSlop()返回true) //TODO (3) final boolean pastSlop = toCapture != null &amp;&amp; checkTouchSlop(toCapture, dx, dy); if (pastSlop) &#123; //根据callback的四个方法getView[Horizontal|Vertical]DragRange和 //clampViewPosition[Horizontal|Vertical]来检查是否可以拖动 final int oldLeft = toCapture.getLeft(); final int targetLeft = oldLeft + (int) dx; final int newLeft = mCallback.clampViewPositionHorizontal(toCapture, targetLeft, (int) dx); final int oldTop = toCapture.getTop(); final int targetTop = oldTop + (int) dy; final int newTop = mCallback.clampViewPositionVertical(toCapture, targetTop, (int) dy); final int horizontalDragRange = mCallback.getViewHorizontalDragRange( toCapture); final int verticalDragRange = mCallback.getViewVerticalDragRange(toCapture); //如果都不允许移动则跳出循环 if ((horizontalDragRange == 0 || horizontalDragRange &gt; 0 &amp;&amp; newLeft == oldLeft) &amp;&amp; (verticalDragRange == 0 || verticalDragRange &gt; 0 &amp;&amp; newTop == oldTop)) &#123; break; &#125; &#125; //记录并回调是否有边缘触摸 reportNewEdgeDrags(dx, dy, pointerId); if (mDragState == STATE_DRAGGING) &#123; // Callback might have started an edge drag break; &#125; //如果产生了拖动则调用tryCaptureViewForDrag() //TODO (4) if (pastSlop &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break; &#125; &#125; //保存触摸点的信息 saveLastMotion(ev); break; &#125; //当有一个手指抬起时,清除这个手指的触摸数据 case MotionEventCompat.ACTION_POINTER_UP: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); clearMotionHistory(pointerId); break; &#125; //清除所有触摸数据 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: &#123; cancel(); break; &#125; &#125; //如果mDragState等于正在拖拽则返回true return mDragState == STATE_DRAGGING;&#125; 上面就是整个shouldInterceptTouchEvent()的实现,上面的注释也足够清楚了,我们这里就先不分析某一种触摸事件,大家可以看到我上面留了几个TODO,下文会一起分析,这里我假设大家都已经对触摸事件分发处理都有充分的理解了,我们下面就直接看ViewDragHelper里processTouchEvent()方法的实现. 4.3 processTouchEvent()方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public void processTouchEvent(MotionEvent ev) &#123; final int action = MotionEventCompat.getActionMasked(ev); final int actionIndex = MotionEventCompat.getActionIndex(ev); ...（省去部分代码） switch (action) &#123; case MotionEvent.ACTION_DOWN: &#123; ...（省去部分代码） break; &#125; case MotionEventCompat.ACTION_POINTER_DOWN: &#123; ...（省去部分代码） break; &#125; case MotionEvent.ACTION_MOVE: &#123; //如果现在已经是拖拽状态 if (mDragState == STATE_DRAGGING) &#123; final int index = MotionEventCompat.findPointerIndex(ev, mActivePointerId); final float x = MotionEventCompat.getX(ev, index); final float y = MotionEventCompat.getY(ev, index); final int idx = (int) (x - mLastMotionX[mActivePointerId]); final int idy = (int) (y - mLastMotionY[mActivePointerId]); //拖拽至指定位置 //TODO (5) dragTo(mCapturedView.getLeft() + idx, mCapturedView.getTop() + idy, idx, idy); saveLastMotion(ev); &#125; else &#123; // Check to see if any pointer is now over a draggable view. //如果还不是拖拽状态,就检测是否经过了一个View final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int pointerId = MotionEventCompat.getPointerId(ev, i); final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); final float dx = x - mInitialMotionX[pointerId]; final float dy = y - mInitialMotionY[pointerId]; reportNewEdgeDrags(dx, dy, pointerId); if (mDragState == STATE_DRAGGING) &#123; // Callback might have started an edge drag. break; &#125; final View toCapture = findTopChildUnder((int) x, (int) y); if (checkTouchSlop(toCapture, dx, dy) &amp;&amp; tryCaptureViewForDrag(toCapture, pointerId)) &#123; break; &#125; &#125; saveLastMotion(ev); &#125; break; &#125; //当多个手指中的一个手机松开时 case MotionEventCompat.ACTION_POINTER_UP: &#123; final int pointerId = MotionEventCompat.getPointerId(ev, actionIndex); //如果当前点正在被拖拽,则再剩余还在触摸的点钟寻找是否正在View上 if (mDragState == STATE_DRAGGING &amp;&amp; pointerId == mActivePointerId) &#123; // Try to find another pointer that's still holding on to the captured view. int newActivePointer = INVALID_POINTER; final int pointerCount = MotionEventCompat.getPointerCount(ev); for (int i = 0; i &lt; pointerCount; i++) &#123; final int id = MotionEventCompat.getPointerId(ev, i); if (id == mActivePointerId) &#123; // This one's going away, skip. continue; &#125; final float x = MotionEventCompat.getX(ev, i); final float y = MotionEventCompat.getY(ev, i); if (findTopChildUnder((int) x, (int) y) == mCapturedView &amp;&amp; tryCaptureViewForDrag(mCapturedView, id)) &#123; newActivePointer = mActivePointerId; break; &#125; &#125; if (newActivePointer == INVALID_POINTER) &#123; // We didn't find another pointer still touching the view, release it. //如果没找到则释放View //TODO (6) releaseViewForPointerUp(); &#125; &#125; clearMotionHistory(pointerId); break; &#125; case MotionEvent.ACTION_UP: &#123; //如果是拖拽状态的释放则调用 //releaseViewForPointerUp() if (mDragState == STATE_DRAGGING) &#123; releaseViewForPointerUp(); &#125; cancel(); break; &#125; case MotionEvent.ACTION_CANCEL: &#123; if (mDragState == STATE_DRAGGING) &#123; dispatchViewReleased(0, 0); &#125; cancel(); break; &#125; &#125;&#125; 上面就是processTouchEvent()方法的实现,我们省去了部分大致与shouldInterceptTouchEvent()相同的逻辑代码,通过事件传递机制我们知道,如果程序已经进入到processTouchEvent()中,也就意味着触摸事件就不会再向下传递,都会交给此方法处理,所以在这里我们就需要处理拖拽事件了,通过上面的注释,我们也看到了在MotionEvent.ACTION_MOVE,MotionEventCompat.ACTION_POINTER_UP,MotionEvent.ACTION_UP和MotionEvent.ACTION_CANCEL都分别进行了处理 ,我们知道触摸事件大致的流程是: ACTION_DOWN -&gt; ACTION_MOVE -&gt; ... -&gt; ACTION_MOVE -&gt; ACTION_UP 再配合事件的分发机制,我们就能很清晰的分析出一次完整的事件调用过程,所以整个ViewDragHelper的拖拽过程也能很清晰的分为三个步骤: 捕获拖拽目标View -&gt; 拖拽目标View -&gt; 处理目标View释放操作 最后我们再分析上面两段代码的6个TODO: 4.4 saveInitialMotion()方法123456789101112private void saveInitialMotion(float x, float y, int pointerId) &#123; //确保各个数组的大小足够存放数据 ensureMotionHistorySizeForId(pointerId); //保存x坐标 mInitialMotionX[pointerId] = mLastMotionX[pointerId] = x; //保存y坐标 mInitialMotionY[pointerId] = mLastMotionY[pointerId] = y; //保存是否触摸到边缘 mInitialEdgesTouched[pointerId] = getEdgesTouched((int) x, (int) y); //保存当前id是否在触摸,用于后续验证 mPointersDown |= 1 &lt;&lt; pointerId;&#125; 4.5 findTopChildUnder()方法1234567891011public View findTopChildUnder(int x, int y) &#123; final int childCount = mParentView.getChildCount(); for (int i = childCount - 1; i &gt;= 0; i--) &#123; final View child = mParentView.getChildAt(mCallback.getOrderedChildIndex(i)); if (x &gt;= child.getLeft() &amp;&amp; x &lt; child.getRight() &amp;&amp; y &gt;= child.getTop() &amp;&amp; y &lt; child.getBottom()) &#123; return child; &#125; &#125; return null;&#125; 代码很简单就是根据x和y坐标和来找到指定View,注意这里回调了callback中的getOrderedChildIndex()方法,所以我们可以在这里返回指定的View的index. 4.6 checkTouchSlop()方法12345678910111213141516private boolean checkTouchSlop(View child, float dx, float dy) &#123; if (child == null) &#123; return false; &#125; final boolean checkHorizontal = mCallback.getViewHorizontalDragRange(child) &gt; 0; final boolean checkVertical = mCallback.getViewVerticalDragRange(child) &gt; 0; if (checkHorizontal &amp;&amp; checkVertical) &#123; return dx * dx + dy * dy &gt; mTouchSlop * mTouchSlop; &#125; else if (checkHorizontal) &#123; return Math.abs(dx) &gt; mTouchSlop; &#125; else if (checkVertical) &#123; return Math.abs(dy) &gt; mTouchSlop; &#125; return false;&#125; 用来根据mTouchSlop最小拖动的距离来判断是否属于拖动,mTouchSlop根据我们设定的灵敏度决定. 4.7 tryCaptureViewForDrag()方法12345678910111213141516boolean tryCaptureViewForDrag(View toCapture, int pointerId) &#123; //如果已经捕获该View 直接返回true if (toCapture == mCapturedView &amp;&amp; mActivePointerId == pointerId) &#123; // Already done! return true; &#125; //根据mCallback.tryCaptureView()方法来最终决定是否可以捕获View if (toCapture != null &amp;&amp; mCallback.tryCaptureView(toCapture, pointerId)) &#123; mActivePointerId = pointerId; //如果可以则调用captureChildView(),并返回true captureChildView(toCapture, pointerId); return true; &#125; return false;&#125; 可以看到如果可以捕获View则调用了captureChildView()方法: 1234567891011121314public void captureChildView(View childView, int activePointerId) &#123; if (childView.getParent() != mParentView) &#123; throw new IllegalArgumentException(\"captureChildView: parameter must be a descendant \" + \"of the ViewDragHelper's tracked parent view (\" + mParentView + \")\"); &#125; //赋值mCapturedView mCapturedView = childView; mActivePointerId = activePointerId; //回调callback mCallback.onViewCaptured(childView, activePointerId); //设定mDragState的状态为STATE_DRAGGING setDragState(STATE_DRAGGING);&#125; 如果程序执行到这里,就证明View已经处于拖拽状态了,后续的触摸操作,将直接根据mDragState为STATE_DRAGGING的状态处理. 4.8 dragTo()方法的实现123456789101112131415161718192021222324252627private void dragTo(int left, int top, int dx, int dy) &#123; int clampedX = left; int clampedY = top; final int oldLeft = mCapturedView.getLeft(); final int oldTop = mCapturedView.getTop(); if (dx != 0) &#123; //回调callback来决定View最终被拖拽的x方向上的偏移量 clampedX = mCallback.clampViewPositionHorizontal(mCapturedView, left, dx); //移动View ViewCompat.offsetLeftAndRight(mCapturedView, clampedX - oldLeft); &#125; if (dy != 0) &#123; //回调callback来决定View最终被拖拽的y方向上的偏移量 clampedY = mCallback.clampViewPositionVertical(mCapturedView, top, dy); //移动View ViewCompat.offsetTopAndBottom(mCapturedView, clampedY - oldTop); &#125; if (dx != 0 || dy != 0) &#123; final int clampedDx = clampedX - oldLeft; final int clampedDy = clampedY - oldTop; //回调callback mCallback.onViewPositionChanged(mCapturedView, clampedX, clampedY, clampedDx, clampedDy); &#125;&#125; 因为dragTo()方法是在processTouchEvent()中的MotionEvent.ACTION_MOVE case被调用所以当程序运行到这里时View就会不断的被拖动了。如果一旦手指释放则最终会调用releaseViewForPointerUp()方法 4.8 releaseViewForPointerUp()方法的实现123456789101112private void releaseViewForPointerUp() &#123; //计算出当前x和y方向上的加速度 mVelocityTracker.computeCurrentVelocity(1000, mMaxVelocity); final float xvel = clampMag( VelocityTrackerCompat.getXVelocity(mVelocityTracker, mActivePointerId), mMinVelocity, mMaxVelocity); final float yvel = clampMag( VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId), mMinVelocity, mMaxVelocity); dispatchViewReleased(xvel, yvel);&#125; 计算完加速度后就调用了dispatchViewReleased(): 123456789101112131415private void dispatchViewReleased(float xvel, float yvel) &#123; //设定当前正处于释放阶段 mReleaseInProgress = true; //回调callback的onViewReleased()方法 mCallback.onViewReleased(mCapturedView, xvel, yvel); mReleaseInProgress = false; //设定状态 if (mDragState == STATE_DRAGGING) &#123; // onViewReleased didn't call a method that would have changed this. Go idle. //如果onViewReleased()中没有调用任何方法,则状态设定为STATE_IDLE setDragState(STATE_IDLE); &#125;&#125; 所以最后释放后的处理交给了callback中的onViewReleased()方法,如果我们什么都不做,那么这个被拖拽的View就是停止在当前位置,或者我们可以调用ViewDragHelper提供给我们的这几个方法: settleCapturedViewAt(int finalLeft, int finalTop)以松手前的滑动速度为初速动，让捕获到的View自动滚动到指定位置。只能在Callback的onViewReleased()中调用。 flingCapturedView(int minLeft, int minTop, int maxLeft, int maxTop)以松手前的滑动速度为初速动，让捕获到的View在指定范围内fling。只能在Callback的onViewReleased()中调用。 smoothSlideViewTo(View child, int finalLeft, int finalTop)指定某个View自动滚动到指定的位置，初速度为0，可在任何地方调用。 引用自这篇文章,具体释放后的原理我们就不分析了,其实就是配合Scroller这个类来实现,具体也可以参照上面这篇文章。好,我们关于ViewDragHelper的源码分析就到这里. 5. 开源项目中的使用ViewDragHelper在各种关于拖拽和各种手势动画的开源库中使用广泛,我这里就简要列出一些,大家可以多去看看是如何使用ViewDragHelper的: SwipeBackLayout android-card-slide-panel FlowingDrawer 6. 个人评价ViewDragHelper的出现,大大简化了我们开发相关触摸和拖拽功能的复杂度和代码量,帮助我们比较容易的实现各种效果,让我们开发酷炫的交互更加容易了。但是从一些开源项目中发现,ViewDragHelper中还是有一些不足之处,比如给Scroller提供了一个固定的Interpolator,导致如果我们想实现例如反弹效果的话,还要把ViewDragHelper的代码拷贝一份并修改Interpolator,这样做肯定是不太好的.当然建议我们自己修改一个ViewDragHelper后如果项目里有多处使用,可以包装成一个提供给我们自己项目的模块使用,防止出现更多的多余代码 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"TextView源码解析","date":"2017-07-26T12:07:19.000Z","path":"2017/07/26/TextView源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 TextView源码解析1.简介 TextView作为Android系统上显示和排版文字以及提供对文字的增删改查、图文混排等功能的控件，内部是相对比较复杂的。这么一个复杂的控件自然需要依赖于一些其他的辅助类，例如：Layout以及Layout的相关子类、Span相关的类、MovementMethod接口、TransformationMethod接口等。这篇文章主要介绍TextView的结构和内部处理文字的流程以及TextView相关的辅助类在TextView处理文字过程中的作用。 2.TextView的内部结构和辅助类TextView内部除了继承自View的相关属性和measure、layout、draw步骤，还包括： Layout: TextView的文字排版、折行策略以及文本绘制都是在Layout里面完成的，TextView的自身测量也受Layout的影响。Layout是TextView执行setText方法后，由TextView内部创建的实例，并不能由外部提供。可以用getLayout()方法获取。 TransformationMethod: 用来处理最终的显示结果的类，例如显示密码的时候把密码转换成圆点。这个类并不直接影响TextView内部储存的Text，只影响显示的结果。 MovementMethod: 用来处理TextView内部事件响应的类，可以针对TextView内文本的某一个区域做软键盘输入或者触摸事件的响应。 Drawables: TextView的静态内部类，用来处理和储存TextView的CompoundDrawables,包括TextView的上下左右的Drawable以及错误提示的Drawable。 Spans: Spans并不是特定的某一个类或者实现了某一个接口的类。它可以是任意类型，Spans实际上做的事情是在TextView的内部的text的某一个区域做标记。其中有部分Spans可以影响TextView的绘制和测量，如ImageSpan、BackgroundColorSpan、AbsoluteSizeSpan。还有可以响应点击事件的ClickableSpan。 Editor: TextView作为可编辑文本控件的时候(EditText)，使用Editor来处理文本的区域选择处理和判断、拼写检查、弹出文本菜单等。 InputConnection: EditText的文本输入部分是在TextView中完成的。而InputConnection是软键盘和TextView之间的桥梁，所有的软键盘的输入文字、修改文字和删除文字都是通过InputConnection传递给TextView的。 3.TextView的onTouchEvent处理TextView内部能处理触摸事件的，包括自身的触摸处理、Editor的onTouchEvent、MovementMethod的onTouchEvent。Editor的onTouchEvent主要处理出于编辑状态下的触摸事件，比如点击选中、长按等。MovementMethod则主要负责文本内部有Span的时候的相关处理，比较常见的就是LinkMovementMethod处理ClickableSpan的点击事件。我们来看一下TextView内部对这些触摸事件的处理和优先级的分配： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public boolean onTouchEvent(MotionEvent event) &#123; final int action = event.getActionMasked(); //当Editor不为空的时候，给Editor的双击事件预设值 if (mEditor != null &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123; if (mFirstTouch &amp;&amp; (SystemClock.uptimeMillis() - mLastTouchUpTime) &lt;= ViewConfiguration.getDoubleTapTimeout()) &#123; mEditor.mDoubleTap = true; mFirstTouch = false; &#125; else &#123; mEditor.mDoubleTap = false; mFirstTouch = true; &#125; &#125; if (action == MotionEvent.ACTION_UP) &#123; mLastTouchUpTime = SystemClock.uptimeMillis(); &#125; //当Editor不为空，优先处理Editor的触摸事件 if (mEditor != null) &#123; mEditor.onTouchEvent(event); //由于Editor内部onTouchEvent实际上交给了mSelectionModifierCursorController处理，所以这边判断mSelectionModifierCursorController是否需要处理接下来的一系列事件，如果是则直接返回跳过下面的步骤 if (mEditor.mSelectionModifierCursorController != null &amp;&amp; mEditor.mSelectionModifierCursorController.isDragAcceleratorActive()) &#123; return true; &#125; &#125; final boolean superResult = super.onTouchEvent(event); //处理API 23新加入的InsertionActinoMode if (mEditor != null &amp;&amp; mEditor.mDiscardNextActionUp &amp;&amp; action == MotionEvent.ACTION_UP) &#123; mEditor.mDiscardNextActionUp = false; if (mEditor.mIsInsertionActionModeStartPending) &#123; mEditor.startInsertionActionMode(); mEditor.mIsInsertionActionModeStartPending = false; &#125; return superResult; &#125; final boolean touchIsFinished = (action == MotionEvent.ACTION_UP) &amp;&amp; (mEditor == null || !mEditor.mIgnoreActionUpEvent) &amp;&amp; isFocused(); if ((mMovement != null || onCheckIsTextEditor()) &amp;&amp; isEnabled() &amp;&amp; mText instanceof Spannable &amp;&amp; mLayout != null) &#123; boolean handled = false; //MovementMethod的触摸时间处理，如果MovementMethod类型是LinkMovementMethod则会处理文本内的所有ClickableSpan的点击 if (mMovement != null) &#123; handled |= mMovement.onTouchEvent(this, (Spannable) mText, event); &#125; final boolean textIsSelectable = isTextSelectable(); if (touchIsFinished &amp;&amp; mLinksClickable &amp;&amp; mAutoLinkMask != 0 &amp;&amp; textIsSelectable) &#123; //在文本可选择的情况下，默认是没有LinkMovementMethod来处理ClickableSpan相关的点击的，所以在文本可选择情况，TextView对所有的ClickableSpan进行统一处理 ClickableSpan[] links = ((Spannable) mText).getSpans(getSelectionStart(), getSelectionEnd(), ClickableSpan.class); if (links.length &gt; 0) &#123; links[0].onClick(this); handled = true; &#125; &#125; if (touchIsFinished &amp;&amp; (isTextEditable() || textIsSelectable)) &#123; final InputMethodManager imm = InputMethodManager.peekInstance(); viewClicked(imm); if (!textIsSelectable &amp;&amp; mEditor.mShowSoftInputOnFocus) &#123; handled |= imm != null &amp;&amp; imm.showSoftInput(this, 0); &#125; mEditor.onTouchUpEvent(event); handled = true; &#125; if (handled) &#123; return true; &#125; &#125; return superResult; &#125; 4.TextView的创建Layout的过程TextView内部并不仅仅只有一个用来显示文本内容的Layout，在设置了hint的时候，还需要有一个mHintLayout来处理hint的内容。如果设置了Ellipsize类型为Marquee时，还会有一个mSavedMarqueeModeLayout专门用来显示marquee效果。这些Layout都是通过内部的makeNewLayout方法来创建的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138protected void makeNewLayout(int wantWidth, int hintWidth BoringLayout.Metrics boring, BoringLayout.Metrics hintBoring, int ellipsisWidth, boolean bringIntoView) &#123; //如果当前有marquee动画，则先停止动画 stopMarquee(); mOldMaximum = mMaximum; mOldMaxMode = mMaxMode; mHighlightPathBogus = true; if (wantWidth &lt; 0) &#123; wantWidth = 0; &#125; if (hintWidth &lt; 0) &#123; hintWidth = 0; &#125; //文本对齐方式 Layout.Alignment alignment = getLayoutAlignment(); final boolean testDirChange = mSingleLine &amp;&amp; mLayout != null &amp;&amp; (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE); int oldDir = 0; if (testDirChange) oldDir = mLayout.getParagraphDirection(0); //检测是否设置了ellipsize boolean shouldEllipsize = mEllipsize != null &amp;&amp; getKeyListener() == null; final boolean switchEllipsize = mEllipsize == TruncateAt.MARQUEE &amp;&amp; mMarqueeFadeMode != MARQUEE_FADE_NORMAL; TruncateAt effectiveEllipsize = mEllipsize; if (mEllipsize == TruncateAt.MARQUEE &amp;&amp; mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) &#123; effectiveEllipsize = TruncateAt.END_SMALL; &#125; //文本方向 if (mTextDir == null) &#123; mTextDir = getTextDirectionHeuristic(); &#125; //创建主Layout mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == mEllipsize); //非常规的Marquee模式下，需要创建mSavedMarqueeModeLayout来保存marquee动画时所用的Layout，并且在动画期间把它和TextView的主Layout对换 if (switchEllipsize) &#123; TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE; mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize); &#125; shouldEllipsize = mEllipsize != null; mHintLayout = null; //判断是否需要创建hintLayout if (mHint != null) &#123; if (shouldEllipsize) hintWidth = wantWidth; if (hintBoring == UNKNOWN_BORING) &#123; hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring); if (hintBoring != null) &#123; mHintBoring = hintBoring; &#125; &#125; //判断是否为boring，如果是则创建BoringLayout if (hintBoring != null) &#123; if (hintBoring.width &lt;= hintWidth &amp;&amp; (!shouldEllipsize || hintBoring.width &lt;= ellipsisWidth)) &#123; if (mSavedHintLayout != null) &#123; mHintLayout = mSavedHintLayout. replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad); &#125; else &#123; mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad); &#125; mSavedHintLayout = (BoringLayout) mHintLayout; &#125; else if (shouldEllipsize &amp;&amp; hintBoring.width &lt;= hintWidth) &#123; if (mSavedHintLayout != null) &#123; mHintLayout = mSavedHintLayout. replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth); &#125; else &#123; mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth); &#125; &#125; &#125; //不是boring的状态下，用StaticLayout来创建 if (mHintLayout == null) &#123; StaticLayout.Builder builder = StaticLayout.Builder.obtain(mHint, 0, mHint.length(), mTextPaint, hintWidth) .setAlignment(alignment) .setTextDirection(mTextDir) .setLineSpacing(mSpacingAdd, mSpacingMult) .setIncludePad(mIncludePad) .setBreakStrategy(mBreakStrategy) .setHyphenationFrequency(mHyphenationFrequency); if (shouldEllipsize) &#123; builder.setEllipsize(mEllipsize) .setEllipsizedWidth(ellipsisWidth) .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE); &#125; mHintLayout = builder.build(); &#125; &#125; if (bringIntoView || (testDirChange &amp;&amp; oldDir != mLayout.getParagraphDirection(0))) &#123; registerForPreDraw(); &#125; //判断是否需要开始Marquee动画 if (mEllipsize == TextUtils.TruncateAt.MARQUEE) &#123; if (!compressText(ellipsisWidth)) &#123; final int height = mLayoutParams.height; if (height != LayoutParams.WRAP_CONTENT &amp;&amp; height != LayoutParams.MATCH_PARENT) &#123; startMarquee(); &#125; else &#123; mRestartMarquee = true; &#125; &#125; &#125; if (mEditor != null) mEditor.prepareCursorControllers(); &#125; TextView的布局创建过程涉及到一个boring的概念，boring是指布局所用的文本里面不包含任何Span，所有的文本方向都是从左到右的布局，并且仅需一行就能显示完全的布局。这种情况下，TextView会使用BoringLayout类来创建相关的布局，以节省不必要的文本测量以及文本折行、Span宽度、文本方向等的计算。下面我们来看一下makeNewLayout中使用频率比较高的makeSingleLayout的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Layout makeSingleLayout(int wantWidth, BoringLayout.Metrics boring, int ellipsisWidth, Layout.Alignment alignment, boolean shouldEllipsize, TruncateAt effectiveEllipsize, boolean useSaved) &#123; Layout result = null; //判断是否Spannable，如果是则用DynamicLayout类来创建布局，DynamicLayout内部实际也是使用StaticLayout来做文本的测量绘制，并在StaticLayout的基础上增加了文本或者Span改变时的监听，及时对文本或者Span的变化做出反应。 if (mText instanceof Spannable) &#123; result = new DynamicLayout(mText, mTransformed, mTextPaint, wantWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad, mBreakStrategy, mHyphenationFrequency, getKeyListener() == null ? effectiveEllipsize : null, ellipsisWidth); &#125; else &#123; //如果boring是未知状态，则重新判断一次是否boring if (boring == UNKNOWN_BORING) &#123; boring = BoringLayout.isBoring(mTransformed, mTextPaint, mTextDir, mBoring); if (boring != null) &#123; mBoring = boring; &#125; &#125; //根据boring的属性来创建对应的布局，如果有mSavedLayout则从mSavedLayout创建 if (boring != null) &#123; if (boring.width &lt;= wantWidth &amp;&amp; (effectiveEllipsize == null || boring.width &lt;= ellipsisWidth)) &#123; if (useSaved &amp;&amp; mSavedLayout != null) &#123; //从之前保存的Layout中创建 result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad); &#125; else &#123; //创建新的Layout result = BoringLayout.make(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad); &#125; if (useSaved) &#123; mSavedLayout = (BoringLayout) result; &#125; &#125; else if (shouldEllipsize &amp;&amp; boring.width &lt;= wantWidth) &#123; if (useSaved &amp;&amp; mSavedLayout != null) &#123; result = mSavedLayout.replaceOrMake(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad, effectiveEllipsize, ellipsisWidth); &#125; else &#123; result = BoringLayout.make(mTransformed, mTextPaint, wantWidth, alignment, mSpacingMult, mSpacingAdd, boring, mIncludePad, effectiveEllipsize, ellipsisWidth); &#125; &#125; &#125; &#125; //如果没有创建BoringLayout, 则使用StaticLayout类来创建布局 if (result == null) &#123; StaticLayout.Builder builder = StaticLayout.Builder.obtain(mTransformed, 0, mTransformed.length(), mTextPaint, wantWidth) .setAlignment(alignment) .setTextDirection(mTextDir) .setLineSpacing(mSpacingAdd, mSpacingMult) .setIncludePad(mIncludePad) .setBreakStrategy(mBreakStrategy) .setHyphenationFrequency(mHyphenationFrequency); if (shouldEllipsize) &#123; builder.setEllipsize(effectiveEllipsize) .setEllipsizedWidth(ellipsisWidth) .setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE); &#125; result = builder.build(); &#125; return result; &#125; 5.TextView的文字处理和绘制TextView主要的文字排版和渲染并不是在TextView里面完成的，而是由Layout类来处理文字排版工作。在单纯地使用TextView来展示静态文本的时候，这件事情则是由Layout的子类StaticLayout来完成的。 StaticLayout接收到字符串后，首先做的事情是根据字符串里面的换行符对字符串进行拆分。 123456for (int paraStart = bufStart; paraStart &lt;= bufEnd; paraStart = paraEnd) &#123; paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd); if (paraEnd &lt; 0) paraEnd = bufEnd; else paraEnd++; 拆分后的段落(Paragraph)被分配给辅助类MeasuredText进行测量得到每个字符的宽度以及每个段落的FontMetric。并通过LineBreaker进行折行的判断 1234567//把段落载入到MeasuredText中，并分配对应的缓存空间measured.setPara(source, paraStart, paraEnd, textDir, b); char[] chs = measured.mChars; float[] widths = measured.mWidths; byte[] chdirs = measured.mLevels; int dir = measured.mDir; boolean easy = measured.mEasy; //把相关属性传给JNI层的LineBreaker nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int fmCacheCount = 0;int spanEndCacheCount = 0;for (int spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123; if (fmCacheCount * 4 &gt;= fmCache.length) &#123; int[] grow = new int[fmCacheCount * 4 * 2]; System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4); fmCache = grow; &#125; if (spanEndCacheCount &gt;= spanEndCache.length) &#123; int[] grow = new int[spanEndCacheCount * 2]; System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount); spanEndCache = grow; &#125; if (spanned == null) &#123; spanEnd = paraEnd; int spanLen = spanEnd - spanStart; //段落没有Span的情况下，把整个段落交给MeasuredText计算每个字符的宽度和FontMetric measured.addStyleRun(paint, spanLen, fm); &#125; else &#123; spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class); int spanLen = spanEnd - spanStart; MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class); spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class); //把对排版有影响的Span交给MeasuredText测量宽度并计算FontMetric measured.addStyleRun(paint, spans, spanLen, fm); &#125; //把测量后的FontMetric缓存下来方便后面使用 fmCache[fmCacheCount * 4 + 0] = fm.top; fmCache[fmCacheCount * 4 + 1] = fm.bottom; fmCache[fmCacheCount * 4 + 2] = fm.ascent; fmCache[fmCacheCount * 4 + 3] = fm.descent; fmCacheCount++; spanEndCache[spanEndCacheCount] = spanEnd; spanEndCacheCount++;&#125;nGetWidths(b.mNativePtr, widths);//计算段落中需要折行的位置，并返回折行的数量int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length); 计算完每一行的测量相关信息、Span宽高以及折行位置，就可以开始按照最终的行数一行一行地保存下来，以供后面绘制和获取对应文本信息的时候使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657for (int spanStart = paraStart, spanEnd; spanStart &lt; paraEnd; spanStart = spanEnd) &#123; spanEnd = spanEndCache[spanEndCacheIndex++]; // 获取之前缓存的FontMetric信息 fm.top = fmCache[fmCacheIndex * 4 + 0]; fm.bottom = fmCache[fmCacheIndex * 4 + 1]; fm.ascent = fmCache[fmCacheIndex * 4 + 2]; fm.descent = fmCache[fmCacheIndex * 4 + 3]; fmCacheIndex++; if (fm.top &lt; fmTop) &#123; fmTop = fm.top; &#125; if (fm.ascent &lt; fmAscent) &#123; fmAscent = fm.ascent; &#125; if (fm.descent &gt; fmDescent) &#123; fmDescent = fm.descent; &#125; if (fm.bottom &gt; fmBottom) &#123; fmBottom = fm.bottom; &#125; while (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt; spanStart) &#123; breakIndex++; &#125; while (breakIndex &lt; breakCount &amp;&amp; paraStart + breaks[breakIndex] &lt;= spanEnd) &#123; int endPos = paraStart + breaks[breakIndex]; boolean moreChars = (endPos &lt; bufEnd); //逐行把相关信息储存下来 v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars); if (endPos &lt; spanEnd) &#123; fmTop = fm.top; fmBottom = fm.bottom; fmAscent = fm.ascent; fmDescent = fm.descent; &#125; else &#123; fmTop = fmBottom = fmAscent = fmDescent = 0; &#125; here = endPos; breakIndex++; if (mLineCount &gt;= mMaximumVisibleLineCount) &#123; return; &#125; &#125; &#125; 这样StaticLayout的排版过程就完成了。文本的绘制则是交给父类Layout来做的，Layout的绘制分为两大部分，drawBackground和drawText。drawBackground做的事情是如果文本内有LineBackgroundSpan则绘制所有的LineBackgroundSpan，然后判断是否有高亮背景(文本选中的背景)，如果有则绘制高亮背景。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public void drawBackground(Canvas canvas, Path highlight, Paint highlightPaint, int cursorOffsetVertical, int firstLine, int lastLine) &#123; //判断并绘制LineBackgroundSpan if (mSpannedText) &#123; if (mLineBackgroundSpans == null) &#123; mLineBackgroundSpans = new SpanSet&lt;LineBackgroundSpan&gt;(LineBackgroundSpan.class); &#125; Spanned buffer = (Spanned) mText; int textLength = buffer.length(); mLineBackgroundSpans.init(buffer, 0, textLength); if (mLineBackgroundSpans.numberOfSpans &gt; 0) &#123; int previousLineBottom = getLineTop(firstLine); int previousLineEnd = getLineStart(firstLine); ParagraphStyle[] spans = NO_PARA_SPANS; int spansLength = 0; TextPaint paint = mPaint; int spanEnd = 0; final int width = mWidth; //逐行绘制LineBackgroundSpan for (int i = firstLine; i &lt;= lastLine; i++) &#123; int start = previousLineEnd; int end = getLineStart(i + 1); previousLineEnd = end; int ltop = previousLineBottom; int lbottom = getLineTop(i + 1); previousLineBottom = lbottom; int lbaseline = lbottom - getLineDescent(i); if (start &gt;= spanEnd) &#123; spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength); spansLength = 0; if (start != end || start == 0) &#123; //排除不在绘制范围内的LineBackgroundSpan for (int j = 0; j &lt; mLineBackgroundSpans.numberOfSpans; j++) &#123; if (mLineBackgroundSpans.spanStarts[j] &gt;= end || mLineBackgroundSpans.spanEnds[j] &lt;= start) continue; spans = GrowingArrayUtils.append( spans, spansLength, mLineBackgroundSpans.spans[j]); spansLength++; &#125; &#125; &#125; //对当前行内的LineBackgroundSpan进行绘制 for (int n = 0; n &lt; spansLength; n++) &#123; LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n]; lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i); &#125; &#125; &#125; mLineBackgroundSpans.recycle(); &#125; //判断并绘制高亮背景(即选中的文本) if (highlight != null) &#123; if (cursorOffsetVertical != 0) canvas.translate(0, cursorOffsetVertical); canvas.drawPath(highlight, highlightPaint); if (cursorOffsetVertical != 0) canvas.translate(0, -cursorOffsetVertical); &#125; &#125; drawText用来逐行绘制Layout的文本、影响显示效果的Span、以及Emoji表情等。当有Emoji或者Span的时候，实际绘制工作交给TextLine类来完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public void drawText(Canvas canvas, int firstLine, int lastLine) &#123; int previousLineBottom = getLineTop(firstLine); int previousLineEnd = getLineStart(firstLine); ParagraphStyle[] spans = NO_PARA_SPANS; int spanEnd = 0; TextPaint paint = mPaint; CharSequence buf = mText; Alignment paraAlign = mAlignment; TabStops tabStops = null; boolean tabStopsIsInitialized = false; //获取TextLine实例 TextLine tl = TextLine.obtain(); //逐行绘制文本 for (int lineNum = firstLine; lineNum &lt;= lastLine; lineNum++) &#123; int start = previousLineEnd; previousLineEnd = getLineStart(lineNum + 1); int end = getLineVisibleEnd(lineNum, start, previousLineEnd); int ltop = previousLineBottom; int lbottom = getLineTop(lineNum + 1); previousLineBottom = lbottom; int lbaseline = lbottom - getLineDescent(lineNum); int dir = getParagraphDirection(lineNum); int left = 0; int right = mWidth; if (mSpannedText) &#123; Spanned sp = (Spanned) buf; int textLength = buf.length(); //检测是否段落的第一行 boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\\n'); //获得所有的段落风格相关的Span if (start &gt;= spanEnd &amp;&amp; (lineNum == firstLine || isFirstParaLine)) &#123; spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class); spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class); paraAlign = mAlignment; for (int n = spans.length - 1; n &gt;= 0; n--) &#123; if (spans[n] instanceof AlignmentSpan) &#123; paraAlign = ((AlignmentSpan) spans[n]).getAlignment(); break; &#125; &#125; tabStopsIsInitialized = false; &#125; //获取影响行缩进的Span final int length = spans.length; boolean useFirstLineMargin = isFirstParaLine; for (int n = 0; n &lt; length; n++) &#123; if (spans[n] instanceof LeadingMarginSpan2) &#123; int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount(); int startLine = getLineForOffset(sp.getSpanStart(spans[n])); if (lineNum &lt; startLine + count) &#123; useFirstLineMargin = true; break; &#125; &#125; &#125; for (int n = 0; n &lt; length; n++) &#123; if (spans[n] instanceof LeadingMarginSpan) &#123; LeadingMarginSpan margin = (LeadingMarginSpan) spans[n]; if (dir == DIR_RIGHT_TO_LEFT) &#123; margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this); right -= margin.getLeadingMargin(useFirstLineMargin); &#125; else &#123; margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this); left += margin.getLeadingMargin(useFirstLineMargin); &#125; &#125; &#125; &#125; boolean hasTabOrEmoji = getLineContainsTab(lineNum); if (hasTabOrEmoji &amp;&amp; !tabStopsIsInitialized) &#123; if (tabStops == null) &#123; tabStops = new TabStops(TAB_INCREMENT, spans); &#125; else &#123; tabStops.reset(TAB_INCREMENT, spans); &#125; tabStopsIsInitialized = true; &#125; //判断当前行的第五方式 Alignment align = paraAlign; if (align == Alignment.ALIGN_LEFT) &#123; align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE; &#125; else if (align == Alignment.ALIGN_RIGHT) &#123; align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL; &#125; int x; if (align == Alignment.ALIGN_NORMAL) &#123; if (dir == DIR_LEFT_TO_RIGHT) &#123; x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT); &#125; else &#123; x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT); &#125; &#125; else &#123; int max = (int)getLineExtent(lineNum, tabStops, false); if (align == Alignment.ALIGN_OPPOSITE) &#123; if (dir == DIR_LEFT_TO_RIGHT) &#123; x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT); &#125; else &#123; x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT); &#125; &#125; else &#123; // Alignment.ALIGN_CENTER max = max &amp; ~1; x = ((right + left - max) &gt;&gt; 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER); &#125; &#125; paint.setHyphenEdit(getHyphen(lineNum)); Directions directions = getLineDirections(lineNum); if (directions == DIRS_ALL_LEFT_TO_RIGHT &amp;&amp; !mSpannedText &amp;&amp; !hasTabOrEmoji) &#123; //没有任何Emoji或者span的时候，直接调用Canvas来绘制文本 canvas.drawText(buf, start, end, x, lbaseline, paint); &#125; else &#123; //当有Emoji或者Span的时候，交给TextLine类来绘制 tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops); tl.draw(canvas, x, ltop, lbaseline, lbottom); &#125; paint.setHyphenEdit(0); &#125; TextLine.recycle(tl); &#125; 我们下面再来看看TextLine是如何绘制有特殊情况的文本的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void draw(Canvas c, float x, int top, int y, int bottom) &#123; //判断是否有Tab或者Emoji if (!mHasTabs) &#123; if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) &#123; drawRun(c, 0, mLen, false, x, top, y, bottom, false); return; &#125; if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) &#123; drawRun(c, 0, mLen, true, x, top, y, bottom, false); return; &#125; &#125; float h = 0; int[] runs = mDirections.mDirections; RectF emojiRect = null; int lastRunIndex = runs.length - 2; //逐个绘制 for (int i = 0; i &lt; runs.length; i += 2) &#123; int runStart = runs[i]; int runLimit = runStart + (runs[i+1] &amp; Layout.RUN_LENGTH_MASK); if (runLimit &gt; mLen) &#123; runLimit = mLen; &#125; boolean runIsRtl = (runs[i+1] &amp; Layout.RUN_RTL_FLAG) != 0; int segstart = runStart; for (int j = mHasTabs ? runStart : runLimit; j &lt;= runLimit; j++) &#123; int codept = 0; Bitmap bm = null; if (mHasTabs &amp;&amp; j &lt; runLimit) &#123; codept = mChars[j]; if (codept &gt;= 0xd800 &amp;&amp; codept &lt; 0xdc00 &amp;&amp; j + 1 &lt; runLimit) &#123; codept = Character.codePointAt(mChars, j); if (codept &gt;= Layout.MIN_EMOJI &amp;&amp; codept &lt;= Layout.MAX_EMOJI) &#123; //获取Emoji对应的图像 bm = Layout.EMOJI_FACTORY.getBitmapFromAndroidPua(codept); &#125; else if (codept &gt; 0xffff) &#123; ++j; continue; &#125; &#125; &#125; if (j == runLimit || codept == '\\t' || bm != null) &#123; //绘制文字 h += drawRun(c, segstart, j, runIsRtl, x+h, top, y, bottom, i != lastRunIndex || j != mLen); if (codept == '\\t') &#123; h = mDir * nextTab(h * mDir); &#125; else if (bm != null) &#123; float bmAscent = ascent(j); float bitmapHeight = bm.getHeight(); float scale = -bmAscent / bitmapHeight; float width = bm.getWidth() * scale; if (emojiRect == null) &#123; emojiRect = new RectF(); &#125; //调整emoji图像绘制矩形 emojiRect.set(x + h, y + bmAscent, x + h + width, y); //绘制Emoji图像 c.drawBitmap(bm, null, emojiRect, mPaint); h += width; j++; &#125; segstart = j + 1; &#125; &#125; &#125; &#125; 这样就完成了文本的绘制工作，简单地总结就是：分析整体文本—&gt;拆分为段落—&gt;计算整体段落的文本包括Span的测量信息—&gt;对文本进行折行—&gt;根据最终行数把文本测量信息保存—&gt;绘制文本的行背景—&gt;判断并获取文本种的Span和Emoji图像—&gt;绘制最终的文本和图像。当然我们省略了一部分内容，比如段落文本方向，单行的文本排版方向的计算，实际的处理要更为复杂。 接下来我们来看一下在测量过程中出现的FontMetrics，这是一个Paint的静态内部类。主要用来储存文字排版的Y轴相关信息。内部仅包含ascent、descent、top、bottom、leading五个数值。如下图: 除了leading以外，其他的数值都是相对于每一行的baseline的，也就是说其他的数值需要加上对应行的baseline才能得到最终真实的坐标。 6.TextView接收软键盘输入Android上的标准文本编辑控件是EditText，而EditText对软键盘输入的处理，却是在TextView内部实现的。Android为所有的View预留了一个接收软键盘输入的接口类，叫InputConnection。软键盘以InputConnection为桥梁把文字输入、文字修改、文字删除等传递给View。任意View只要重写onCheckIsTextEditor()并返回true，然后重写onCreateInputConnection(EditorInfo outAttrs)返回一个InputConnection的实例，便可以接收软键盘的输入。TextView的软键盘输入接收，是通过EditableInputConnection类来实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public InputConnection onCreateInputConnection(EditorInfo outAttrs) &#123; //判断是否处于可编辑状态 if (onCheckIsTextEditor() &amp;&amp; isEnabled()) &#123; mEditor.createInputMethodStateIfNeeded(); //设置输入法相关的信息 outAttrs.inputType = getInputType(); if (mEditor.mInputContentType != null) &#123; outAttrs.imeOptions = mEditor.mInputContentType.imeOptions; outAttrs.privateImeOptions = mEditor.mInputContentType.privateImeOptions; outAttrs.actionLabel = mEditor.mInputContentType.imeActionLabel; outAttrs.actionId = mEditor.mInputContentType.imeActionId; outAttrs.extras = mEditor.mInputContentType.extras; &#125; else &#123; outAttrs.imeOptions = EditorInfo.IME_NULL; &#125; if (focusSearch(FOCUS_DOWN) != null) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_NEXT; &#125; if (focusSearch(FOCUS_UP) != null) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS; &#125; if ((outAttrs.imeOptions&amp;EditorInfo.IME_MASK_ACTION) == EditorInfo.IME_ACTION_UNSPECIFIED) &#123; if ((outAttrs.imeOptions&amp;EditorInfo.IME_FLAG_NAVIGATE_NEXT) != 0) &#123; //把软键盘的enter设为下一步 outAttrs.imeOptions |= EditorInfo.IME_ACTION_NEXT; &#125; else &#123; //把软键盘的enter设为完成 outAttrs.imeOptions |= EditorInfo.IME_ACTION_DONE; &#125; if (!shouldAdvanceFocusOnEnter()) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION; &#125; &#125; if (isMultilineInputType(outAttrs.inputType)) &#123; outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_ENTER_ACTION; &#125; outAttrs.hintText = mHint; //判断TextView内部文本是否可编辑 if (mText instanceof Editable) &#123; //返回EditableInputConnection实例 InputConnection ic = new EditableInputConnection(this); outAttrs.initialSelStart = getSelectionStart(); outAttrs.initialSelEnd = getSelectionEnd(); outAttrs.initialCapsMode = ic.getCursorCapsMode(getInputType()); return ic; &#125; &#125; return null; &#125; 我们再来看一下EditableInputConnection里面的几个主要的方法： 首先是commitText方法，这个方法接收输入法输入的字符并提交给TextView。 12345678910111213141516171819public boolean commitText(CharSequence text, int newCursorPosition) &#123; //判断TextView是否为空 if (mTextView == null) &#123; return super.commitText(text, newCursorPosition); &#125; //判断文本是否Span，来自输入法的Span一般只有SuggestionSpan，SuggestionSpan携带了输入法的错别字修正的词 if (text instanceof Spanned) &#123; Spanned spanned = ((Spanned) text); SuggestionSpan[] spans = spanned.getSpans(0, text.length(), SuggestionSpan.class); mIMM.registerSuggestionSpansForNotification(spans); &#125; mTextView.resetErrorChangedFlag(); //提交字符 boolean success = super.commitText(text, newCursorPosition); mTextView.hideErrorIfUnchanged(); //返回是否成功 return success; &#125; getEditable方法，这个方法并不是InputConnection接口的一部分，而是EditableInputConnection的父类BaseInputConnection的方法，用来获取一个可编辑对象，EditableInputConnection里面的所有修改都针对这个可编辑对象来做。 12345678public Editable getEditable() &#123; TextView tv = mTextView; if (tv != null) &#123; //返回TextView的可编辑对象 return tv.getEditableText(); &#125; return null; &#125; deleteSurroundingText方法，这个方法用来删除光标前后的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean deleteSurroundingText(int beforeLength, int afterLength) &#123; if (DEBUG) Log.v(TAG, \"deleteSurroundingText \" + beforeLength + \" / \" + afterLength); final Editable content = getEditable(); if (content == null) return false; //批量删除标记 beginBatchEdit(); //获取当前已选择的文本的位置 int a = Selection.getSelectionStart(content); int b = Selection.getSelectionEnd(content); if (a &gt; b) &#123; int tmp = a; a = b; b = tmp; &#125; int ca = getComposingSpanStart(content); int cb = getComposingSpanEnd(content); if (cb &lt; ca) &#123; int tmp = ca; ca = cb; cb = tmp; &#125; if (ca != -1 &amp;&amp; cb != -1) &#123; if (ca &lt; a) a = ca; if (cb &gt; b) b = cb; &#125; int deleted = 0; //删除光标之前的文本 if (beforeLength &gt; 0) &#123; int start = a - beforeLength; if (start &lt; 0) start = 0; content.delete(start, a); deleted = a - start; &#125; //删除光标之后的文本 if (afterLength &gt; 0) &#123; b = b - deleted; int end = b + afterLength; if (end &gt; content.length()) end = content.length(); content.delete(b, end); &#125; //结束批量编辑 endBatchEdit(); return true; &#125; commitCompletion和commitCorrection方法，即是用来补全单词和修正错别字的方法，这两个方法内部都是调用TextView对应的方法来实现的。 12345678910111213141516public boolean commitCompletion(CompletionInfo text) &#123; if (DEBUG) Log.v(TAG, \"commitCompletion \" + text); mTextView.beginBatchEdit(); mTextView.onCommitCompletion(text); mTextView.endBatchEdit(); return true; &#125; @Override public boolean commitCorrection(CorrectionInfo correctionInfo) &#123; if (DEBUG) Log.v(TAG, \"commitCorrection\" + correctionInfo); mTextView.beginBatchEdit(); mTextView.onCommitCorrection(correctionInfo); mTextView.endBatchEdit(); return true; &#125; 8.总结一个展示文本+文本编辑器功能的控件需要做的事情很多，要对文本进行排版、处理不同的段落风格、处理段落内的不同emoji和span、进行折行计算，然后还需要做文本编辑、文本选择等。而TextView把这些事情明确分工给不同的类。这样不仅仅把复杂问题拆分成了一个个简单的小功能，同时也大大增加了可扩展性。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"TabLayout源码解析","date":"2017-07-26T12:06:13.000Z","path":"2017/07/26/TabLayout源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 TabLayout 源码解析1. 功能介绍1.1 TabLayoutTabs跟随Actionbar在Android 3.0进入大家的视线，是一个很经典的设计。它也是Material Design 规范中提及的Component之一。Tabs or Bottom navigation？相信不少Android开发者与产品都撕过，就连微信在其中也有过抉择。Google在Google+以及Google Photo中相继采用Bottom navigation的设计把剧情推到向高潮，一度轰动整个社区。Google继而在Material Design 规范加入了Bottom navigation，表明了态度，也给这起争论画上了圆满的句号。 在 support desgin lib 发布前，大家基本都采用PagerSlidingTabStrip来实现tab效果。其实TabLayout在实现上和PagerSlidingTabStrip十分相似，今天我们来分析TabLayout。 1.2 TabLayout使用TabLayout使用比较简单。既可以单独使用，也可以与ViewPager配合使用。 1.2.1 TabLayout单独使用在java代码中添加Tabs1234TabLayout tabLayout = (TabLayout) findViewById(R.id.tabLayout);tabLayout.addTab(tabLayout.newTab().setText(\"Tab 1\"));tabLayout.addTab(tabLayout.newTab().setText(\"Tab 2\"));tabLayout.addTab(tabLayout.newTab().setText(\"Tab 3\")); 也可以在xml中添加Tabs1234567891011&lt;android.support.design.widget.TabLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\"&gt; &lt;android.support.design.widget.TabItem android:text=\"@string/tab_text\"/&gt; &lt;android.support.design.widget.TabItem android:icon=\"@drawable/ic_android\"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 1.2.2 与ViewPager搭配使用1234567891011121314// find viewTabLayout tabLayout = ...;ViewPager viewPager = ...;PagerAdapter adapter = new PagerAdapter()&#123; // ...Override some methods // TabLayout调用这个方法获取Tab的title @Override public CharSequence getPageTitle(int position) &#123; return \"Tab 1\"; &#125;&#125;viewPager.setAdapter(adapter);tabLayout.setupWithViewPager(viewPager); 2. 总体设计 TabLayout继承HorizontalScrollView天生就是一个可以横向滚动的ViewGroup. 我们知道, HorizontalScrollView与ScrollView一样, 最多只能包含一个子View. SlidingTabStrip继承于LinearLayout，是TabLayout的内部类。它是TabLayout唯一的子View. 所有的TabView都是它的子View. TabView继承于LinearLayout,以Tab为数据源，来展示Tab的样式。最终用for循环被add进SlidingTabStrip. Tab是一个简单的View Model实体类，控制TabView的title, icon, custom layout id等属性。 TabItem继承于View. 用于在layout xml中来描述Tab. 需要注意的是，它不会add到SlidingTabStrip中去。它的作用是从xml中获取到text，icon，custom layout id等属性。TabLayout inflate到TabItem并获取属性到装配到Tab中，最终add到SlidingTabStrip中的还是TabView. OnTabSelectedListener是TabLayout中的内部接口，用于监听SlidingTabStrip中子TabView选中状态的改变。 Mode是TabLayout滚动模式的描述，一共有两种状态。MODE_FIXED不可滚动模式，以及MODE_SCROLLABLE可以滚动模式。 Gravity是TabView在SlidingTabStrip中layout方式的描述。分为：GRAVITY_FILL，GRAVITY_CENTER. 3. 详细设计3.1 类关系图 3.2 分析3.2.1 TabLayout子View唯一性保证前面介绍TabLayout继承于HorizontalScrollView最多只能有1个子View. 但TabLayout可以在layout中添加多个子View节点. 这是怎么回事呢？1234567891011&lt;android.support.design.widget.TabLayout android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\"&gt; &lt;android.support.design.widget.TabItem android:text=\"@string/tab_text\"/&gt; &lt;android.support.design.widget.TabItem android:icon=\"@drawable/ic_android\"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 看过LayoutInflater源码的同学可能会知道这个过程：先inflate到生成View对象，再调用ViewGroup#addView(...)系列方法把view添加到ViewGroup中。我们发现TabLayout的addView(...)系列方法，都删去super调用，且调用了共同的一个方法，addViewInternal(View view)。 1234567private void addViewInternal(final View child) &#123; if (child instanceof TabItem) &#123; addTabFromItemView((TabItem) child); &#125; else &#123; throw new IllegalArgumentException(\"Only TabItem instances can be added to TabLayout\"); &#125;&#125; 可见，若child非TabItem对象会抛出异常。所以xml中给TabLayout添加tab时，只能添加TabItem对象。若想添加其它View类型怎么办？TabItem有android:customView这个属性。我们继续来看。12345678910111213141516171819202122232425262728293031323334private void addTabFromItemView(@NonNull TabItem item) &#123; final Tab tab = newTab(); if (item.mText != null) &#123; tab.setText(item.mText); &#125; if (item.mIcon != null) &#123; tab.setIcon(item.mIcon); &#125; if (item.mCustomLayout != 0) &#123; tab.setCustomView(item.mCustomLayout); &#125; addTab(tab);&#125;public Tab newTab() &#123; Tab tab = sTabPool.acquire(); if (tab == null) &#123; tab = new Tab(); &#125; tab.mParent = this; tab.mView = createTabView(tab); return tab;&#125;private TabView createTabView(@NonNull final Tab tab) &#123; TabView tabView = mTabViewPool != null ? mTabViewPool.acquire() : null; if (tabView == null) &#123; tabView = new TabView(getContext()); &#125; tabView.setTab(tab); tabView.setFocusable(true); tabView.setMinimumWidth(getTabMinWidth()); return tabView;&#125; 这里调newTab()方法创建了一个tab对象，并且用对象池把创建的tab对象缓存起来。然后将TabItem对象的属性都赋值给tab对象。在createTabView(Tab tab)这个方法中，首先从TabView池中获取TabView对象，如果不存在，则实例化一个对象，并调用tabView.setTab(tab)方法来进行了数据绑定。 addTab(...)有三个重载方法，最终都会调用如下方法：1234567891011121314151617181920212223242526272829public void addTab(@NonNull Tab tab, boolean setSelected) &#123; if (tab.mParent != this) &#123; throw new IllegalArgumentException(\"Tab belongs to a different TabLayout.\"); &#125; addTabView(tab, setSelected); configureTab(tab, mTabs.size()); if (setSelected) &#123; tab.select(); &#125;&#125;private void addTabView(Tab tab, int position, boolean setSelected) &#123; final TabView tabView = tab.mView; mTabStrip.addView(tabView, position, createLayoutParamsForTabs()); if (setSelected) &#123; tabView.setSelected(true); &#125;&#125;private void configureTab(Tab tab, int position) &#123; tab.setPosition(position); mTabs.add(position, tab); final int count = mTabs.size(); for (int i = position + 1; i &lt; count; i++) &#123; mTabs.get(i).setPosition(i); &#125;&#125; 在addView(Tab, int, boolean)方法中，把TabView对象add进了SlidingTabStrip这个ViewGroup中。实际上SlidingTabStrip的对象mTabStrip才是TabLayout的唯一子View.在TabLayout的构造方法中:1234567891011public TabLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 禁用横向滑动条 setHorizontalScrollBarEnabled(false); // new 一个'SlidingTabStrip'的实例，并作为唯一的子View add进'TabLayout'. mTabStrip = new SlidingTabStrip(context); super.addView(mTabStrip, 0, new HorizontalScrollView.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT)); // 省略下面的无关代码...｝ 至此，我们就明白了TabLayout中子View的一致性是如何保证的。也明白了TabView其实才是亲生的，TabItem其实是后娘养的! 这些代码都很简单，不过我们可以从中学习到很多有用的思想。 至此，一个清晰的View层级图应该就出现在了各位同学的眼前。 3.2.2 与ViewPager搭配使用有了上面的的基础，我们再来看看TabLayout是如何和它的好基友ViewPager搭配使用的。12345678910111213141516171819202122232425262728293031323334353637383940414243public void setupWithViewPager(@Nullable final ViewPager viewPager) &#123; //... //为理解简单起见，删掉边角性干扰代码，主要来看核心逻辑 mViewPager = viewPager; // Add our custom OnPageChangeListener to the ViewPager if (mPageChangeListener == null) &#123; mPageChangeListener = new TabLayoutOnPageChangeListener(this); &#125; mPageChangeListener.reset(); viewPager.addOnPageChangeListener(mPageChangeListener); // Now we'll add a tab selected listener to set ViewPager's current item setOnTabSelectedListener(new ViewPagerOnTabSelectedListener(viewPager)); // Now we'll populate ourselves from the pager adapter setPagerAdapter(adapter, true);&#125;public void setOnTabSelectedListener(OnTabSelectedListener onTabSelectedListener) &#123; mOnTabSelectedListener = onTabSelectedListener;&#125;private void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter populateFromPagerAdapter();&#125; 这里的TabLayoutOnPageChangeListener实现了ViewPager.OnPageChangeListener. 首先调用ViewPager对象addOnPageChangeListener(OnPageChangeListener)来监听ViewPager的滑动以及当前也的选中。然后设置ViewPagerOnTabSelectedListener对象，保证ViewPager的页面和TabLayout的item的选中状态保持一致，以及滚动的协同性。这里的监听在3.2.3中详细讲解。 我们一般调用viewPager.getAdapter().notifyDataSetChanged()来进行ViewPager的刷新. 现在我们在ViewPager的adapter中注册一个监听器，监听ViewPager的刷新行为。目的是为了刷新ViewPager的同时也可以刷新TabLayout. 我们来看看PagerAdapterObserver这个监听器是如何刷新TabLayout的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private class PagerAdapterObserver extends DataSetObserver &#123; @Override public void onChanged() &#123; populateFromPagerAdapter(); &#125; @Override public void onInvalidated() &#123; populateFromPagerAdapter(); &#125;&#125;private void populateFromPagerAdapter() &#123; removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123; addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) &#123; final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123; selectTab(getTabAt(curItem)); &#125; &#125; &#125; else &#123; removeAllTabs(); &#125;&#125;public void removeAllTabs() &#123; // Remove all the views for (int i = mTabStrip.getChildCount() - 1; i &gt;= 0; i--) &#123; removeTabViewAt(i); &#125; for (final Iterator&lt;Tab&gt; i = mTabs.iterator(); i.hasNext();) &#123; final Tab tab = i.next(); i.remove(); tab.reset(); sTabPool.release(tab); &#125; mSelectedTab = null;&#125; 刷新方式很简单粗暴，从SlidingTabStrip对象中移除所有的TabView，继而从View ModelmTabs中移除所有Tab对象。然后从adapter中获取tab信息，循环调用addTab(Tab, boolean)方法重新添加TabView。最后调用ViewPager对象的getCurrentItem()方法，获取当前位置，然后调用selectTab(int position)恢复TabView的选中状态（针对TabView的选中，3.2.4中有详细介绍)。 3.2.3 ViewPager与TabLayout的Tab及indicaotr协同滚动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class TabLayoutOnPageChangeListener implements ViewPager.OnPageChangeListener &#123; private final WeakReference&lt;TabLayout&gt; mTabLayoutRef; private int mPreviousScrollState; private int mScrollState; public TabLayoutOnPageChangeListener(TabLayout tabLayout) &#123; mTabLayoutRef = new WeakReference&lt;&gt;(tabLayout); &#125; @Override public void onPageScrollStateChanged(int state) &#123; mPreviousScrollState = mScrollState; mScrollState = state; &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null) &#123; // Only update the text selection if we're not settling, or we are settling after // being dragged final boolean updateText = mScrollState != SCROLL_STATE_SETTLING || mPreviousScrollState == SCROLL_STATE_DRAGGING; // Update the indicator if we're not settling after being idle. This is caused // from a setCurrentItem() call and will be handled by an animation from // onPageSelected() instead. final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.setScrollPosition(position, positionOffset, updateText, updateIndicator); &#125; &#125; @Override public void onPageSelected(int position) &#123; final TabLayout tabLayout = mTabLayoutRef.get(); if (tabLayout != null &amp;&amp; tabLayout.getSelectedTabPosition() != position) &#123; // Select the tab, only updating the indicator if we're not being dragged/settled // (since onPageScrolled will handle that). final boolean updateIndicator = mScrollState == SCROLL_STATE_IDLE || (mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); tabLayout.selectTab(tabLayout.getTabAt(position), updateIndicator); &#125; &#125; private void reset() &#123; mPreviousScrollState = mScrollState = SCROLL_STATE_IDLE; &#125;&#125; 用过ViewPager的同学对OnPageChangeListener不会陌生，不多赘述。TabLayoutOnPageChangeListener实现了OnPageChangeListener, 在onPageScrolled(...)方法中做协同滚动处理。滚动的条件是：1final boolean updateIndicator = !(mScrollState == SCROLL_STATE_SETTLING &amp;&amp; mPreviousScrollState == SCROLL_STATE_IDLE); 调用TabLayout的setScrollPosition(...)方法来控制TabLayout中TabView和indocator的协同滚动。12345678910111213141516171819202122private void setScrollPosition(int position, float positionOffset, boolean updateSelectedText, boolean updateIndicatorPosition) &#123; final int roundedPosition = Math.round(position + positionOffset); if (roundedPosition &lt; 0 || roundedPosition &gt;= mTabStrip.getChildCount()) &#123; return; &#125; // Set the indicator position, if enabled if (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset); &#125; // Now update the scroll position, canceling any running animation if (mScrollAnimator != null &amp;&amp; mScrollAnimator.isRunning()) &#123; mScrollAnimator.cancel(); &#125; scrollTo(calculateScrollXForTab(position, positionOffset), 0); // Update the 'selected state' view as we scroll, if enabled if (updateSelectedText) &#123; setSelectedTabView(roundedPosition); &#125;&#125; 3.2.3.1 TabLayout的Indicator协同滚动indicator的滚动由SlidingTabStrip来处理： 1234// Set the indicator position, if enabledif (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset);&#125; 这里的position是当前选中的位置。positionOffset是: 距当前Tab滑动的距离／从当前tab滑动到下一个tab的总距离 这样一个范围在［0，1］间的小数。 SlidingTabStrip#setIndicatorPositionFromTabPosition(int, float)123456789void setIndicatorPositionFromTabPosition(int position, float positionOffset) &#123; if (mIndicatorAnimator != null &amp;&amp; mIndicatorAnimator.isRunning()) &#123; mIndicatorAnimator.cancel(); &#125; mSelectedPosition = position; mSelectionOffset = positionOffset; updateIndicatorPosition();&#125; SlidingTabStrip#updateIndicatorPosition()12345678910111213141516171819202122private void updateIndicatorPosition() &#123; final View selectedTitle = getChildAt(mSelectedPosition); int left, right; if (selectedTitle != null &amp;&amp; selectedTitle.getWidth() &gt; 0) &#123; left = selectedTitle.getLeft(); right = selectedTitle.getRight(); if (mSelectionOffset &gt; 0f &amp;&amp; mSelectedPosition &lt; getChildCount() - 1) &#123; // Draw the selection partway between the tabs View nextTitle = getChildAt(mSelectedPosition + 1); left = (int) (mSelectionOffset * nextTitle.getLeft() + (1.0f - mSelectionOffset) * left); right = (int) (mSelectionOffset * nextTitle.getRight() + (1.0f - mSelectionOffset) * right); &#125; &#125; else &#123; left = right = -1; &#125; setIndicatorPosition(left, right);&#125; 通过getChildAt(mSelectedPosition), 获取到到mSelectedPosition处的TabView。若滑动的mSelectionOffset&gt;0f且当前选中的位置mSelectedPosition不是最后一个TabView. 获取到下一个TabView，并计算出indicator的left和right。 SlidingTabStrip＃setIndicatorPosition(int, int)12345678private void setIndicatorPosition(int left, int right) &#123; if (left != mIndicatorLeft || right != mIndicatorRight) &#123; // If the indicator's left/right has changed, invalidate mIndicatorLeft = left; mIndicatorRight = right; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 非常简单的代码，在调用ViewCompat.postInvalidateOnAnimation(this)重绘View之前，去掉一些重复绘制的帧。 12345678910@Overridepublic void draw(Canvas canvas) &#123; super.draw(canvas); // Thick colored underline below the current selection if (mIndicatorLeft &gt;= 0 &amp;&amp; mIndicatorRight &gt; mIndicatorLeft) &#123; canvas.drawRect(mIndicatorLeft, getHeight() - mSelectedIndicatorHeight, mIndicatorRight, getHeight(), mSelectedIndicatorPaint); &#125;&#125; 绘制逻辑很简单。调用canvas.drawRect(float left, float top, float right, float bottom, Paint paint)来绘制indicator.这里：1234left = mIndicatorLeft;top = getHeight() - mSelectedIndicatorHeight;right = mIndicatorRight;bottom = getHeight(); 3.2.3.2 TabLayout的TabView协同滚动我们回头来看 3.2.3中setScrollPosition(...)方法12345678910111213141516171819202122private void setScrollPosition(int position, float positionOffset, boolean updateSelectedText, boolean updateIndicatorPosition) &#123; final int roundedPosition = Math.round(position + positionOffset); if (roundedPosition &lt; 0 || roundedPosition &gt;= mTabStrip.getChildCount()) &#123; return; &#125; // Set the indicator position, if enabled if (updateIndicatorPosition) &#123; mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset); &#125; // Now update the scroll position, canceling any running animation if (mScrollAnimator != null &amp;&amp; mScrollAnimator.isRunning()) &#123; mScrollAnimator.cancel(); &#125; scrollTo(calculateScrollXForTab(position, positionOffset), 0); // Update the 'selected state' view as we scroll, if enabled if (updateSelectedText) &#123; setSelectedTabView(roundedPosition); &#125;&#125; 在3.2.3.1中我们知道indicator的滚动是通过mTabStrip.setIndicatorPositionFromTabPosition(position, positionOffset)实现的。那TabView的滚动呢？我们知道TabLayout是继承HorizonScrollView天生就是一个可以横行滚动的View，所以，我们只需要调用scrollTo(int x, int y)方法就可以实现横向滚动。1scrollTo(calculateScrollXForTab(position, positionOffset), 0); 这里x方向的偏移量调用calculateScrollXForTab(position, positionOffset)实时计算得出，y方向的偏移量为0。12345678910111213141516private int calculateScrollXForTab(int position, float positionOffset) &#123; if (mMode == MODE_SCROLLABLE) &#123; final View selectedChild = mTabStrip.getChildAt(position); final View nextChild = position + 1 &lt; mTabStrip.getChildCount() ? mTabStrip.getChildAt(position + 1) : null; final int selectedWidth = selectedChild != null ? selectedChild.getWidth() : 0; final int nextWidth = nextChild != null ? nextChild.getWidth() : 0; return selectedChild.getLeft() + ((int) ((selectedWidth + nextWidth) * positionOffset * 0.5f)) + (selectedChild.getWidth() / 2) - (getWidth() / 2); &#125; return 0;&#125; 至此，我们就明白了TabLayout是如何随ViewPager的滚动而滚动的。 3.2.4 Tab选中状态123456789private void setSelectedTabView(int position) &#123; final int tabCount = mTabStrip.getChildCount(); if (position &lt; tabCount &amp;&amp; !mTabStrip.getChildAt(position).isSelected()) &#123; for (int i = 0; i &lt; tabCount; i++) &#123; final View child = mTabStrip.getChildAt(i); child.setSelected(i == position); &#125; &#125;&#125; 调用View的setSelected(boolean)方法。 4. 开源项目中的使用开源项目中使用TabLayout的例子特别多, 这里给出我写的一个项目： SwipeToLoadLayout的demo 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"SwipeRefreshLayout源码分析","date":"2017-07-26T12:04:43.000Z","path":"2017/07/26/SwipeRefreshLayout源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 简介官方文档 SwipeRefreshLayout 是一个下拉刷新控件，几乎可以包裹一个任何可以滚动的内容（ListView GridView ScrollView RecyclerView），可以自动识别垂直滚动手势。使用起来非常方便。 1.将需要下拉刷新的空间包裹起来 12345678910&lt;android.support.v4.widget.SwipeRefreshLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 2.设置刷新动画的触发回调 123456789101112131415161718192021222324252627282930//设置下拉出现小圆圈是否是缩放出现，出现的位置，最大的下拉位置mySwipeRefreshLayout.setProgressViewOffset(true, 50, 200);//设置下拉圆圈的大小，两个值 LARGE， DEFAULTmySwipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);// 设置下拉圆圈上的颜色，蓝色、绿色、橙色、红色mySwipeRefreshLayout.setColorSchemeResources( android.R.color.holo_blue_bright, android.R.color.holo_green_light, android.R.color.holo_orange_light, android.R.color.holo_red_light);// 通过 setEnabled(false) 禁用下拉刷新mySwipeRefreshLayout.setEnabled(false);// 设定下拉圆圈的背景mSwipeLayout.setProgressBackgroundColor(R.color.red);/* * 设置手势下拉刷新的监听 */mySwipeRefreshLayout.setOnRefreshListener( new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; // 刷新动画开始后回调到此方法 &#125; &#125;); 通过 setRefreshing(false) 和 setRefreshing(true) 来手动调用刷新的动画。 onRefresh 的回调只有在手势下拉的情况下才会触发，通过 setRefreshing 只能调用刷新的动画是否显示。SwipeRefreshLayout 也可放在 CoordinatorLayout 内共同处理滑动冲突，有兴趣可以尝试。 SwipeRefreshLayout 源码分析 本文基于 v4 版本 23.2.0 extends ViewGroup implements NestedScrollingParent NestedScrollingChild1234java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.support.v4.widget.SwipeRefreshLayout SwipeRefreshLayout 的分析分为两个部分：自定义 ViewGroup 的部分，处理和子视图的嵌套滚动部分。 SwipeRefreshLayout extends ViewGroup其实就是一个自定义的 ViewGroup ，结合我们自己平时自定义 ViewGroup 的步骤： 初始化变量 onMeasure onLayout 处理交互 （dispatchTouchEvent onInterceptTouchEvent onTouchEvent） 接下来就按照上面的步骤进行分析。 1.初始化变量SwipeRefreshLayout 内部有 2 个 View，一个圆圈（mCircleView），一个内部可滚动的View（mTarget）。除了 View，还包含一个 OnRefreshListener 接口，当刷新动画被触发时回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Constructor that is called when inflating SwipeRefreshLayout from XML. * * @param context * @param attrs */public SwipeRefreshLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); // 系统默认的最小滚动距离 mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop(); // 系统默认的动画时长 mMediumAnimationDuration = getResources().getInteger( android.R.integer.config_mediumAnimTime); setWillNotDraw(false); mDecelerateInterpolator = new DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR); // 获取 xml 中定义的属性 final TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS); setEnabled(a.getBoolean(0, true)); a.recycle(); // 刷新的圆圈的大小，单位转换成 sp final DisplayMetrics metrics = getResources().getDisplayMetrics(); mCircleWidth = (int) (CIRCLE_DIAMETER * metrics.density); mCircleHeight = (int) (CIRCLE_DIAMETER * metrics.density); // 创建刷新动画的圆圈 createProgressView(); ViewCompat.setChildrenDrawingOrderEnabled(this, true); // the absolute offset has to take into account that the circle starts at an offset mSpinnerFinalOffset = DEFAULT_CIRCLE_TARGET * metrics.density; // 刷新动画的临界距离值 mTotalDragDistance = mSpinnerFinalOffset; // 通过 NestedScrolling 机制来处理嵌套滚动 mNestedScrollingParentHelper = new NestedScrollingParentHelper(this); mNestedScrollingChildHelper = new NestedScrollingChildHelper(this); setNestedScrollingEnabled(true);&#125; // 创建刷新动画的圆圈12345678private void createProgressView() &#123; mCircleView = new CircleImageView(getContext(), CIRCLE_BG_LIGHT, CIRCLE_DIAMETER/2); mProgress = new MaterialProgressDrawable(getContext(), this); mProgress.setBackgroundColor(CIRCLE_BG_LIGHT); mCircleView.setImageDrawable(mProgress); mCircleView.setVisibility(View.GONE); addView(mCircleView);&#125; 初始化的时候创建一个出来一个 View （下拉刷新的圆圈）。可以看出使用背景圆圈是 v4 包里提供的 CircleImageView 控件，中间的是 MaterialProgressDrawable 进度条。另一个 View 是在 xml 中包含的可滚动视图。 2.onMeasureonMeasure 确定子视图的大小。 123456789101112131415161718192021222324252627282930313233343536@Overridepublic void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); if (mTarget == null) &#123; // 确定内部要滚动的View，如 RecycleView ensureTarget(); &#125; if (mTarget == null) &#123; return; &#125; // 测量子 View （mTarget） mTarget.measure(MeasureSpec.makeMeasureSpec( getMeasuredWidth() - getPaddingLeft() - getPaddingRight(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec( getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY)); // 测量刷新的圆圈 mCircleView mCircleView.measure(MeasureSpec.makeMeasureSpec(mCircleWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(mCircleHeight, MeasureSpec.EXACTLY)); if (!mUsingCustomStart &amp;&amp; !mOriginalOffsetCalculated) &#123; mOriginalOffsetCalculated = true; mCurrentTargetOffsetTop = mOriginalOffsetTop = -mCircleView.getMeasuredHeight(); &#125; // 计算 mCircleView 在 ViewGroup 中的索引 mCircleViewIndex = -1; // Get the index of the circleview. for (int index = 0; index &lt; getChildCount(); index++) &#123; if (getChildAt(index) == mCircleView) &#123; mCircleViewIndex = index; break; &#125; &#125;&#125; 这个步骤确定了 mCircleView 和 SwipeRefreshLayout 的子视图的大小。 3.onLayoutonLayout 主要负责确定各个子视图的位置。 12345678910111213141516171819202122232425262728@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; // 获取 SwipeRefreshLayout 的宽高 final int width = getMeasuredWidth(); final int height = getMeasuredHeight(); if (getChildCount() == 0) &#123; return; &#125; if (mTarget == null) &#123; ensureTarget(); &#125; if (mTarget == null) &#123; return; &#125; // 考虑到给控件设置 padding，去除 padding 的距离 final View child = mTarget; final int childLeft = getPaddingLeft(); final int childTop = getPaddingTop(); final int childWidth = width - getPaddingLeft() - getPaddingRight(); final int childHeight = height - getPaddingTop() - getPaddingBottom(); // 设置 mTarget 的位置 child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight); int circleWidth = mCircleView.getMeasuredWidth(); int circleHeight = mCircleView.getMeasuredHeight(); // 根据 mCurrentTargetOffsetTop 变量的值来设置 mCircleView 的位置 mCircleView.layout((width / 2 - circleWidth / 2), mCurrentTargetOffsetTop, (width / 2 + circleWidth / 2), mCurrentTargetOffsetTop + circleHeight);&#125; 在 onLayout 中放置了 mCircleView 的位置，注意 顶部位置是 mCurrentTargetOffsetTop ，mCurrentTargetOffsetTop 初始距离是-mCircleView.getMeasuredHeight()，所以是在 SwipeRefreshLayout 外。 经过以上几个步骤，SwipeRefreshLayout 创建了子视图，确定他们的大小、位置，现在所有视图可以显示在界面了。 处理与子视图的滚动交互下拉刷新控件的主要功能是当子视图下拉到最顶部时，继续下拉可以出现刷新动画。而子视图可以滚动时需要将所有滚动事件都交给子视图。借助 Android 提供的 NestedScrolling 机制，使得 SwipeRefreshLayout 很轻松的解决了与子视图的滚动冲突问题。SwipeRefreshLayout 通过实现 NestedScrollingParent 和 NestedScrollingChild 接口来处理滚动冲突。SwipeRefreshLayout 作为 Parent 嵌套一个可以滚动的子视图，那么就需要了解一下 NestedScrollingParent 接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** 当你希望自己的自定义布局支持嵌套子视图并且处理滚动操作，就可以实现该接口。 实现这个接口后可以创建一个 NestedScrollingParentHelper 字段，使用它来帮助你处理大部分的方法。 处理嵌套的滚动时应该使用 `ViewCompat`，`ViewGroupCompat`或`ViewParentCompat` 中的方法来处理，这是一些兼容库， 他们保证 Android 5.0之前的兼容性垫片的静态方法，这样可以兼容 Android 5.0 之前的版本。 */public interface NestedScrollingParent &#123; /** * 当子视图调用 startNestedScroll(View, int) 后调用该方法。返回 true 表示响应子视图的滚动。 * 实现这个方法来声明支持嵌套滚动，如果返回 true，那么这个视图将要配合子视图嵌套滚动。当嵌套滚动结束时会调用到 onStopNestedScroll(View)。 * * @param child 可滚动的子视图 * @param target NestedScrollingParent 的直接可滚动的视图，一般情况就是 child * @param nestedScrollAxes 包含 ViewCompat#SCROLL_AXIS_HORIZONTAL, ViewCompat#SCROLL_AXIS_VERTICAL 或者两个值都有。 * @return 返回 true 表示响应子视图的滚动。 */ public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes); /** * 如果 onStartNestedScroll 返回 true ，然后走该方法，这个方法里可以做一些初始化。 */ public void onNestedScrollAccepted(View child, View target, int nestedScrollAxes); /** * 子视图开始滚动前会调用这个方法。这时候父布局（也就是当前的 NestedScrollingParent 的实现类）可以通过这个方法来配合子视图同时处理滚动事件。 * * @param target 滚动的子视图 * @param dx 绝对值为手指在x方向滚动的距离，dx&lt;0 表示手指在屏幕向右滚动 * @param dy 绝对值为手指在y方向滚动的距离，dy&lt;0 表示手指在屏幕向下滚动 * @param consumed 一个数组，值用来表示父布局消耗了多少距离，未消耗前为[0,0], 如果父布局想处理滚动事件，就可以在这个方法的实现中为consumed[0]，consumed[1]赋值。 * 分别表示x和y方向消耗的距离。如父布局想在竖直方向（y）完全拦截子视图，那么让 consumed[1] = dy，就把手指产生的触摸事件给拦截了，子视图便响应不到触摸事件了 。 */ public void onNestedPreScroll(View target, int dx, int dy, int[] consumed); /** * 这个方法表示子视图正在滚动，并且把滚动距离回调用到该方法，前提是 onStartNestedScroll 返回了 true。 * &lt;p&gt;Both the consumed and unconsumed portions of the scroll distance are reported to the * ViewParent. An implementation may choose to use the consumed portion to match or chase scroll * position of multiple child elements, for example. The unconsumed portion may be used to * allow continuous dragging of multiple scrolling or draggable elements, such as scrolling * a list within a vertical drawer where the drawer begins dragging once the edge of inner * scrolling content is reached.&lt;/p&gt; * * @param target 滚动的子视图 * @param dxConsumed 手指产生的触摸距离中，子视图消耗的x方向的距离 * @param dyConsumed 手指产生的触摸距离中，子视图消耗的y方向的距离 ，如果 onNestedPreScroll 中 dy = 20， consumed[0] = 8，那么 dy = 12 * @param dxUnconsumed 手指产生的触摸距离中，未被子视图消耗的x方向的距离 * @param dyUnconsumed 手指产生的触摸距离中，未被子视图消耗的y方向的距离 */ public void onNestedScroll(View target, int dxConsumed, int dyConsumed,int dxUnconsumed, int dyUnconsumed); /** * 响应嵌套滚动结束 * * 当一个嵌套滚动结束后（如MotionEvent#ACTION_UP， MotionEvent#ACTION_CANCEL）会调用该方法，在这里可有做一些收尾工作，比如变量重置 */ public void onStopNestedScroll(View target); /** * 手指在屏幕快速滑触发Fling前回调，如果前面 onNestedPreScroll 中父布局消耗了事件，那么这个也会被触发 * 返回true表示父布局完全处理 fling 事件 * * @param target 滚动的子视图 * @param velocityX x方向的速度（px/s） * @param velocityY y方向的速度 * @return true if this parent consumed the fling ahead of the target view */ public boolean onNestedPreFling(View target, float velocityX, float velocityY); /** * 子视图fling 时回调，父布局可以选择监听子视图的 fling。 * true 表示父布局处理 fling，false表示父布局监听子视图的fling * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @param consumed true 表示子视图处理了fling */ public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed); /** * 返回当前 NestedScrollingParent 的滚动方向， * * @return * @see ViewCompat#SCROLL_AXIS_HORIZONTAL * @see ViewCompat#SCROLL_AXIS_VERTICAL * @see ViewCompat#SCROLL_AXIS_NONE */ public int getNestedScrollAxes();&#125; 看一下 SwipeRefreshLayout 实现 NestedScrollingParent 的相关方法123456789101112131415161718// NestedScrollingParent// 子 View （NestedScrollingChild）开始滚动前回调此方法,返回 true 表示接 Parent 收嵌套滚动，然后调用 onNestedScrollAccepted// 具体可以看 NestedScrollingChildHelper 的源码@Overridepublic boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; // 子 View 回调，判断是否开始嵌套滚动 ， return isEnabled() &amp;&amp; !mReturningToStart &amp;&amp; !mRefreshing &amp;&amp; (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;&#125;@Override public void onNestedScrollAccepted(View child, View target, int axes) &#123; // Reset the counter of how much leftover scroll needs to be consumed. mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes); // ...省略代码 &#125; SwipeRefreshLayout 只接受竖直方向（Y轴）的滚动，并且在刷新动画进行中不接受滚动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// NestedScrollingChild 在滚动的时候会触发， 看父类消耗了多少距离// * @param dx x 轴滚动的距离// * @param dy y 轴滚动的距离// * @param consumed 代表 父 View 消费的滚动距离//@Overridepublic void onNestedPreScroll(View target, int dx, int dy, int[] consumed) &#123; // dy &gt; 0 表示手指在屏幕向上移动 // mTotalUnconsumed 表示子视图Y轴未消费的距离 // 现在表示 if (dy &gt; 0 &amp;&amp; mTotalUnconsumed &gt; 0) &#123; if (dy &gt; mTotalUnconsumed) &#123; consumed[1] = dy - (int) mTotalUnconsumed; // SwipeRefreshLayout 就吧子视图位消费的距离全部消费了。 mTotalUnconsumed = 0; &#125; else &#123; mTotalUnconsumed -= dy; // 消费的 y 轴的距离 consumed[1] = dy; &#125; // 出现动画圆圈，并向上移动 moveSpinner(mTotalUnconsumed); &#125; // ... 省略代码&#125;// onStartNestedScroll 返回 true 才会调用此方法。此方法表示子View将滚动事件分发到父 View（SwipeRefreshLayout）@Overridepublic void onNestedScroll(final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; // ... 省略代码 // This is a bit of a hack. Nested scrolling works from the bottom up, and as we are // sometimes between two nested scrolling views, we need a way to be able to know when any // nested scrolling parent has stopped handling events. We do that by using the // 'offset in window 'functionality to see if we have been moved from the event. // This is a decent indication of whether we should take over the event stream or not. // 手指在屏幕上向下滚动，并且子视图不可以滚动 final int dy = dyUnconsumed + mParentOffsetInWindow[1]; if (dy &lt; 0 &amp;&amp; !canChildScrollUp()) &#123; mTotalUnconsumed += Math.abs(dy); moveSpinner(mTotalUnconsumed); &#125;&#125; SwipeRefreshLayout 通过 NestedScrollingParent 接口完成了处理子视图的滚动的冲突，中间省略了一些 SwipeRefreshLayout作为 child 的相关代码，这种情况是为了兼容将 SwipeRefreshLayout 作为子视图放在知识嵌套滚动的父布局的情况，这里不做深入讨论。但是下拉刷新需要判断手指在屏幕的状态来进行一个刷新的动画，所以我们还需要处理触摸事件，判断手指在屏幕中的状态。 首先是 onInterceptTouchEvent，返回 true 表示拦截触摸事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; ensureTarget(); final int action = MotionEventCompat.getActionMasked(ev); // 手指按下时恢复状态 if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123; mReturningToStart = false; &#125; // 控件可用 || 刷新事件刚结束正在恢复初始状态时 || 子 View 可滚动 || 正在刷新 || 父 View 正在滚动 if (!isEnabled() || mReturningToStart || canChildScrollUp() || mRefreshing || mNestedScrollInProgress) &#123; // Fail fast if we're not in a state where a swipe is possible return false; &#125; switch (action) &#123; case MotionEvent.ACTION_DOWN: setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop(), true); mActivePointerId = MotionEventCompat.getPointerId(ev, 0); mIsBeingDragged = false; // 记录手指按下的位置，为了判断是否开始滚动 final float initialDownY = getMotionEventY(ev, mActivePointerId); if (initialDownY == -1) &#123; return false; &#125; mInitialDownY = initialDownY; break; case MotionEvent.ACTION_MOVE: if (mActivePointerId == INVALID_POINTER) &#123; Log.e(LOG_TAG, \"Got ACTION_MOVE event but don't have an active pointer id.\"); return false; &#125; final float y = getMotionEventY(ev, mActivePointerId); if (y == -1) &#123; return false; &#125; // 判断当拖动距离大于最小距离时设置 mIsBeingDragged = true; final float yDiff = y - mInitialDownY; if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123; mInitialMotionY = mInitialDownY + mTouchSlop; mIsBeingDragged = true; // 正在拖动状态，更新圆圈的 progressbar 的 alpha 值 mProgress.setAlpha(STARTING_PROGRESS_ALPHA); &#125; break; case MotionEventCompat.ACTION_POINTER_UP: onSecondaryPointerUp(ev); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mIsBeingDragged = false; mActivePointerId = INVALID_POINTER; break; &#125; return mIsBeingDragged;&#125; 可以看到源码也就是进行简单处理，DOWN 的时候记录一下位置，MOVE 时判断移动的距离，返回值 mIsBeingDragged 为 true 时， 即 onInterceptTouchEvent 返回true，SwipeRefreshLayout 拦截触摸事件，不分发给 mTarget，然后把 MotionEvent 传给 onTouchEvent 方法。其中有一个判断子View的是否还可以滚动的方法 canChildScrollUp。 12345678910111213141516171819/** * @return Whether it is possible for the child view of this layout to * scroll up. Override this if the child view is a custom view. */public boolean canChildScrollUp() &#123; if (android.os.Build.VERSION.SDK_INT &lt; 14) &#123; // 判断 AbsListView 的子类 ListView 或者 GridView 等 if (mTarget instanceof AbsListView) &#123; final AbsListView absListView = (AbsListView) mTarget; return absListView.getChildCount() &gt; 0 &amp;&amp; (absListView.getFirstVisiblePosition() &gt; 0 || absListView.getChildAt(0) .getTop() &lt; absListView.getPaddingTop()); &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1) || mTarget.getScrollY() &gt; 0; &#125; &#125; else &#123; return ViewCompat.canScrollVertically(mTarget, -1); &#125;&#125; 当SwipeRefreshLayout 拦截了触摸事件之后（ mIsBeingDragged 为 true ），将 MotionEvent 交给 onTouchEvent 处理。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Overridepublic boolean onTouchEvent(MotionEvent ev) &#123; // ... 省略代码 switch (action) &#123; case MotionEvent.ACTION_DOWN: // 获取第一个按下的手指 mActivePointerId = MotionEventCompat.getPointerId(ev, 0); mIsBeingDragged = false; break; case MotionEvent.ACTION_MOVE: &#123; // 处理多指触控 pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); // ... 省略代码 final float y = MotionEventCompat.getY(ev, pointerIndex); final float overscrollTop = (y - mInitialMotionY) * DRAG_RATE; if (mIsBeingDragged) &#123; if (overscrollTop &gt; 0) &#123; // 正在拖动状态，更新圆圈的位置 moveSpinner(overscrollTop); &#125; else &#123; return false; &#125; &#125; break; &#125; // ... 省略代码 case MotionEvent.ACTION_UP: &#123; pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); if (pointerIndex &lt; 0) &#123; Log.e(LOG_TAG, \"Got ACTION_UP event but don't have an active pointer id.\"); return false; &#125; final float y = MotionEventCompat.getY(ev, pointerIndex); final float overscrollTop = (y - mInitialMotionY) * DRAG_RATE; mIsBeingDragged = false; // 手指松开，将圆圈移动到正确的位置 finishSpinner(overscrollTop); mActivePointerId = INVALID_POINTER; return false; &#125; // ... 省略代码 &#125; return true;&#125; 在手指滚动过程中通过判断 mIsBeingDragged 来移动刷新的圆圈（对应的是 moveSpinner ），手指松开将圆圈移动到正确位置（初始位置或者刷新动画的位置，对应的是 finishSpinner 方法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 手指下拉过程中触发的圆圈的变化过程，透明度变化，渐渐出现箭头，大小的变化private void moveSpinner(float overscrollTop) &#123; // 设置为有箭头的 progress mProgress.showArrow(true); // 进度转化成百分比 float originalDragPercent = overscrollTop / mTotalDragDistance; // 避免百分比超过 100% float dragPercent = Math.min(1f, Math.abs(originalDragPercent)); // 调整拖动百分比，造成视差效果 float adjustedPercent = (float) Math.max(dragPercent - .4, 0) * 5 / 3; // float extraOS = Math.abs(overscrollTop) - mTotalDragDistance; // 这里mUsingCustomStart 为 true 代表用户自定义了起始出现的坐标 float slingshotDist = mUsingCustomStart ? mSpinnerFinalOffset - mOriginalOffsetTop : mSpinnerFinalOffset; // 弹性系数 float tensionSlingshotPercent = Math.max(0, Math.min(extraOS, slingshotDist * 2) / slingshotDist); float tensionPercent = (float) ((tensionSlingshotPercent / 4) - Math.pow( (tensionSlingshotPercent / 4), 2)) * 2f; float extraMove = (slingshotDist) * tensionPercent * 2; // 因为有弹性系数，不同的手指滚动距离不同于view的移动距离 int targetY = mOriginalOffsetTop + (int) ((slingshotDist * dragPercent) + extraMove); // where 1.0f is a full circle if (mCircleView.getVisibility() != View.VISIBLE) &#123; mCircleView.setVisibility(View.VISIBLE); &#125; // 设置的是否有缩放 if (!mScale) &#123; ViewCompat.setScaleX(mCircleView, 1f); ViewCompat.setScaleY(mCircleView, 1f); &#125; // 设置缩放进度 if (mScale) &#123; setAnimationProgress(Math.min(1f, overscrollTop / mTotalDragDistance)); &#125; // 移动距离未达到最大距离 if (overscrollTop &lt; mTotalDragDistance) &#123; if (mProgress.getAlpha() &gt; STARTING_PROGRESS_ALPHA &amp;&amp; !isAnimationRunning(mAlphaStartAnimation)) &#123; // Animate the alpha startProgressAlphaStartAnimation(); &#125; &#125; else &#123; if (mProgress.getAlpha() &lt; MAX_ALPHA &amp;&amp; !isAnimationRunning(mAlphaMaxAnimation)) &#123; // Animate the alpha startProgressAlphaMaxAnimation(); &#125; &#125; // 出现的进度，裁剪 mProgress float strokeStart = adjustedPercent * .8f; mProgress.setStartEndTrim(0f, Math.min(MAX_PROGRESS_ANGLE, strokeStart)); mProgress.setArrowScale(Math.min(1f, adjustedPercent)); // 旋转 float rotation = (-0.25f + .4f * adjustedPercent + tensionPercent * 2) * .5f; mProgress.setProgressRotation(rotation); setTargetOffsetTopAndBottom(targetY - mCurrentTargetOffsetTop, true /* requires update */);&#125; 刷新圆圈的移动过程也是有好几种状态，看上面的注释基本上就比较清楚了。 12345678910111213141516private void finishSpinner(float overscrollTop) &#123; if (overscrollTop &gt; mTotalDragDistance) &#123; //移动距离超过了刷新的临界值，触发刷新动画 setRefreshing(true, true /* notify */); &#125; else &#123; // 取消刷新的圆圈，将圆圈移动到初始位置 mRefreshing = false; mProgress.setStartEndTrim(0f, 0f); // ...省略代码 // 移动到初始位置 animateOffsetToStartPosition(mCurrentTargetOffsetTop, listener); // 设置没有箭头 mProgress.showArrow(false) &#125;&#125; 可以看到调用 setRefresh(true,true) 方法触发刷新动画并进行回调，但是这个方法是 private 的。前面提到我们自己调用 setRefresh(true) 只能产生动画，而不能回调刷新函数，那么我们就可以用反射调用 2 个参数的 setRefresh 函数。 或者手动调 setRefreshing(true)+ OnRefreshListener.onRefresh 方法。 setRefresh123456789101112131415161718192021222324/** * 改变刷新动画的的圆圈刷新状态。Notify the widget that refresh state has changed. Do not call this when * refresh is triggered by a swipe gesture. * * @param refreshing 是否显示刷新的圆圈 */ public void setRefreshing(boolean refreshing) &#123; if (refreshing &amp;&amp; mRefreshing != refreshing) &#123; // scale and show mRefreshing = refreshing; int endTarget = 0; if (!mUsingCustomStart) &#123; endTarget = (int) (mSpinnerFinalOffset + mOriginalOffsetTop); &#125; else &#123; endTarget = (int) mSpinnerFinalOffset; &#125; setTargetOffsetTopAndBottom(endTarget - mCurrentTargetOffsetTop, true /* requires update */); mNotify = false; startScaleUpAnimation(mRefreshListener); &#125; else &#123; setRefreshing(refreshing, false /* notify */); &#125; &#125; startScaleUpAnimation 开启一个动画，然后在动画结束后回调 onRefresh 方法。 12345678910111213141516171819private Animation.AnimationListener mRefreshListener = new Animation.AnimationListener() &#123; // .. 省略代码 @Override public void onAnimationEnd(Animation animation) &#123; if (mRefreshing) &#123; mProgress.setAlpha(MAX_ALPHA); //确保刷新圆圈中间的进度条是完全不透明了 mProgress.start(); if (mNotify) &#123; // 当 mNotify 为 true 时才会回调 onRefresh if (mListener != null) &#123; // 回调 listener 的 onRefresh 方法 mListener.onRefresh(); &#125; &#125; mCurrentTargetOffsetTop = mCircleView.getTop(); &#125; else &#123; reset(); &#125; &#125;&#125;; 总结分析 SwipeRefreshLayout 的流程就是按照平时我们自定义 ViewGroup 的流程，但是其中也有好多需要我们借鉴的地方，如何使用 NestedScrolling相关机制 ，多点触控的处理，onMeasure 中减去了 padding，如何判断子 View 是否可滚动，如何确定 ViewGroup 中某一个 View 的索引等。此外，一个好的下拉刷新框架不仅仅要兼容各种滚动的子控件，还要考虑自己要兼容 NestedScrollingChild 的情况，比如放到 CooCoordinatorLayout 的情况，目前大多数开源的下拉刷新好像都没有达到这个要求，一般都是只考虑了内部嵌套滚动子视图的情况，没有考虑自己作为滚动子视图的情况。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"SearchView源码解析","date":"2017-07-26T11:59:27.000Z","path":"2017/07/26/SearchView源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 SearchView源码解析SearchView是一个搜索框控件，样式也挺好看的。这次解析主要围绕android.support.v7.widget包下的SearchView（API &gt;= 7）,android.widget.SearchView支持API &gt;= 11，另外有个android.support.v4.widget.SearchViewCompat 1. 源码解析v7版本：23.2.1 1.1 继承关系12345java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup ↳ android.support.v7.widget.LinearLayoutCompat ↳ android.support.v7.widget.SearchView 1.2 主要组件12345678910private final SearchAutoComplete mSearchSrcTextView;private final View mSearchEditFrame;private final View mSearchPlate;private final View mSubmitArea;private final ImageView mSearchButton;private final ImageView mGoButton;private final ImageView mCloseButton;private final ImageView mVoiceButton;private final View mDropDownAnchor;private final ImageView mCollapsedIcon; 看命名也能大概知道控件各自充当了什么角色了。 1.3 构造方法和自定义接下来看构造方法public SearchView(Context context, AttributeSet attrs, int defStyleAttr),v7的SearchView并不是用TypedArray而是使用TintTypedArray，看了源码发现TintTypedArray里有个：final TypedArray mWrapped; ```所以主要还是`TypedArray`，不同点是`getDrawable(int index)`和新加的`getDrawableIfKnown(int index)`方法，123456789101112131415并在满足条件下会调用`AppCompatDrawableManager.get().getDrawable(mContext, resourceId)`。为了能更好的自定义，`SearchView`的layout也是可以指定的，不过自定义的layout必须包括上面那些控件，同时id也是指定的，不然后面会报错，因为`findViewById(id)`无法找到各自控件，然后调用控件方法的时候就。。。构造方法最后是更新控件状态，`mIconifiedByDefault`默认是`true`的，`setIconifiedByDefault(boolean iconified)`改变值后也会执行如下方法：```java public void setIconifiedByDefault(boolean iconified) &#123; if (mIconifiedByDefault == iconified) return; mIconifiedByDefault = iconified; //更新组件 updateViewsVisibility(iconified); updateQueryHint(); &#125; 所以setIconifiedByDefault(false)会让SearchView一直呈现展开状态，并且输入框内icon也会不显示。具体方法如下，该方法在updateQueryHint()中被调用：12345678910111213141516private CharSequence getDecoratedHint(CharSequence hintText) &#123; //如果mIconifiedByDefault为false或者mSearchHintIcon为null //将不会添加搜索icon到提示hint中 if (!mIconifiedByDefault || mSearchHintIcon == null) &#123; return hintText; &#125; final int textSize = (int) (mSearchSrcTextView.getTextSize() * 1.25); mSearchHintIcon.setBounds(0, 0, textSize, textSize); final SpannableStringBuilder ssb = new SpannableStringBuilder(\" \"); ssb.setSpan(new ImageSpan(mSearchHintIcon), 1, 2, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); ssb.append(hintText); return ssb;&#125; 1.4 Listener然后，我们来看看SearchView里面有哪些Listener： 1234567891011121314151617181920212223//里面有2个方法： //onQueryTextSubmit(String query)：当用户提交查询的时候会调用 //onQueryTextChange(String newText)：当查询文字改变的时候会调用private OnQueryTextListener mOnQueryChangeListener;//里面有1个方法：boolean onClose(); //onClose()：当mCloseButton被点击和setIconified(true)会判断是否调用 //是否调用是在onCloseClicked()里判断，后面会进行分析private OnCloseListener mOnCloseListener;//View类里定义的接口private OnFocusChangeListener mOnQueryTextFocusChangeListener;//里面有2个方法： //onSuggestionSelect(int position)：选择建议可选项（搜索框下方出现的）后触发 //onSuggestionClick(int position)：点击建议可选项后触发private OnSuggestionListener mOnSuggestionListener;//View类里定义的接口private OnClickListener mOnSearchClickListener;//还有其他mOnClickListener，mTextKeyListener等 我们看看OnQueryTextListener是怎样进行监听的： onQueryTextChange(String newText) 12//在构造方法里添加了监听mSearchSrcTextView.addTextChangedListener(mTextWatcher); 然后在mTextWatcher的onTextChanged()方法里调用了SearchView的onTextChanged(CharSequence newText)方法，也就是在这里进行了判断触发: 12345678910111213private void onTextChanged(CharSequence newText) &#123; /** * 省略代码,主要是更新组件 */ //当listener!=null和当文本不一样的时候会触发。 if (mOnQueryChangeListener != null &amp;&amp; !TextUtils.equals(newText, mOldQueryText)) &#123; mOnQueryChangeListener.onQueryTextChange(newText.toString()); &#125; //省略代码&#125; onQueryTextSubmit(String query) 12345678910111213141516171819202122232425262728293031323334353637//同在构造方法里添加了监听mSearchSrcTextView.setOnEditorActionListener(mOnEditorActionListener);private final OnEditorActionListener mOnEditorActionListener = new OnEditorActionListener() &#123; /** * Called when the input method default action key is pressed. */ public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; onSubmitQuery(); return true; &#125;&#125;;private void onSubmitQuery() &#123; CharSequence query = mSearchSrcTextView.getText(); if (query != null &amp;&amp; TextUtils.getTrimmedLength(query) &gt; 0) &#123; //当监听OnQueryChangeListener了之后， //当onQueryTextSubmit() return true的话，是不会执行下面操作的 if (mOnQueryChangeListener == null || !mOnQueryChangeListener.onQueryTextSubmit(query.toString())) &#123; //设置了Searchable后，会startActivity到配置指定的Activity if (mSearchable != null) &#123; launchQuerySearch(KeyEvent.KEYCODE_UNKNOWN, null, query.toString()); &#125; //设置键盘是否显示 setImeVisibility(false); //下拉可选项是用ListPopupWindow显示的，具体可看 AutoCompleteTextView 源码 //搜索提交后，dismiss后就不会继续显示而挡住内容什么的 dismissSuggestions(); &#125; &#125;&#125; 在if里加入!mOnQueryChangeListener.onQueryTextSubmit(query.toString())，这样做就可以让使用者自己决定是否完全自己处理，灵活性也更高。 其他Listener差不多也是这样，那接下来看看其他的。 1.5 CollapsibleActionView接口SearchView实现了CollapsibleActionView接口：onActionViewExpanded()和onActionViewCollapsed(),具体操作就是设置键盘及控件，并使用全局变量mExpandedInActionView记录ActionView是否伸展。只有当SearchView作为MenuItem的时候才会触发，如果是使用v7包的话，想要通过menu获取SearchView就需要使用MenuItemCompat类，具体可以看demo。1MenuItemCompat.getActionView(android.view.MenuItem item); 1.6 状态的保存和恢复SearchView覆写了onSaveInstanceState()和onRestoreInstanceState(Parcelable state)用来保存和恢复状态，为什么要覆写呢？因为需要额外保存boolean mIconified，为此还建了个内部静态类SavedState用来保存mIconified。 123456789//实现了Parcelable序列化static class SavedState extends BaseSavedState &#123; boolean isIconified; /** * 省略其他代码 */&#125; 1.7 关于Suggestions和Searchable如果你使用了Suggestions，而且没有setSearchableInfo，那么当你点击建议可选项的时候会log： 12345678W/SearchView: Search suggestions cursor at row 0 returned exception. java.lang.NullPointerException at android.support.v7.widget.SearchView.createIntentFromSuggestion(SearchView.java:1620) at android.support.v7.widget.SearchView.launchSuggestion(SearchView.java:1436) at android.support.v7.widget.SearchView.onItemClicked(SearchView.java:1349) at android.support.v7.widget.SearchView.access$1800(SearchView.java:103) at android.support.v7.widget.SearchView$10.onItemClick(SearchView.java:1373) ...... 定位到第1620行： 123456789101112131415161718192021222324252627private Intent createIntentFromSuggestion(Cursor c, int actionKey, String actionMsg) &#123; try &#123; // use specific action if supplied, or default action if supplied, or fixed default String action = getColumnString(c, SearchManager.SUGGEST_COLUMN_INTENT_ACTION); //在这里并没有检查mSearchable是否为null if (action == null &amp;&amp; Build.VERSION.SDK_INT &gt;= 8) &#123; action = mSearchable.getSuggestIntentAction(); //第1620行 &#125; /** *省略部分代码 */ return createIntent(action, dataUri, extraData, query, actionKey, actionMsg); &#125; catch (RuntimeException e ) &#123; /** *省略部分代码 */ Log.w(LOG_TAG, \"Search suggestions cursor at row \" + rowNum + \" returned exception.\", e); return null; &#125;&#125; 发现调用mSearchable的方法之前并没有检查mSearchable是否为null，其他地方是有判断的，由于做了catch所以不会crash，也不影响使用，另外，如果setOnSuggestionListener： 1234567891011mSearchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() &#123; @Override public boolean onQueryTextSubmit(String query) &#123; return false; &#125; @Override public boolean onQueryTextChange(String newText) &#123; return true; //返回true &#125;&#125;); onSuggestionClick(int position) 返回 true 就不会执行createIntentFromSuggestion(~)，也就不会log了，但这样，键盘的隐藏和可选项pop的dismiss也不会执行，需要自己处理，使用SearchView的clearFocus()方法就能达到同样的效果。 那既然是报null，那就设置Searchable吧，设置后是会startActivity的(执行完createIntentFromSuggestion(~)后就会执行)。然后效果就是当你点击了可选项就会startActivity，看需求做选择吧。。 1.8 语音搜索功能SearchView还有语音搜索功能(API &gt;= 8)，需要通过配置Searchable来开启，在xml配置文件中加入： 1android:voiceSearchMode=\"showVoiceSearchButton|launchRecognizer\" showVoiceSearchButton显示语音搜索按钮，launchRecognizer表示要启动一个语音识别器来转换成文字传给指定的searchable activity。有个全局变量boolean mVoiceButtonEnabled表示是否启用，在setSearchableInfo(~)方法里进行了设置： 1mVoiceButtonEnabled = IS_AT_LEAST_FROYO &amp;&amp; hasVoiceSearch(); IS_AT_LEAST_FROYO是Build.VERSION.SDK_INT &gt;= 8，为了确保正确性，我试了下，结果并没有显示语言搜索按钮，debug后发现在hasVoiceSearch()里： 123ResolveInfo ri = getContext().getPackageManager().resolveActivity(testIntent, PackageManager.MATCH_DEFAULT_ONLY);return ri != null; 在这里并没有resolve到Activity，结果return false，mVoiceButtonEnabled也就变成false了 终于知道为什么了，原来阉割版的系统都不会出现语音搜索按钮，华为/魅族/Genymotion试过都不行(没有试过全版本系统)，AS自带模拟器可以(有Google服务)，具体应该就是没有resolve到Google语音识别Activity。对语音识别有兴趣的同学可以搜索RecognizerIntent。 1.9 AutoCompleteTextViewReflectorv7包的SearchView使用了反射机制，通过反射拿到AutoCompleteTextView和InputMethodManager隐藏的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041static final AutoCompleteTextViewReflector HIDDEN_METHOD_INVOKER = new AutoCompleteTextViewReflector();private static class AutoCompleteTextViewReflector &#123; private Method doBeforeTextChanged, doAfterTextChanged; private Method ensureImeVisible; private Method showSoftInputUnchecked; AutoCompleteTextViewReflector() &#123; /** * 省略部分代码 */ try &#123; showSoftInputUnchecked = InputMethodManager.class.getMethod( \"showSoftInputUnchecked\", int.class, ResultReceiver.class); showSoftInputUnchecked.setAccessible(true); &#125; catch (NoSuchMethodException e) &#123; // Ah well. &#125; &#125; /** * 省略部分代码 */ void showSoftInputUnchecked(InputMethodManager imm, View view, int flags) &#123; if (showSoftInputUnchecked != null) &#123; try &#123; showSoftInputUnchecked.invoke(imm, flags, null); return; &#125; catch (Exception e) &#123; &#125; &#125; //只有这个方法才有在if后面做处理 // Hidden method failed, call public version instead imm.showSoftInput(view, flags); &#125; &#125; 1.10 onMeasure 测量查看了下onMeasure，发现有个地方还是比较在意的。 当isIconified()返回false的时候，width的mode在最后都会被设置成MeasureSpec.EXACTLY。 在SearchView伸展收缩的时候，onMeasure会被执行多次，width根据其mode改变, 之后mode设置为EXACTLY再调用父类super方法进行测量。 设置为EXACTLY，这样父控件就能确切的决定view的大小，那为什么只对width而不对height进行设置呢? 通过查看默认的 layout，可以看到主要组件的layout_height的大多都是match_parent(对应EXACTLY模式)，而layout_width基本都是wrap_content(对应AT_MOST模式)。 另外，不是只有伸展收缩的时候，onMeasure才会被执行, 点击语音搜索按钮/输入框获取焦点的时候/…也会执行。 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Let the standard measurements take effect in iconified state. if (isIconified()) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); return; &#125; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int width = MeasureSpec.getSize(widthMeasureSpec); switch (widthMode) &#123; case MeasureSpec.AT_MOST: // If there is an upper limit, don't exceed maximum width (explicit or implicit) if (mMaxWidth &gt; 0) &#123; width = Math.min(mMaxWidth, width); &#125; else &#123; width = Math.min(getPreferredWidth(), width); &#125; break; case MeasureSpec.EXACTLY: // If an exact width is specified, still don't exceed any specified maximum width if (mMaxWidth &gt; 0) &#123; width = Math.min(mMaxWidth, width); &#125; break; case MeasureSpec.UNSPECIFIED: // Use maximum width, if specified, else preferred width width = mMaxWidth &gt; 0 ? mMaxWidth : getPreferredWidth(); break; &#125; widthMode = MeasureSpec.EXACTLY; super.onMeasure(MeasureSpec.makeMeasureSpec(width, widthMode), heightMeasureSpec);&#125; 2. 展望未来在v7包的SearchView里，有一个声明并初始化了的变量，但并没有用到过: 1234private final AppCompatDrawableManager mDrawableManager;//在构造方法里初始化mDrawableManager = AppCompatDrawableManager.get(); 或许后续版本会用到吧! 抱着好奇的心去看了AppCompatDrawableManager源码，但并没有注释说明这个类是干什么用的，看名字只知道是管理Drawable的。 既然这样，那就来看下AppCompatDrawableManager能干些什么吧。 一步一步来，先看看它初始化的时候干了些什么，查看get()方法: 123456789101112131415161718192021222324public static AppCompatDrawableManager get() &#123; //使用了懒汉式 if (INSTANCE == null) &#123; INSTANCE = new AppCompatDrawableManager(); installDefaultInflateDelegates(INSTANCE); &#125; return INSTANCE;&#125;private static void installDefaultInflateDelegates(@NonNull AppCompatDrawableManager manager) &#123; final int sdk = Build.VERSION.SDK_INT; // 只在Android 5.0以下的系统 if (sdk &lt; 21) &#123; // 在需要的时候使用 VectorDrawableCompat 进行自动处理 manager.addDelegate(\"vector\", new VdcInflateDelegate()); if (sdk &gt;= 11) &#123; // AnimatedVectorDrawableCompat 只能在 API v11+ 使用 manager.addDelegate(\"animated-vector\", new AvdcInflateDelegate()); &#125; &#125;&#125; 从这里, 我们可以看出跟Vector(矢量)有关。 VectorDrawable能创建一个基于xml描述的矢量图; AnimatedVectorDrawable使用ObjectAnimator和AnimatorSet为VectorDrawable创建动画。 然后我粗略的看了方法名，有几个关键词: Tint着色，Cache，…… 有兴趣的同学可以搜下相关资料，这里就不再深入了。 如果我哪里分析错了，请大家及时纠正我，谢谢。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"Scroller源码解析","date":"2017-07-26T11:58:31.000Z","path":"2017/07/26/Scroller源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 本文分析版本: Android API 22 1. 简介Android开发中，如果我们希望使一个View滑动的话，除了使用属性动画外。我们还可以使用系统提供给我们的两个类Scroller和OverScroller用来实现弹性滑动。在我以前的一篇ViewDragHelper源码分析中我们有讲到过Scroller的作用。那么我们今天就来仔细分析一下Scroller的使用方法以及实现方式。 2. 使用方法在看Scroller的使用方法之前我们需要先了解一下View中的scrollBy()和scrollTo()方法，scrollTo()方法的实现如下： 1234567891011121314151617 public void scrollTo(int x, int y) &#123; //如果当前偏移量变化 if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY;//赋值偏移量 mScrollX = x; mScrollY = y; invalidateParentCaches(); //回调onScrollChanged方法 onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125; &#125; scrollTo()是指将当前视图内容横向偏移x距离，纵向偏移y距离。注意这里是View的内容的偏移，而不是View本身。而scrollBy()方法如下： 123public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; scrollBy()方法里直接调用了scrollTo()方法，表示在当前偏移量的基础上继续偏移(x,y)。现在我们来看看Scroller的用法。SkyScrollerDemo是我写的一个Scroller和OverScroller的使用demo。下面的用法都是来自于这个demo里，大家可以clone下来配合本文一起阅读。本文我们主要研究Scroller。对于OverScroller我在demo里也写了相关的使用方法，在本文的最后我们再做讨论。 Scroller一般需要配合重写computeScroll()一起使用，代码如下： 123456789101112131415161718192021222324252627282930313233public class ScrollTextView extends TextView &#123; private Context mContext; private Scroller mScroller; public ScrollTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); this.mContext = context; init(); &#125; private void init() &#123; mScroller = new Scroller(mContext); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; offsetLeftAndRight(mScroller.getCurrX() - mLeft); offsetTopAndBottom(mScroller.getCurrY() - mTop); invalidate(); &#125; &#125; //以mLeft,mTop为初始点，在DEFAULT_DURATION的时间内，在Y轴上滑动-400的偏移量 public void startScrollerScroll() &#123; mScroller.startScroll(mLeft, mTop, 0, -400, DEFAULT_DURATION); invalidate(); &#125; //以mLeft,mTop为初始点，并以Y方向上-5000的加速度滑动，最小Y坐标为200，最大Y坐标为1200 public void startScrollerFling() &#123; mScroller.fling(mLeft, mTop, 0, -5000, mLeft, mLeft, 200, 1200); invalidate(); &#125;&#125; 在上面的代码里，当我们调用startScrollerScroll()与startScrollerFling()方法时我们就发现View滑动了。如果以前没了解过Scroller的同学可能会不理解。这里大致分析一下调用流程，首先我们要知道Scroller其实只负责计算，它并不负责滑动View，当我们调用了Scroller的startScrollerScroll()方法时，我们紧接着调用了invalidate()方法。invalidate()方法会使View重新绘制。因此会调用View的draw()方法，在View的draw()方法中又会去调用computeScroll()方法，computeScroll()方法在View中是一个空实现，所以需要我们自己实现computeScroll()方法。在上面的computeScroll()方法中，我们调用了mScroller.computeScrollOffset()方法来计算当前滑动的偏移量。如果还在滑动过程中就会返回true。所以我们就能在if中通过Scroller拿到当前的滑动坐标从而做任何我们想做的处理。在demo里我们根据滑动的偏移量来改变了View的坐标偏移量。从而形成了滑动动画。下面我们解释一下Scroller的两个方法的具体作用： 1.startScroll(int startX, int startY, int dx, int dy, int duration):通过起始点、偏移的距离和滑动的时间来开始滑动。 startX 起始滑动点的X坐标 startY 起始滑动点的Y坐标 dx 滑动的水平偏移量。&gt;0 则表示往左滑动。 dy 滑动的垂直偏移量。&gt;0 则表示往上滑动。 duration 滑动执行的时间 2.fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) :基于一个快速滑动手势下的滑动。滑动的距离与这个手势最初的加速度有关。 startX 起始滑动点的X坐标 startY 起始滑动点的Y坐标 velocityX X方向上的加速度 velocityY Y方向上的加速度 minX X方向上滑动的最小值，不会滑动超过这个点 maxX X方向上滑动的最大值，不会滑动超过这个点 minY Y方向上滑动的最小值，不会滑动超过这个点 maxY Y方向上滑动的最大值，不会滑动超过这个点 3. 源码分析我们依然通过调用流程来分析Scroller的实现： 1.构造方法12345678910111213141516171819202122public Scroller(Context context) &#123; this(context, null);&#125;public Scroller(Context context, Interpolator interpolator) &#123; this(context, interpolator, context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB);&#125;public Scroller(Context context, Interpolator interpolator, boolean flywheel) &#123; mFinished = true; if (interpolator == null) &#123; mInterpolator = new ViscousFluidInterpolator(); &#125; else &#123; mInterpolator = interpolator; &#125; mPpi = context.getResources().getDisplayMetrics().density * 160.0f; mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction()); mFlywheel = flywheel; mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning&#125; 最终都会调用最后一个构造方法。必须传入Context对象。可以传入自定义的interpolator和是否支持飞轮flywheel的功能，当然这两个并不是必须的。如果不传入interpolator会默认创建一个ViscousFluidInterpolator，从字面意义上看是一个粘性流体插值器。对于flywheel是指是否支持在滑动过程中，如果有新的fling()方法调用是否累加加速度。如果不传默认在2.3以上都会支持。剩下就是初始化了一些用于计算的参数。这样就完成了Scroller的初始化了。下面我们来看看startScroll()方法的实现： 2.startScroll()方法的实现123456789101112131415161718192021222324public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123; // mMode 分两种方式 1.滑动:SCROLL_MODE 2. 加速度滑动:FLING_MODE mMode = SCROLL_MODE; // 是否滑动结束 这里是开始所以设置为false mFinished = false; // 滑动的时间 mDuration = duration; // 开始的时间 mStartTime = AnimationUtils.currentAnimationTimeMillis(); // 开始滑动点的X坐标 mStartX = startX; // 开始滑动点的Y坐标 mStartY = startY; // 最终滑动到位置的X坐标 mFinalX = startX + dx; // 最终滑动到位置的Y坐标 mFinalY = startY + dy; // X方向上滑动的偏移量 mDeltaX = dx; // Y方向上滑动的偏移量 mDeltaY = dy; // 持续时间的倒数 最终用来计算得到插值器返回的值 mDurationReciprocal = 1.0f / (float) mDuration;&#125; 很简单只是一些变量的赋值。根据我们前面使用方法里的分析，最终会调用computeScrollOffset()方法： 3.computeScrollOffset() 方法中 SCROLL_MODE 的实现12345678910111213141516171819202122232425262728293031// 当你需要知道新的位置的时候调用这个方法，如果动画还未结束则返回truepublic boolean computeScrollOffset() &#123; //如果已经结束 则直接返回false if (mFinished) &#123; return false; &#125; //得到以及度过的时间 int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); //如果还在动画时间内 if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: // 根据timePassed * mDurationReciprocal,从mInterpolator中取出当前需要偏移量的比例 final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); // 赋值给 mCurrX，mCurrY mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); break; case FLING_MODE: ... break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 首先的到当前时间与滑动开始时间的时间差，如果还在滑动时间内则通过插值器获得当前的进度并乘以总偏移量并赋值给mCurrX，mCurrY。如果已经结束则直接将mFinalX和mFinalY赋值并将mFinished设置\b为true。所以这样我们就能通过getCurrX()和getCurrY()来得到对应的mCurrX和mCurrY来做相应的处理了。整个Scroll的过程就是这样了。 4.fling()方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) &#123; // 如果前一次滑动还未结束，又调用了新的fling()方法时， // 则累加相同方向上加速度 if (mFlywheel &amp;&amp; !mFinished) &#123; float oldVel = getCurrVelocity(); float dx = (float) (mFinalX - mStartX); float dy = (float) (mFinalY - mStartY); float hyp = FloatMath.sqrt(dx * dx + dy * dy); float ndx = dx / hyp; float ndy = dy / hyp; float oldVelocityX = ndx * oldVel; float oldVelocityY = ndy * oldVel; if (Math.signum(velocityX) == Math.signum(oldVelocityX) &amp;&amp; Math.signum(velocityY) == Math.signum(oldVelocityY)) &#123; velocityX += oldVelocityX; velocityY += oldVelocityY; &#125; &#125; //设置为FLING_MODE mMode = FLING_MODE; mFinished = false; //根据勾股定理获得总加速度 float velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY); mVelocity = velocity; // 通过加速度得到滑动持续时间 mDuration = getSplineFlingDuration(velocity); mStartTime = AnimationUtils.currentAnimationTimeMillis(); mStartX = startX; mStartY = startY; float coeffX = velocity == 0 ? 1.0f : velocityX / velocity; float coeffY = velocity == 0 ? 1.0f : velocityY / velocity; double totalDistance = getSplineFlingDistance(velocity); mDistance = (int) (totalDistance * Math.signum(velocity)); mMinX = minX; mMaxX = maxX; mMinY = minY; mMaxY = maxY; mFinalX = startX + (int) Math.round(totalDistance * coeffX); // Pin to mMinX &lt;= mFinalX &lt;= mMaxX mFinalX = Math.min(mFinalX, mMaxX); mFinalX = Math.max(mFinalX, mMinX); mFinalY = startY + (int) Math.round(totalDistance * coeffY); // Pin to mMinY &lt;= mFinalY &lt;= mMaxY mFinalY = Math.min(mFinalY, mMaxY); mFinalY = Math.max(mFinalY, mMinY);&#125; 依然是为计算需要的各种变量赋值。因为引入了加速度的概念所以变得相对复杂，首先先判断了如果一次滑动未结束又触发另一次滑动时，是否需要累加加速度。然后是设置mMode为FLING_MODE。然后根据velocityX和velocityY算出总的加速度velocity，紧接着算出这个加速度下可以滑动的距离mDistance。最后再通过x或y方向上的加速度比值以及我们设定的最大值和最小值来给mFinalX或mFinalY赋值。赋值结束后，通过调用invalidate()，最终依然会调用computeScrollOffset()方法： 5.computeScrollOffset() 方法中 FLING_MODE 的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean computeScrollOffset() &#123; if (mFinished) &#123; return false; &#125; int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime); if (timePassed &lt; mDuration) &#123; switch (mMode) &#123; case SCROLL_MODE: ... break; case FLING_MODE: // 当前已滑动的时间与总滑动时间的比值 final float t = (float) timePassed / mDuration; final int index = (int) (NB_SAMPLES * t); // 距离系数 float distanceCoef = 1.f; // 加速度系数 float velocityCoef = 0.f; if (index &lt; NB_SAMPLES) &#123; final float t_inf = (float) index / NB_SAMPLES; final float t_sup = (float) (index + 1) / NB_SAMPLES; final float d_inf = SPLINE_POSITION[index]; final float d_sup = SPLINE_POSITION[index + 1]; velocityCoef = (d_sup - d_inf) / (t_sup - t_inf); distanceCoef = d_inf + (t - t_inf) * velocityCoef; &#125; // 计算出当前的加速度 mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f; // 计算出当前的mCurrX 与mCurrY mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX)); // Pin to mMinX &lt;= mCurrX &lt;= mMaxX mCurrX = Math.min(mCurrX, mMaxX); mCurrX = Math.max(mCurrX, mMinX); mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY)); // Pin to mMinY &lt;= mCurrY &lt;= mMaxY mCurrY = Math.min(mCurrY, mMaxY); mCurrY = Math.max(mCurrY, mMinY); // 如果到达了终点 则结束 if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123; mFinished = true; &#125; break; &#125; &#125; else &#123; mCurrX = mFinalX; mCurrY = mFinalY; mFinished = true; &#125; return true;&#125; 由于fling()方法中将mMode赋值为FLING_MODE。所以我们直接来看FLING_MODE中的代码。可以看出根据当前滑动时间与总滑动时间的比例。再根据一个SPLINE_POSITION数组计算出了距离系数distanceCoef与加速度系数velocityCoef。再根据这两个系数计算出当前加速度与当前的mCurrX与mCurrY。关于SPLINE_POSITION的初始化是在下面的静态代码块里赋值的： 1234567891011121314151617181920212223242526272829303132static &#123; float x_min = 0.0f; float y_min = 0.0f; for (int i = 0; i &lt; NB_SAMPLES; i++) &#123; final float alpha = (float) i / NB_SAMPLES; float x_max = 1.0f; float x, tx, coef; while (true) &#123; x = x_min + (x_max - x_min) / 2.0f; coef = 3.0f * x * (1.0f - x); tx = coef * ((1.0f - x) * P1 + x * P2) + x * x * x; if (Math.abs(tx - alpha) &lt; 1E-5) break; if (tx &gt; alpha) x_max = x; else x_min = x; &#125; SPLINE_POSITION[i] = coef * ((1.0f - x) * START_TENSION + x) + x * x * x; float y_max = 1.0f; float y, dy; while (true) &#123; y = y_min + (y_max - y_min) / 2.0f; coef = 3.0f * y * (1.0f - y); dy = coef * ((1.0f - y) * START_TENSION + y) + y * y * y; if (Math.abs(dy - alpha) &lt; 1E-5) break; if (dy &gt; alpha) y_max = y; else y_min = y; &#125; SPLINE_TIME[i] = coef * ((1.0f - y) * P1 + y * P2) + y * y * y; &#125; SPLINE_POSITION[NB_SAMPLES] = SPLINE_TIME[NB_SAMPLES] = 1.0f;&#125; 我并没有看懂这段代码的实际意义。网上也没有找到比较清晰的解释。通过debug得知SPLINE_POSITION是一个长度为101并且从0-1递增数组。猜想这应该是一个函数模型并且最终用于计算出滑动过程中的加速度与位置。至此Scroller的两个主要方法的实现我们就分析完了。 4. OverScroller解析OverScroller是对Scroller的拓展，它在Scroller的基础上拓展出了更多的方法。OverScroller的fling方法支持滑动到终点之后并超出一段距离并返回，类似于弹性效果。另外一个springBack()方法是指将指定的点平滑滚动到指定的终点上。这个终点由设置的参数决定。原理我们就不再探究了，大家可以自行研究这两个类的差别。最后具体的使用方法在文章最上面的demo里都有提供。可以clone下来帮助理解。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"LruCache源码解析","date":"2017-07-26T11:57:39.000Z","path":"2017/07/26/LruCache源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 1. 简介 LRU 是 Least Recently Used 最近最少使用算法。 曾经，在各大缓存图片的框架没流行的时候。有一种很常用的内存缓存技术：SoftReference 和 WeakReference（软引用和弱引用）。但是走到了 Android 2.3（Level 9）时代，垃圾回收机制更倾向于回收 SoftReference 或 WeakReference 的对象。后来，又来到了 Android3.0，图片缓存在内容中，因为不知道要在是什么时候释放内存，没有策略，没用一种可以预见的场合去将其释放。这就造成了内存溢出。 2. 使用方法当成一个 Map 用就可以了，只不过实现了 LRU 缓存策略。 使用的时候记住几点即可： 1.（必填）你需要提供一个缓存容量作为构造参数。 2.（必填） 覆写 sizeOf 方法 ，自定义设计一条数据放进来的容量计算，如果不覆写就无法预知数据的容量，不能保证缓存容量限定在最大容量以内。 3.（选填） 覆写 entryRemoved 方法 ，你可以知道最少使用的缓存被清除时的数据（ evicted, key, oldValue, newVaule ）。 4.（记住）LruCache是线程安全的，在内部的 get、put、remove 包括 trimToSize 都是安全的（因为都上锁了）。 5.（选填） 还有就是覆写 create 方法 。 一般做到 1、2、3、4就足够了，5可以无视 。 以下是 一个 LruCache 实现 Bitmap 小缓存的案例, entryRemoved 里的自定义逻辑可以无视，想看的可以去到我的我的展示 demo 里的看自定义 entryRemoved 逻辑。1234567891011121314private static final float ONE_MIB = 1024 * 1024;// 7MBprivate static final int CACHE_SIZE = (int) (7 * ONE_MIB);private LruCache&lt;String, Bitmap&gt; bitmapCache;this.bitmapCache = new LruCache&lt;String, Bitmap&gt;(CACHE_SIZE) &#123; protected int sizeOf(String key, Bitmap value) &#123; return value.getByteCount(); &#125; @Override protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123; ... &#125;&#125;; 3. 效果展示LruCache 效果展示 4. 源码分析4.1 LruCache 原理概要解析LruCache 就是 利用 LinkedHashMap 的一个特性（ accessOrder＝true 基于访问顺序 ）再加上对 LinkedHashMap 的数据操作上锁实现的缓存策略。 LruCache 的数据缓存是内存中的。 1.首先设置了内部 LinkedHashMap 构造参数 accessOrder=true， 实现了数据排序按照访问顺序。 2.然后在每次 LruCache.get(K key) 方法里都会调用 LinkedHashMap.get(Object key)。 3.如上述设置了 accessOrder=true 后，每次 LinkedHashMap.get(Object key) 都会进行 LinkedHashMap.makeTail(LinkedEntry&amp;lt;K, V&gt; e)。 4.LinkedHashMap 是双向循环链表，然后每次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 5.在 put 和 trimToSize 的方法执行下，如果发生数据量移除，会优先移除掉最前面的数据（因为最新访问的数据在尾部）。 具体解析在： 4.2、4.3、4.4、4.5 4.2 LruCache 的唯一构造方法12345678910111213141516/** * LruCache的构造方法：需要传入最大缓存个数 */public LruCache(int maxSize) &#123; ... this.maxSize = maxSize; /* * 初始化LinkedHashMap * 第一个参数：initialCapacity，初始大小 * 第二个参数：loadFactor，负载因子=0.75f * 第三个参数：accessOrder=true，基于访问顺序；accessOrder=false，基于插入顺序 */ this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);&#125; 第一个参数 initialCapacity 用于初始化该 LinkedHashMap 的大小。 先简单介绍一下 第二个参数 loadFactor，这个其实的 HashMap 里的构造参数，涉及到扩容问题，比如 HashMap 的最大容量是100，那么这里设置0.75f的话，到75容量的时候就会扩容。 主要是第三个参数 accessOrder=true ，这样的话 LinkedHashMap 数据排序就会基于数据的访问顺序，从而实现了 LruCache 核心工作原理。 4.3 LruCache.get(K key)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 根据 key 查询缓存，如果存在于缓存或者被 create 方法创建了。 * 如果值返回了，那么它将被移动到双向循环链表的的尾部。 * 如果没有缓存的值，则返回 null。 */public final V get(K key) &#123; ... V mapValue; synchronized (this) &#123; // 关键点：LinkedHashMap每次get都会基于访问顺序来重整数据顺序 mapValue = map.get(key); // 计算 命中次数 if (mapValue != null) &#123; hitCount++; return mapValue; &#125; // 计算 丢失次数 missCount++; &#125; /* * 官方解释： * 尝试创建一个值，这可能需要很长时间，并且Map可能在create()返回的值时有所不同。如果在create()执行的时 * 候，一个冲突的值被添加到Map，我们在Map中删除这个值，释放被创造的值。 */ V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; /*************************** * 不覆写create方法走不到下面 * ***************************/ /* * 正常情况走不到这里 * 走到这里的话 说明 实现了自定义的 create(K key) 逻辑 * 因为默认的 create(K key) 逻辑为null */ synchronized (this) &#123; // 记录 create 的次数 createCount++; // 将自定义create创建的值，放入LinkedHashMap中，如果key已经存在，会返回 之前相同key 的值 mapValue = map.put(key, createdValue); // 如果之前存在相同key的value，即有冲突。 if (mapValue != null) &#123; /* * 有冲突 * 所以 撤销 刚才的 操作 * 将 之前相同key 的值 重新放回去 */ map.put(key, mapValue); &#125; else &#123; // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, createdValue); &#125; &#125; // 如果上面 判断出了 将要放入的值发生冲突 if (mapValue != null) &#123; /* * 刚才create的值被删除了，原来的 之前相同key 的值被重新添加回去了 * 告诉 自定义 的 entryRemoved 方法 */ entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; // 上面 进行了 size += 操作 所以这里要重整长度 trimToSize(maxSize); return createdValue; &#125;&#125; 上述的 get 方法表面并没有看出哪里有实现了 LRU 的缓存策略。主要在 mapValue = map.get(key);里，调用了 LinkedHashMap 的 get 方法，再加上 LruCache 构造里默认设置 LinkedHashMap 的 accessOrder=true。 4.4 LinkedHashMap.get(Object key)1234567891011121314151617181920212223242526272829303132333435/** * Returns the value of the mapping with the specified key. * * @param key * the key. * @return the value of the mapping with the specified key, or &#123;@code null&#125; * if no mapping for the specified key is found. */@Override public V get(Object key) &#123; /* * This method is overridden to eliminate the need for a polymorphic * invocation in superclass at the expense of code duplication. */ if (key == null) &#123; HashMapEntry&lt;K, V&gt; e = entryForNullKey; if (e == null) return null; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; for (HashMapEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - 1)]; e != null; e = e.next) &#123; K eKey = e.key; if (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123; if (accessOrder) makeTail((LinkedEntry&lt;K, V&gt;) e); return e.value; &#125; &#125; return null;&#125; 其实仔细看 if (accessOrder) 的逻辑即可，如果 accessOrder=true 那么每次 get 都会执行 N 次 makeTail(LinkedEntry&amp;lt;K, V&gt; e) 。 接下来看看： 4.5 LinkedHashMap.makeTail(LinkedEntry&lt;K, V&gt; e)123456789101112131415161718/** * Relinks the given entry to the tail of the list. Under access ordering, * this method is invoked whenever the value of a pre-existing entry is * read by Map.get or modified by Map.put. */private void makeTail(LinkedEntry&lt;K, V&gt; e) &#123; // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;&#125; // Unlink e // Relink e as tail LinkedHashMap 是双向循环链表，然后此次 LruCache.get -&gt; LinkedHashMap.get 的数据就被放到最末尾了。 以上就是 LruCache 核心工作原理。 接下来介绍 LruCache 的容量溢出策略。 4.6 LruCache.put(K key, V value)123456789101112public final V put(K key, V value) &#123; ... synchronized (this) &#123; ... // 拿到键值对，计算出在容量中的相对长度，然后加上 size += safeSizeOf(key, value); ... &#125; ... trimToSize(maxSize); return previous;&#125; 记住几点： 1.put 开始的时候确实是把值放入 LinkedHashMap 了，不管超不超过你设定的缓存容量。 2.然后根据 safeSizeOf 方法计算 此次添加数据的容量是多少，并且加到 size 里 。 3.说到 safeSizeOf 就要讲到 sizeOf(K key, V value) 会计算出此次添加数据的大小 。 4.直到 put 要结束时，进行了 trimToSize 才判断 size 是否 大于 maxSize 然后进行最近很少访问数据的移除。 4.7 LruCache.trimToSize(int maxSize)1234567891011121314151617181920212223242526272829303132333435public void trimToSize(int maxSize) &#123; /* * 这是一个死循环， * 1.只有 扩容 的情况下能立即跳出 * 2.非扩容的情况下，map的数据会一个一个删除，直到map里没有值了，就会跳出 */ while (true) &#123; K key; V value; synchronized (this) &#123; // 在重新调整容量大小前，本身容量就为空的话，会出异常的。 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException( getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); &#125; // 如果是 扩容 或者 map为空了，就会中断，因为扩容不会涉及到丢弃数据的情况 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); // 拿到键值对，计算出在容量中的相对长度，然后减去。 size -= safeSizeOf(key, value); // 添加一次收回次数 evictionCount++; &#125; /* * 将最后一次删除的最少访问数据回调出去 */ entryRemoved(true, key, value, null); &#125;&#125; 简单描述：会判断之前 size 是否大于 maxSize 。是的话，直接跳出后什么也不做。不是的话，证明已经溢出容量了。由 makeTail 图已知，最近经常访问的数据在最末尾。拿到一个存放 key 的 Set，然后一直一直从头开始删除，删一个判断是否溢出，直到没有溢出。 最后看看： 4.8 覆写 entryRemoved 的作用entryRemoved被LruCache调用的场景： 1.（put） put 发生 key 冲突时被调用，evicted=false，key=此次 put 的 key，oldValue=被覆盖的冲突 value，newValue=此次 put 的 value。 2.（trimToSize） trimToSize 的时候，只会被调用一次，就是最后一次被删除的最少访问数据带回来。evicted=true，key=最后一次被删除的 key，oldValue=最后一次被删除的 value，newValue=null（此次没有冲突，只是 remove）。 3.（remove） remove的时候，存在对应 key，并且被成功删除后被调用。evicted=false，key=此次 put的 key，oldValue=此次删除的 value，newValue=null（此次没有冲突，只是 remove）。 4.（get后半段，查询丢失后处理情景，不过建议忽略） get 的时候，正常的话不实现自定义 create 的话，代码上看 get 方法只会走一半，如果你实现了自定义的 create(K key) 方法，并且在 你 create 后的值放入 LruCache 中发生 key 冲突时被调用，evicted=false，key=此次 get 的 key，oldValue=被你自定义 create(key)后的 value，newValue=原本存在 map 里的 key-value。 解释一下第四点吧： 第四点是这样的，先 get(key)，然后没拿到，丢失。 如果你提供了 自定义的 create(key) 方法，那么 LruCache 会根据你的逻辑自造一个 value，但是当放入的时候发现冲突了，但是已经放入了。 此时，会将那个冲突的值再让回去覆盖，此时调用上述4.的 entryRemoved。 因为 HashMap 在数据量大情况下，拿数据可能造成丢失，导致前半段查不到，你自定义的 create(key) 放入的时候发现又查到了（有冲突）。然后又急忙把原来的值放回去，此时你就白白create一趟，无所作为，还要走一遍entryRemoved。 综上就如同注释写的一样：12345678910/** * 1.当被回收或者删掉时调用。该方法当value被回收释放存储空间时被remove调用 * 或者替换条目值时put调用，默认实现什么都没做。 * 2.该方法没用同步调用，如果其他线程访问缓存时，该方法也会执行。 * 3.evicted=true：如果该条目被删除空间 （表示 进行了trimToSize or remove） evicted=false：put冲突后 或 get里成功create后 * 导致 * 4.newValue!=null，那么则被put()或get()调用。 */protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125; 可以参考我的 demo 里的 entryRemoved 。 4.9 LruCache 局部同步锁在 get, put, trimToSize, remove 四个方法里的 entryRemoved 方法都不在同步块里。因为 entryRemoved 回调的参数都属于方法域参数，不会线程不安全。 本地方法栈和程序计数器是线程隔离的数据区 5. 开源项目中的使用square/picasso 6. 总结LruCache重要的几点： 1.LruCache 是通过 LinkedHashMap 构造方法的第三个参数的 accessOrder=true 实现了 LinkedHashMap 的数据排序基于访问顺序 （最近访问的数据会在链表尾部），在容量溢出的时候，将链表头部的数据移除。从而，实现了 LRU 数据缓存机制。 2.LruCache 在内部的get、put、remove包括 trimToSize 都是安全的（因为都上锁了）。 3.LruCache 自身并没有释放内存，将 LinkedHashMap 的数据移除了，如果数据还在别的地方被引用了，还是有泄漏问题，还需要手动释放内存。 4.覆写 entryRemoved 方法能知道 LruCache 数据移除是是否发生了冲突，也可以去手动释放资源。 5.maxSize 和 sizeOf(K key, V value) 方法的覆写息息相关，必须相同单位。（ 比如 maxSize 是7MB，自定义的 sizeOf 计算每个数据大小的时候必须能算出与MB之间有联系的单位 ） 7. 资源LruCacheActivity LruCache 注释源码 原文链接 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"FloatingActionButton源码解析","date":"2017-07-26T11:55:14.000Z","path":"2017/07/26/FloatingActionButton源码解析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 背景FloatingActionButton（下文以fab代替）是android support design组件库中提供的一个视图控件，是material design设计中fab的官方实现。 此控件的官方介绍如下： Floating action buttons are used for a promoted action. They are distinguished by a circled icon floating above the UI and have motion behaviors that include morphing, launching, and a transferring anchor point. 关于该控件的设计规范及使用场景请参考文档： http://www.google.com/design/spec/components/buttons-floating-action-button.html# 如果你还不了解design组件库，请参考官方博客: http://android-developers.blogspot.hk/2015/05/android-design-support-library.html 开始源码版本:23.3.0 fab间接继承自ImageView（ImageButton是ImageView的子类），因而拥有ImageView的大部分特性。但是其内部还是做了很多定制，我们一一来看。 1. fab的自定义属性、背景着色相关从构造器开始： 12345678910111213141516171819202122public FloatingActionButton(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //检查是否使用Theme.Appcompat主题 ThemeUtils.checkAppCompatTheme(context); //拿到自定义属性并赋值 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FloatingActionButton, defStyleAttr, R.style.Widget_Design_FloatingActionButton); ... a.recycle(); final int maxImageSize = (int) getResources().getDimension(R.dimen.design_fab_image_size); mImagePadding = (getSizeDimension() - maxImageSize) / 2; //背景着色 getImpl().setBackgroundDrawable(mBackgroundTint, mBackgroundTintMode, mRippleColor, mBorderWidth); //绘制阴影 getImpl().setElevation(elevation); ... &#125; 构造器中主要是拿到用户设置的自定义属性，比如着色、波纹颜色、大小等等,一共有以下几个属性可以定义。 12345678910111213&lt;declare-styleable name=\"FloatingActionButton\"&gt;&lt;attr name=\"backgroundTint\"/&gt;&lt;attr name=\"backgroundTintMode\"/&gt;&lt;attr format=\"color\" name=\"rippleColor\"/&gt;&lt;attr name=\"fabSize\"&gt; &lt;enum name=\"normal\" value=\"0\"/&gt; &lt;enum name=\"mini\" value=\"1\"/&gt;&lt;/attr&gt;&lt;attr name=\"elevation\"/&gt;&lt;attr format=\"dimension\" name=\"pressedTranslationZ\"/&gt;&lt;attr format=\"dimension\" name=\"borderWidth\"/&gt;&lt;attr format=\"boolean\" name=\"useCompatPadding\"/&gt;&lt;/declare-styleable&gt; 属性的默认值定义如下： 1234567891011&lt;style name=\"Widget.Design.FloatingActionButton\" parent=\"android:Widget\"&gt; &lt;item name=\"android:background\"&gt;@drawable/design_fab_background&lt;/item&gt; &lt;item name=\"backgroundTint\"&gt;?attr/colorAccent&lt;/item&gt; &lt;item name=\"fabSize\"&gt;normal&lt;/item&gt; &lt;item name=\"elevation\"&gt;@dimen/design_fab_elevation&lt;/item&gt; &lt;item name=\"pressedTranslationZ\"&gt;@dimen/design_fab_translation_z_pressed&lt;/item&gt; &lt;item name=\"rippleColor\"&gt;?attr/colorControlHighlight&lt;/item&gt; &lt;item name=\"borderWidth\"&gt;@dimen/design_fab_border_width&lt;/item&gt; &lt;/style&gt; 需要注意的是android:background属性，这里指定了background为design_fab_background,并且不允许改变: 1234@Override public void setBackgroundDrawable(Drawable background) &#123; Log.i(LOG_TAG, \"Setting a custom background is not supported.\"); &#125; 那么我们来看下这个background长啥样： 1234&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"oval\"&gt; &lt;solid android:color=\"@android:color/white\" /&gt;&lt;/shape&gt; 很显然，fab的形状固定为圆形都是因为这个background。那么这里指定了背景色为白色，那是不是fab只能是白色背景呢？当然不是，还有我们牛逼的backgroundTint(即背景着色)，tint是android 5.x引进的一个新特性，可以动态地给drawable资源着色，其原理就是通过给控件设置colorFilter: drawable.java 123public void setColorFilter(@ColorInt int color, @NonNull PorterDuff.Mode mode) &#123; setColorFilter(new PorterDuffColorFilter(color, mode)); &#125; 默认的着色模式为SRC_IN(取交集、显示上层，故底层白色会被忽略)： 1static final PorterDuff.Mode DEFAULT_TINT_MODE = PorterDuff.Mode.SRC_IN; 在fab构造的时候，会指定着色为？attr/colorAccent，即当前主题的colorAccent属性值。然后执行如下代码，进行着色。 12getImpl().setBackgroundDrawable(mBackgroundTint, mBackgroundTintMode, mRippleColor, mBorderWidth); 因为不同版本间的实现略有不同，所以这里会根据不同版本创建不同的FloatingActionButtonImpl实现类： 12345678910private FloatingActionButtonImpl createImpl() &#123; final int sdk = Build.VERSION.SDK_INT; if (sdk &gt;= 21) &#123; return new FloatingActionButtonLollipop(this, new ShadowDelegateImpl()); &#125; else if (sdk &gt;= 14) &#123; return new FloatingActionButtonIcs(this, new ShadowDelegateImpl()); &#125; else &#123; return new FloatingActionButtonEclairMr1(this, new ShadowDelegateImpl()); &#125; &#125; 以5.x为例，其setBackgroundDrawable实现代码如下: 先创建着色的背景drawable。 123456GradientDrawable createShapeDrawable() &#123; GradientDrawable d = new GradientDrawable(); d.setShape(GradientDrawable.OVAL); d.setColor(Color.WHITE); return d; &#125; 再对此drawable设置tint： 1234567891011121314151617181920212223242526272829@Override void setBackgroundDrawable(ColorStateList backgroundTint, PorterDuff.Mode backgroundTintMode, int rippleColor, int borderWidth) &#123; // Now we need to tint the shape background with the tint mShapeDrawable = DrawableCompat.wrap(createShapeDrawable()); //着色，这里会其实就是设置了下colorFilter DrawableCompat.setTintList(mShapeDrawable, backgroundTint); if (backgroundTintMode != null) &#123; DrawableCompat.setTintMode(mShapeDrawable, backgroundTintMode); &#125; final Drawable rippleContent; if (borderWidth &gt; 0) &#123; mBorderDrawable = createBorderDrawable(borderWidth, backgroundTint); rippleContent = new LayerDrawable(new Drawable[]&#123;mBorderDrawable, mShapeDrawable&#125;); &#125; else &#123; mBorderDrawable = null; rippleContent = mShapeDrawable; &#125; mRippleDrawable = new RippleDrawable(ColorStateList.valueOf(rippleColor), rippleContent, null); mContentBackground = mRippleDrawable; mShadowViewDelegate.setBackgroundDrawable(mRippleDrawable); &#125; 经过着色，fab就呈现出我们想要的颜色啦。 2. fab的大小再来看fab的大小，fab有两种大小，一种是NORMAL，一种是MINI，实际大小分别是56dp和40dp，其定义可以在design库的values.xml中看到。 fab如何控制控件大小只有这两种规格呢(这样说不准确，事实上你可以通过设置fab的layout_width/layout_height指定为任意大小，但是我们最好按照MD规范来)?必然是通过复写onMeasure啦: 12345678910111213141516@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //我们希望的大小 final int preferredSize = getSizeDimension(); //最终测量的大小 final int w = resolveAdjustedSize(preferredSize, widthMeasureSpec); final int h = resolveAdjustedSize(preferredSize, heightMeasureSpec); //取小值，保证最后绘制的是圆形 final int d = Math.min(w, h); // We add the shadow's padding to the measured dimension setMeasuredDimension( d + mShadowPadding.left + mShadowPadding.right, d + mShadowPadding.top + mShadowPadding.bottom); &#125; 其中getSizeDimension方法计算出来的是我们期望的大小: 12345678910final int getSizeDimension() &#123; switch (mSize) &#123; case SIZE_MINI: return getResources().getDimensionPixelSize(R.dimen.design_fab_size_mini);//40dp case SIZE_NORMAL: default: return getResources().getDimensionPixelSize(R.dimen.design_fab_size_normal);//56dp &#125; &#125; 但是最终的值还是得看我们设置的LayoutParams。关于控件测量相关内容不在此文介绍范围内，大家可以自行google。 3.fab的动画fab还支持fab以动画的方式显现/隐藏，通常和AppBarLayout一起使用，可以通过hide()/show()两个方法控制。 那么动画是如何实现的呢: 1234567private void show(OnVisibilityChangedListener listener, boolean fromUser) &#123; getImpl().show(wrapOnVisibilityChangedListener(listener), fromUser); &#125;private void hide(@Nullable OnVisibilityChangedListener listener, boolean fromUser) &#123; getImpl().hide(wrapOnVisibilityChangedListener(listener), fromUser);&#125; 这里因为要兼容不同版本，所以具体实现也交给了不同的fab实现类。3.x之后很好办，直接使用属性动画，如果是3.x之前的话，那么只能使用传统的Animation了 以hide()为例，使用属性动画较为简单，直接使用View#animate()即可链式调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Override void hide(@Nullable final InternalVisibilityChangedListener listener, final boolean fromUser) &#123; if (mIsHiding || mView.getVisibility() != View.VISIBLE) &#123; // A hide animation is in progress, or we're already hidden. Skip the call if (listener != null) &#123; listener.onHidden(); &#125; return; &#125; if (!ViewCompat.isLaidOut(mView) || mView.isInEditMode()) &#123; // If the view isn't laid out, or we're in the editor, don't run the animation mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; else &#123; mView.animate().cancel(); mView.animate() .scaleX(0f) .scaleY(0f) .alpha(0f) .setDuration(SHOW_HIDE_ANIM_DURATION) .setInterpolator(AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR) .setListener(new AnimatorListenerAdapter() &#123; private boolean mCancelled; @Override public void onAnimationStart(Animator animation) &#123; mIsHiding = true; mCancelled = false; mView.internalSetVisibility(View.VISIBLE, fromUser); &#125; @Override public void onAnimationCancel(Animator animation) &#123; mIsHiding = false; mCancelled = true; &#125; @Override public void onAnimationEnd(Animator animation) &#123; mIsHiding = false; if (!mCancelled) &#123; mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; &#125; &#125;); &#125; &#125; 如果使用传统动画的话，则先在xml中定义好动画，然后构造Animation实例，启动动画。 12345678910111213141516171819202122232425262728293031@Override void hide(@Nullable final InternalVisibilityChangedListener listener, final boolean fromUser) &#123; if (mIsHiding || mView.getVisibility() != View.VISIBLE) &#123; // A hide animation is in progress, or we're already hidden. Skip the call if (listener != null) &#123; listener.onHidden(); &#125; return; &#125; Animation anim = android.view.animation.AnimationUtils.loadAnimation( mView.getContext(), R.anim.design_fab_out); anim.setInterpolator(AnimationUtils.FAST_OUT_LINEAR_IN_INTERPOLATOR); anim.setDuration(SHOW_HIDE_ANIM_DURATION); anim.setAnimationListener(new AnimationUtils.AnimationListenerAdapter() &#123; @Override public void onAnimationStart(Animation animation) &#123; mIsHiding = true; &#125; @Override public void onAnimationEnd(Animation animation) &#123; mIsHiding = false; mView.internalSetVisibility(View.GONE, fromUser); if (listener != null) &#123; listener.onHidden(); &#125; &#125; &#125;); mView.startAnimation(anim); &#125; 4. fab与CoordinatorLayout的交互 这块内容因为与CoordinatorLayout/CoordinatorLayout#Behavior有很大关联，如果不熟悉，请先google相关资料。本文假设读者对这块内容已经有一定理解。 fab并不直接与CoordinatorLayout联系，而是通过CoordinatorLayout#Behavior作为桥梁。CoordinatorLayout类通过CoordinatorLayout#Behavior可以间接控制其直系子View的行为，能控制什么行为？View测量、布局、touch事件拦截、监听、NestedScroll等等。是不是很屌。 fab内部实现了CoordinatorLayout#Behavior抽象类。该抽象类有如下接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static abstract class Behavior&lt;V extends View&gt; &#123; ... public boolean onInterceptTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) &#123; return false; &#125; public boolean onTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) &#123; return false; &#125; ... /** * Determine whether the supplied child view has another specific sibling view as a * layout dependency. * * &lt;p&gt;This method will be called at least once in response to a layout request. If it * returns true for a given child and dependency view pair, the parent CoordinatorLayout * will:&lt;/p&gt; * &lt;ol&gt; * &lt;li&gt;Always lay out this child after the dependent child is laid out, regardless * of child order.&lt;/li&gt; * &lt;li&gt;Call &#123;@link #onDependentViewChanged&#125; when the dependency view's layout or * position changes.&lt;/li&gt; * &lt;/ol&gt; */ public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; /** * Respond to a change in a child's dependent view * * &lt;p&gt;This method is called whenever a dependent view changes in size or position outside * of the standard layout flow. A Behavior may use this method to appropriately update * the child view in response.&lt;/p&gt; * * &lt;p&gt;A view's dependency is determined by * &#123;@link #layoutDependsOn(CoordinatorLayout, android.view.View, android.view.View)&#125; or * if &#123;@code child&#125; has set another view as it's anchor.&lt;/p&gt; * * &lt;p&gt;Note that if a Behavior changes the layout of a child via this method, it should * also be able to reconstruct the correct position in * &#123;@link #onLayoutChild(CoordinatorLayout, android.view.View, int) onLayoutChild&#125;. * &lt;code&gt;onDependentViewChanged&lt;/code&gt; will not be called during normal layout since * the layout of each child view will always happen in dependency order.&lt;/p&gt; * * &lt;p&gt;If the Behavior changes the child view's size or position, it should return true. * The default implementation returns false.&lt;/p&gt; * */ public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123; return false; &#125; ... /** * Called when the parent CoordinatorLayout is about the lay out the given child view. * * &lt;p&gt;This method can be used to perform custom or modified layout of a child view * in place of the default child layout behavior. The Behavior's implementation can * delegate to the standard CoordinatorLayout measurement behavior by calling * &#123;@link CoordinatorLayout#onLayoutChild(android.view.View, int) * parent.onLayoutChild&#125;.&lt;/p&gt; * * &lt;p&gt;If a Behavior implements * &#123;@link #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View)&#125; * to change the position of a view in response to a dependent view changing, it * should also implement &lt;code&gt;onLayoutChild&lt;/code&gt; in such a way that respects those * dependent views. &lt;code&gt;onLayoutChild&lt;/code&gt; will always be called for a dependent view * &lt;em&gt;after&lt;/em&gt; its dependency has been laid out.&lt;/p&gt; * */ public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection) &#123; return false; &#125; ... public void onNestedScroll(CoordinatorLayout coordinatorLayout, V child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; // Do nothing &#125; &#125; 看到这个抽象类，有两点需要注意: 此抽象类并无抽象方法，也即子类可选择任何想复写的方法进行复写。 此抽象类接受一个泛型。该泛型需要是View的子类。 fab实现此抽象类: 1public static class Behavior extends CoordinatorLayout.Behavior&lt;FloatingActionButton&gt; &#123;&#125; 有选择性地实现了三个方法: 12345678public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency);public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency); public boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection); fab为啥要实现Behavior?主要是为了配合其他控件完成一些复杂的交互，比较经典的像这个: fab动画效果 fab需要在snackBar弹出的时候自动向上平移，这就得知道SnackBar的状态了，实现Behavior让fab有机会监听到其他CoordinatorLayout子View的状态，并根据状态更新自己。 复写layoutDependsOn方法可以告诉CoordinatorLayout我对哪个View感兴趣， 这里当然是SnackBar了。（注意哦，SnackBar最终展现的是SnackbarLayout，SnackBar本身并不是View） 12345678private static final boolean SNACKBAR_BEHAVIOR_ENABLED = Build.VERSION.SDK_INT &gt;= 11; @Override public boolean layoutDependsOn(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; // We're dependent on all SnackbarLayouts (if enabled) return SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency instanceof Snackbar.SnackbarLayout; &#125; 为什么API LEVEL要大于11呢？因为google偷懒想直接使用属性动画。 前面告诉了CoordinatorLayoutfab对SnackBar比较感兴趣,那么当SnackBar状态改变的时候，CoordinatorLayout就会通过onDependentViewChanged回调通知fab: fab就可以更新自己的UI拉（这里当然是平移喽）: 123456789101112@Override public boolean onDependentViewChanged(CoordinatorLayout parent, FloatingActionButton child, View dependency) &#123; if (dependency instanceof Snackbar.SnackbarLayout) &#123; updateFabTranslationForSnackbar(parent, child, dependency); &#125; else if (dependency instanceof AppBarLayout) &#123; // If we're depending on an AppBarLayout we will show/hide it automatically // if the FAB is anchored to the AppBarLayout updateFabVisibility(parent, (AppBarLayout) dependency, child); &#125; return false; &#125; 如果是SnackBar状态变化了，那么fab就会根据情况进行平移： 1234567891011121314151617181920212223242526272829303132333435363738394041private void updateFabTranslationForSnackbar(CoordinatorLayout parent, final FloatingActionButton fab, View snackbar) &#123; final float targetTransY = getFabTranslationYForSnackbar(parent, fab); if (mFabTranslationY == targetTransY) &#123; // We're already at (or currently animating to) the target value, return... return; &#125; final float currentTransY = ViewCompat.getTranslationY(fab); // Make sure that any current animation is cancelled if (mFabTranslationYAnimator != null &amp;&amp; mFabTranslationYAnimator.isRunning()) &#123; mFabTranslationYAnimator.cancel(); &#125; if (fab.isShown() &amp;&amp; Math.abs(currentTransY - targetTransY) &gt; (fab.getHeight() * 0.667f)) &#123; // If the FAB will be travelling by more than 2/3 of it's height, let's animate // it instead if (mFabTranslationYAnimator == null) &#123; mFabTranslationYAnimator = ViewUtils.createAnimator(); mFabTranslationYAnimator.setInterpolator( AnimationUtils.FAST_OUT_SLOW_IN_INTERPOLATOR); mFabTranslationYAnimator.setUpdateListener( new ValueAnimatorCompat.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimatorCompat animator) &#123; ViewCompat.setTranslationY(fab, animator.getAnimatedFloatValue()); &#125; &#125;); &#125; mFabTranslationYAnimator.setFloatValues(currentTransY, targetTransY); mFabTranslationYAnimator.start(); &#125; else &#123; // Now update the translation Y ViewCompat.setTranslationY(fab, targetTransY); &#125; mFabTranslationY = targetTransY; &#125; 代码里的注释很多，我就不解释了。 前面说到AppBarLayout和fab一起使用可以完成另一个效果，即AppBarLayout伸缩时，fab也可以以动画的形式显现、隐藏，其实现如下： 123456789101112131415161718192021222324252627282930313233private boolean updateFabVisibility(CoordinatorLayout parent, AppBarLayout appBarLayout, FloatingActionButton child) &#123; final CoordinatorLayout.LayoutParams lp = (CoordinatorLayout.LayoutParams) child.getLayoutParams(); //注意到我们必须为fab指定layout_anchor为appBarLayout if (lp.getAnchorId() != appBarLayout.getId()) &#123; // The anchor ID doesn't match the dependency, so we won't automatically // show/hide the FAB return false; &#125; if (child.getUserSetVisibility() != VISIBLE) &#123; // The view isn't set to be visible so skip changing it's visibility return false; &#125; if (mTmpRect == null) &#123; mTmpRect = new Rect(); &#125; // First, let's get the visible rect of the dependency final Rect rect = mTmpRect; ViewGroupUtils.getDescendantRect(parent, appBarLayout, rect); if (rect.bottom &lt;= appBarLayout.getMinimumHeightForVisibleOverlappingContent()) &#123; // If the anchor's bottom is below the seam, we'll animate our FAB out child.hide(null, false); &#125; else &#123; // Else, we'll animate our FAB back in child.show(null, false); &#125; return true; &#125; 除此之外，fab#Behavior还实现了onLayoutChild,主要是为了根据AppBarLayout的当前状态来判断自己是否需要隐藏。 123456789101112131415161718@Override public boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection) &#123; // First, lets make sure that the visibility of the FAB is consistent final List&lt;View&gt; dependencies = parent.getDependencies(child); for (int i = 0, count = dependencies.size(); i &lt; count; i++) &#123; final View dependency = dependencies.get(i); if (dependency instanceof AppBarLayout &amp;&amp; updateFabVisibility(parent, (AppBarLayout) dependency, child)) &#123; break; &#125; &#125; // Now let the CoordinatorLayout lay out the FAB parent.onLayoutChild(child, layoutDirection); // Now offset it if needed offsetIfNeeded(parent, child); return true; &#125; 此方法会在CoordinatorLayout对孩子布局的时候进行调用(即CoordinatorLayout#onLayout)，CoordinatorLayout会检查所有的直系孩子，是否设置了Behavior，如果设置了，那么就执行其onLayoutChild方法: CoordinatorLayout#onLayout 1234567891011121314@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; final int layoutDirection = ViewCompat.getLayoutDirection(this); final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior behavior = lp.getBehavior(); if (behavior == null || !behavior.onLayoutChild(this, child, layoutDirection)) &#123; onLayoutChild(child, layoutDirection); &#125; &#125; &#125; 如果该Behavior实现了OnLayoutChild，并且返回了true，那么将不会执行CoordinatorLayout #onLayoutChild,否则执行默认的布局方案。最后一点，这里的Behavior如何生效的呢？通过注解： 12@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)public class FloatingActionButton extends VisibilityAwareImageButton &#123; CoordinatorLayout在解析孩子的LayoutParams时，会check有无注解： 123456789101112131415161718192021LayoutParams getResolvedLayoutParams(View child) &#123; final LayoutParams result = (LayoutParams) child.getLayoutParams(); if (!result.mBehaviorResolved) &#123; Class&lt;?&gt; childClass = child.getClass(); DefaultBehavior defaultBehavior = null; while (childClass != null &amp;&amp; (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == null) &#123; childClass = childClass.getSuperclass(); &#125; if (defaultBehavior != null) &#123; try &#123; result.setBehavior(defaultBehavior.value().newInstance()); &#125; catch (Exception e) &#123; Log.e(TAG, \"Default behavior class \" + defaultBehavior.value().getName() + \" could not be instantiated. Did you forget a default constructor?\", e); &#125; &#125; result.mBehaviorResolved = true; &#125; return result; &#125; 至此fab解析完毕，谢谢观看！ 如有疑惑，可以issue。 微博：楚奕RX License123456789101112131415161718192021The MIT License (MIT)Copyright (c) 2016 RowandjjPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"CoordinatorLayout源码分析","date":"2017-07-26T11:53:52.000Z","path":"2017/07/26/CoordinatorLayout源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CoordinatorLayout 源码分析CoordinatorLayout有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今天咱就来一探究竟！ 1. 从LayoutParam开始 CoordinatorLayout.LayoutParam中有一些不太一样的属性和元素，在此先进行介绍。 1.1 特殊属性 属性 对应xml属性 用途 AndchorId layout_anchor &amp;layout_anchorGravity 布局时根据自身gravity 与 layout_anchorGravity放置在被anchor的View中 Behavior layout_behavior 辅助Coordinator对View进行layout、nestedScroll的处理 KeyLine layout_keyline &amp; keylines 给Coordinator设置了keylines（整数数组）后，可以为子View设置layout_keyline=&quot;i&quot;使其的水平位置根据对应keylines[i]进行layout。 LastChildRect 无 记录每一次Layout的位置，从而判断是否新的一帧改变了位置 注： keyline是一个非常奇怪的属性，我在看源码时才第一次看到到这玩意，网上的资料也非常之少。分析下来，就是如果设置了keyline，那么gravity就会被无视，直接放置在对应的水平位置keyline上。CoordinatorLayout里面也没有其他的特性是根据keyline实现的，个人认为没卵用，本文对它的分析基本都会略过。 1.2 依赖关系假设此时有两个View: A 和B，那么有两种情况会导致依赖关系： A的anchor是B ； A的behavior对B有依赖（比如FloatingActionButton依赖SnackBar)。 依赖关系建立的前提是两个View在同一个Coordinatorlayout中。 CoordinatorLayout中维护了一个mDependencySortedChildren列表，里面含有所有的子View，按依赖关系排序，被依赖者排在前面。我们可以看一下用来排序的Comparator： 12345678910111213141516final Comparator&lt;View&gt; mLayoutDependencyComparator = new Comparator&lt;View&gt;() &#123; @Override public int compare(View lhs, View rhs) &#123; if (lhs == rhs) &#123; return 0; &#125; else if (((LayoutParams) lhs.getLayoutParams()).dependsOn( CoordinatorLayout.this, lhs, rhs)) &#123; return 1; &#125; else if (((LayoutParams) rhs.getLayoutParams()).dependsOn( CoordinatorLayout.this, rhs, lhs)) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;; 注意，在建立mDependencySortedChildren并排序完成之后（在measure的第一步处理完成），每次对子View的遍历都是通过它进行顺序遍历，保证了被依赖的View最先被处理。 1.3 Behavior在CoordinatorLayout中定义了Behavior类，它是用来辅助layout的工具。如果一个CoordinatorLayout的直接子View设置了Behavior（或者通过类注解@DefaultBehavior指定Behavior），则该Behavior会储存在该View的LayoutParam中。 注意：不是CoordinatorLayout的直接子View，设置Behavior是无效的。你可以看到任何一处对于Behavior的处理都是直接getChildCount（）遍历。 在Behavior中有几类功能，我们一一进行介绍： 1.3.1 触摸响应类Behavior中有两个函数：onInterceptTouchEvent、 onTouchEvent。在CoordinatorLayout每次触发对应事件的时候会选择一个最适合的子View的Behavior执行对应函数。我们来看一下CoordinatorLayout是怎么分发和处理Touch事件的： intercept12345678910111213141516171819202122232425@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); // 重置响应的Behavoir if (action == MotionEvent.ACTION_DOWN) &#123; resetTouchBehaviors(); &#125; // 在这里选择一个最佳Behavior进行处理 final boolean intercepted = performIntercept(ev, TYPE_ON_INTERCEPT); if (cancelEvent != null) &#123; cancelEvent.recycle(); &#125; // 重置响应的Behavior if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123; resetTouchBehaviors(); &#125; return intercepted;&#125; 在performIntercept去选择一个最适合的Behavior来进行处理，这个方法不仅用于onInterceptTouchEvent，并且也用于onTouchEvent，根据传入type不同来识别对应方法。我们来看看它的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243private boolean performIntercept(MotionEvent ev, final int type) &#123; boolean intercepted = false; boolean newBlock = false; MotionEvent cancelEvent = null; final int action = MotionEventCompat.getActionMasked(ev); final List&lt;View&gt; topmostChildList = mTempList1; // API&gt;=21时，使用elevation由低到高排列View；API&lt;21时，按View添加顺序排列 getTopSortedChildren(topmostChildList); final int childCount = topmostChildList.size(); for (int i = 0; i &lt; childCount; i) &#123; final View child = topmostChildList.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Behavior b = lp.getBehavior(); // ...(省略代码) 如果此次判定intercept，则对上次的Behavior发送CANCEL事件。 // 根据传入type不同调用不同的方法 if (!intercepted &amp;&amp; b != null) &#123; switch (type) &#123; case TYPE_ON_INTERCEPT: intercepted = b.onInterceptTouchEvent(this, child, ev); break; case TYPE_ON_TOUCH: intercepted = b.onTouchEvent(this, child, ev); break; &#125; if (intercepted) &#123; mBehaviorTouchView = child; &#125; &#125; //...(省略代码) 如果Behavior.blocksInteractionBelow()返回true，则不处理后续的事件。 &#125; topmostChildList.clear(); return intercepted;&#125; 1.3.2 依赖关系类 这部分比较简单，就俩函数： layoutDependsOn：返回true则表示对另一个View有依赖关系； onDependentViewChanged&amp;onDependentViewRemoved：如果被依赖的View在正常layout之后仍有size/position上的变化，或者被remove掉，都会触发对应方法。 那么问题来了，CoordinatorLayout是怎么监听这个被依赖的View改变的事件的呢？ 原来它里面有一个ViewTreeObserver.OnPreDrawListener，它在onMeasure的时候被添加到了ViewTreeObserver中，这样每一帧被绘制出来之前都会调用这个回调。 1234567class OnPreDrawListener implements ViewTreeObserver.OnPreDrawListener &#123; @Override public boolean onPreDraw() &#123; dispatchOnDependentViewChanged(false); return true; &#125;&#125; 这个dispatchOnDependentViewChanged里面代码比较多，就不放上来了，总结下来就是这样： 根据依赖关系遍历子View，对每一个View做如下操作 判断一下新的布局边界与lastChildRect是否相同，是则记录新的布局边界为lastChildRect，并继续后续流程，否则跳过； 对于之后每一个View，如果它依赖于本View，则调用它的Behavior.onDependentViewChanged（如果有Behavior的话）。 至于onDependentViewRemoved，是在初始化的时候就会调用ViewGroup.setOnHierarchyChangeListener()方法设置一个OnHierarchyChangeListener，这样每次add和remove子View的时候就会接收到回调，同时对相应依赖关系的View进行处理。 1.3.3 布局类onMeasureChild&amp;onLayoutChild：如果重写了该方法并返回true，则CoordinatorLayout会使用Behavior对这个子View进行measure/layout。具体的可以见下面的Measure&amp;Layout 1.3.4 嵌套滑动类CoordinatorLayout实现了NestedScrollingParent，当CoordinatorLayout内有一个支持NestedScroll的子View时，它的嵌套滑动事件通过NestedScrollingParent的回调分发到各直接子View的Behavior处理。虽然Behavior类没有实现NestedScrollingParent，但是实际上它的方法都有。有兴趣的同学可以去看看这个类，我们这里重点讲CoordinatorLayout的分发过程。 各个事件的分发过程类似，此处就举一个例子： 1234567891011121314151617181920public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) &#123; boolean handled = false; final int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i) &#123; final View view = getChildAt(i); final LayoutParams lp = (LayoutParams) view.getLayoutParams(); final Behavior viewBehavior = lp.getBehavior(); if (viewBehavior != null) &#123; final boolean accepted = viewBehavior.onStartNestedScroll(this, view, child, target, nestedScrollAxes); handled |= accepted; lp.acceptNestedScroll(accepted); &#125; else &#123; lp.acceptNestedScroll(false); &#125; &#125; return handled;&#125; 非常简单吧，就遍历一下直接子View，每个都调一下对应的回调方法，只要有任何一个子View的behavior消耗了这个事件，就算消耗了这个事件。 ##2. Measure&amp;Layout 我们知道，ViewGroup要把子View准确地放置到屏幕上都是要走onMeasure onLayout的，那么我们看看CoordinatorLayout在这里干了什么。 在看懂时请确保你明白measure/layout的意义以及基本用法，否则可能会导致身体不适=。= 2.1 Measure最直接的就是看代码，如果不喜欢，可以跳过代码看总结。： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; prepareChildren(); /* 解析依赖关系，并用1.2中提到的Comparator对View按依赖关系进行排序 */ ensurePreDrawListener(); /* 若PreDrawListener未添加，则添加到ViewTreeObserver */ //...(省略代码) 解析paddingmeasureSpec final int childCount = mDependencySortedChildren.size(); for (int i = 0; i &lt; childCount; i) &#123; final View child = mDependencySortedChildren.get(i); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //...(省略代码)处理keyline int childWidthMeasureSpec = widthMeasureSpec; int childHeightMeasureSpec = heightMeasureSpec; //...(省略代码) 处理由于fitSystemWindows带来的padding /* 如果childView有Behavior并且它的onMeasureChild返回true，则由behavior来对childView进行measure，否则就自己measure. */ final Behavior b = lp.getBehavior(); if (b == null || !b.onMeasureChild(this, child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0)) &#123; onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed, childHeightMeasureSpec, 0); &#125; /* 取最大的child width/height 加上margin 作为已经消耗的尺寸。 */ widthUsed = Math.max(widthUsed, widthPadding child.getMeasuredWidth() lp.leftMargin lp.rightMargin); heightUsed = Math.max(heightUsed, heightPadding child.getMeasuredHeight() lp.topMargin lp.bottomMargin); childState = ViewCompat.combineMeasuredStates(childState, ViewCompat.getMeasuredState(child)); &#125; /* 设置自身的measure尺寸 */ final int width = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec, childState &amp; ViewCompat.MEASURED_STATE_MASK); final int height = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec, childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT); setMeasuredDimension(width, height);&#125; 总结下来，onMeasure干了这么几件事： 根据依赖关系对所有子View进行排序 保证OnPreDrawListener被添加 按依赖关系遍历子View: 如果子View有Behavior，并且它的onMeasureChild返回true，则使用Behavior进行measure；否则直接使用measureSpec对子View进行measure； 取子VIew最大的measure尺寸为已使用的measure尺寸。 更新本身的Measure尺寸。 2.2 Layout 在onLayout中，我们可以看到CoordinatorLayout会对每一个子View依照以下判断顺序进行layout： 如果子View设置了Behavior，并且该Behavior的behavior.onLayoutChild返回true，则使用behavior.onLayoutChild对该子View进行layout； 如果Behavior不进行layout，则进入自身的onLayoutChild()，内部依次进行如下判断： 如果子View设置了Anchor，则调用layoutChildWithAnchor（根据anchor进行layout）； 如果子View含有keyline，则调用layoutChildWithKeyline（根据keyline进行layout）； 如果以上判断都不符合，则直接将View根据padding/margin/measure结果按照Gravity放置。 我们一一来看一下这些过程。 2.2.1 使用Behavior进行layout 默认的Behavior的onLayoutChild都是返回false的，那么我们看看FloatingActionButton的默认Behavior是怎么处理的吧： 1234567891011121314151617181920@Overridepublic boolean onLayoutChild(CoordinatorLayout parent, FloatingActionButton child, int layoutDirection) &#123; // 检查该FAB是否依赖AppBarLayout final List&lt;View&gt; dependencies = parent.getDependencies(child); for (int i = 0, count = dependencies.size(); i &lt; count; i) &#123; final View dependency = dependencies.get(i); if (dependency instanceof AppBarLayout &amp;&amp; updateFabVisibility(parent, (AppBarLayout) dependency, child)) &#123; break; &#125; &#125; // 调用CoordinatorLayout的onLayoutChild对FAB进行layout parent.onLayoutChild(child, layoutDirection); // 在API &lt; 21时，需要手动offset来让出阴影的位置 offsetIfNeeded(parent, child); return true;&#125; 这里主要是处理了如果FAB设置了AppBarLayout为anchor时（此时会对AppBarLayout有依赖），则当AppBarLayout的高度不足以显示FAB时将其隐藏）。 之后它会手动调用CoordinatorLayout自身的onLayoutChild方法进行layout，即上述判断的第二步，那我们继续往下看。 2.2.2 使用Anchor进行layout 如果View设置了anchor，那么都会调用layoutWithAnchor进行layout，代码与解释如下： 12345678910111213private void layoutChildWithAnchor(View child, View anchor, int layoutDirection) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect anchorRect = mTempRect1; final Rect childRect = mTempRect2; /* 1. 找到被anchor的View的布局边界 */ getDescendantRect(anchor, anchorRect); /* 2. 获取到被anchor的View布局边界之后，配合layout_anchorGravity与自身的gravity获取到最终要layout到的边界 */ getDesiredAnchoredChildRect(child, layoutDirection, anchorRect, childRect); child.layout(childRect.left, childRect.top, childRect.right, childRect.bottom);&#125; 这里用到的两个关键函数就是getDescendantRect与getDesiredAnchoredChildRect，它们的目的在我添加的注释中进行了解释，为保证文章的可读性就不再把代码放上来了，有兴趣的同学可以再自己去挖掘相应代码~~ 2.2.3 直接layout如果之前的都不符合，就会走到这一步，我们看看它是怎么layout的： 12345678910111213141516private void layoutChild(View child, int layoutDirection) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect parent = mTempRect1; parent.set(getPaddingLeft() lp.leftMargin, getPaddingTop() lp.topMargin, getWidth() - getPaddingRight() - lp.rightMargin, getHeight() - getPaddingBottom() - lp.bottomMargin); //...(省略代码) 处理由于fitsSystemWindows带来的inset // 按照Gravity与measure尺寸在父控件里面找到自己的位置，并进行layout。 final Rect out = mTempRect2; GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(), child.getMeasuredHeight(), parent, out, layoutDirection); child.layout(out.left, out.top, out.right, out.bottom); &#125; ##3 总结 CoordinatorLayout的特性总结下来就是两个方面： 可以设置anchor，被依赖的View变化自身也会变化； 可以设置behavior，当内部有支持嵌套滑动的控件时处理NestedScroll事件； 这两个特性导致的子View之间的依赖关系让界面的交互更有意思。有兴趣的同学可以再去看AppBarLayout、FloatingActionButton、SnackBar的源码~~ 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"CompoundButton源码分析","date":"2017-07-26T11:52:49.000Z","path":"2017/07/26/CompoundButton源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CompoundButton 是一个有两种状态（选中和未选中 / checkd unchecked）的Button。当你按下（pressed）或者点击（clicked），它的状态会自动改变。 特点 是一个抽象类（abstract），所以我们不能直接使用它，只有自定义实现或者系统已经提供的它的一直子类（ToggleButton，Checkbox，RadioButton 等等） 继承自Button，而Button 继承自TextView，所以Button，TextView 的特性CompoundButton 都是具备的 实现自Checkable 接口（interface），利用它可以设置状态（setChecked(boolean checked)），获取状态（isChecked()）和切换状态（toggle()） 最后的效果图就是这样的。 分析1234567891011121314151617// 选中和未选中的状态private boolean mChecked;private boolean mBroadcasting;private Drawable mButtonDrawable;private ColorStateList mButtonTintList = null;// 就是水波纹和背景颜色混合的方式private PorterDuff.Mode mButtonTintMode = null;private boolean mHasButtonTint = false;private boolean mHasButtonTintMode = false;// 状态监听private OnCheckedChangeListener mOnCheckedChangeListener;private OnCheckedChangeListener mOnCheckedChangeWidgetListener; 这是一些局部变量，在后面的分析会用到。 我们先来看看CompoundButton 自定义控件有哪些属性 \\data\\res\\values\\attrs.xml12345678910111213&lt;declare-styleable name=\"CompoundButton\"&gt; &lt;!-- 设置状态 true: 选中; false: 未选中 --&gt; &lt;attr name=\"checked\" format=\"boolean\" /&gt; &lt;!-- 绘制按钮图形，一般为Drawable 资源 (e.g. checkbox, radio button, etc). --&gt; &lt;attr name=\"button\" format=\"reference\" /&gt; &lt;!-- 对绘制的按钮图形着色 --&gt; &lt;attr name=\"buttonTint\" format=\"color\" /&gt; &lt;!-- 对着色设置模式 --&gt; &lt;attr name=\"buttonTintMode\"&gt; &lt;enum name=\"src_over\" value=\"3\" /&gt; ... &lt;/attr&gt; &lt;/declare-styleable&gt; 然后再来看看怎么绘制，先来看看构造方法1234567891011121314151617181920212223242526272829303132333435public CompoundButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); // 这里的获取自定义的CompoundButton 就是上面的定义的CompoundButton final TypedArray a = context.obtainStyledAttributes( attrs, com.android.internal.R.styleable.CompoundButton, defStyleAttr, defStyleRes); // 用于绘制按钮图形 final Drawable d = a.getDrawable(com.android.internal.R.styleable.CompoundButton_button); if (d != null) &#123; setButtonDrawable(d); &#125; // 对绘制的按钮图形着色设置模式 if (a.hasValue(R.styleable.CompoundButton_buttonTintMode)) &#123; mButtonTintMode = Drawable.parseTintMode(a.getInt( R.styleable.CompoundButton_buttonTintMode, -1), mButtonTintMode); mHasButtonTintMode = true; &#125; // 对绘制的按钮图形着色 if (a.hasValue(R.styleable.CompoundButton_buttonTint)) &#123; mButtonTintList = a.getColorStateList(R.styleable.CompoundButton_buttonTint); mHasButtonTint = true; &#125; // 设置状态 final boolean checked = a.getBoolean( com.android.internal.R.styleable.CompoundButton_checked, false); setChecked(checked); a.re cycle(); applyButtonTint();&#125; 在构造方法中，获取自定义属性的各个属性， button：用于绘制按钮图形，然后调用setButtonDrawable() 来绘制。 buttonTint：绘制的按钮着色。使用一个boolean 标识符来设置的，然后会在applyButtonTint() 中统一处理。它们两个分别用作给和 buttonTintMode：和设置着色模式。设置方式和buttonTint 几乎一样。不过它的一些属性，参考这篇文章来看看具体不同的着色模式效果是怎么样的。android5.x新特性之Tinting checked：是设置选中状态，在setChecked() 中设置。 绘制按钮图形123456789101112131415161718192021222324@Nullablepublic void setButtonDrawable(@Nullable Drawable drawable) &#123; if (mButtonDrawable != drawable) &#123; if (mButtonDrawable != null) &#123; // 取消对View 的引用 mButtonDrawable.setCallback(null); // 取消绘制对象相关联的调度,当我们重新绘制一个Drawable，可以调用此方法 unscheduleDrawable(mButtonDrawable); &#125; mButtonDrawable = drawable; if (drawable != null) &#123; drawable.setCallback(this); drawable.setLayoutDirection(getLayoutDirection()); if (drawable.isStateful()) &#123; drawable.setState(getDrawableState()); &#125; drawable.setVisible(getVisibility() == VISIBLE, false); setMinHeight(drawable.getIntrinsicHeight()); applyButtonTint(); &#125; &#125;&#125; 这个方法，就是用于绘制按钮图形，首先会判断我们设置的Drawable 和初始会的mButtonDrawable 是否相等，如果不等，将会对初始化的mButtonDrawable 对象，取消对View 的引用（setCallback(null)），并且取消mButtonDrawable 相关联调度（unscheduleDrawable()），然后将我们新设置的Drawable 赋值给mButtonDrawable 对象，然后再设置引用，设置布局的方向，然后判断如果状态改变时，重新设置状态。最后调用applyButtonTint()。 着色12345678910111213141516171819private void applyButtonTint() &#123; if (mButtonDrawable != null &amp;&amp; (mHasButtonTint || mHasButtonTintMode)) &#123; mButtonDrawable = mButtonDrawable.mutate(); if (mHasButtonTint) &#123; mButtonDrawable.setTintList(mButtonTintList); &#125; if (mHasButtonTintMode) &#123; mButtonDrawable.setTintMode(mButtonTintMode); &#125; // The drawable (or one of its children) may not have been // stateful before applying the tint, so let's try again. if (mButtonDrawable.isStateful()) &#123; mButtonDrawable.setState(getDrawableState()); &#125; &#125;&#125; 这个方法主要就是设置mButtonDrawable 的Tint（着色）和TintMode（着色模式），之前在构造方法，setButtonDrawable() 方法中都会调用此方法，因为这两个属性都是基于mButtonDrawable 来设置的，而这个两个属性是根据两个Boolean 属性mHasButtonTint 和mHasButtonTintMode 来识别的，然后为true，就表示设置。而他们两个属性也有setButtonTintList 和setButtonTintMode() 方法来设置两个属性，将两个boolean 属性设置为true，并且调用applyButtonTint() 来设置的。 绘制1234567891011121314151617181920212223242526272829303132333435363738394041424344protected void onDraw(Canvas canvas) &#123; final Drawable buttonDrawable = mButtonDrawable; if (buttonDrawable != null) &#123; final int verticalGravity = getGravity() &amp; Gravity.VERTICAL_GRAVITY_MASK; final int drawableHeight = buttonDrawable.getIntrinsicHeight(); final int drawableWidth = buttonDrawable.getIntrinsicWidth(); final int top; switch (verticalGravity) &#123; case Gravity.BOTTOM: top = getHeight() - drawableHeight; break; case Gravity.CENTER_VERTICAL: top = (getHeight() - drawableHeight) / 2; break; default: top = 0; &#125; final int bottom = top + drawableHeight; final int left = isLayoutRtl() ? getWidth() - drawableWidth : 0; final int right = isLayoutRtl() ? getWidth() : drawableWidth; buttonDrawable.setBounds(left, top, right, bottom); final Drawable background = getBackground(); if (background != null) &#123; background.setHotspotBounds(left, top, right, bottom); &#125; &#125; super.onDraw(canvas); if (buttonDrawable != null) &#123; final int scrollX = mScrollX; final int scrollY = mScrollY; if (scrollX == 0 &amp;&amp; scrollY == 0) &#123; buttonDrawable.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); buttonDrawable.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125; &#125;&#125; 这些属性都初始化好了，那就可以来绘制了，我们都知道自定义重写onDraw() 方法来绘制视图，CompoundButton 也重写了此方法，将我们设置了各种属性的mButtonDrawable 复制给局部变量buttonDrawable，然后根据对其方式（Gravity） 属性来来具体绘制buttonDrawable。然后调用父类的onDraw()，最后在根据时候是滑动通过Canvas 来绘制，如果水平和垂直滑动为0，则直接绘制即可，如果不为零则需要调用translate 对canvas 的重新绘制。 设置选中(checked)状态123456789101112131415161718192021222324252627282930313233public void setChecked(boolean checked) &#123; if (mChecked != checked) &#123; mChecked = checked; refreshDrawableState(); notifyViewAccessibilityStateChangedIfNeeded( AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED); // 避免多次调用setChecked() 来多次调用回调监听 if (mBroadcasting) &#123; return; &#125; mBroadcasting = true; if (mOnCheckedChangeListener != null) &#123; mOnCheckedChangeListener.onCheckedChanged(this, mChecked); &#125; if (mOnCheckedChangeWidgetListener != null) &#123; mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked); &#125; mBroadcasting = false; &#125;&#125;// 设置监状态听public void setOnCheckedChangeListener(OnCheckedChangeListener listener) &#123; mOnCheckedChangeListener = listener;&#125;void setOnCheckedChangeWidgetListener(OnCheckedChangeListener listener) &#123; mOnCheckedChangeWidgetListener = listener;&#125; 设置状态，就是传入一个Boolean 值来设置状态，如果和初始化的mChecked 相反，才会调用，然后调用refreshDrawableState() 来刷新绘制的状态，然后下面就是设置状态改变的监听，通过mBroadcasting 属性来避免多次设置回调，每次调用mBroadcasting，如果为true，则返回。发现有两个监听，我们仔细看下面setXxxListener() 的方法，而下面那个setOnCheckedChangeWidgetListener() 方法不是Public，所以说不是对外开放的，我们是不能调用的，文档中说明是仅供内部使用。因此我们想要监听选中状态，可以使用setOnCheckedChangeListener()。重写onCheckedChanged(CompoundButton buttonView, boolean isChecked) 即可。对了，除了setChecked() 可以设置状态，toggle() 每次也会setChecked() 方法，每次都会讲状态设置为相反的。还有isChecked() 方法，判断当前的选中状态。 状态保存123456789101112131415161718192021222324252627282930313233343536373839404142434445static class SavedState extends BaseSavedState &#123; boolean checked; SavedState(Parcelable superState) &#123; super(superState); &#125; private SavedState(Parcel in) &#123; super(in); checked = (Boolean)in.readValue(null); &#125; @Override public void writeToParcel(Parcel out, int flags) &#123; super.writeToParcel(out, flags); out.writeValue(checked); &#125; public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() &#123; public SavedState createFromParcel(Parcel in) &#123; return new SavedState(in); &#125; public SavedState[] newArray(int size) &#123; return new SavedState[size]; &#125; &#125;;&#125;@Overridepublic Parcelable onSaveInstanceState() &#123; Parcelable superState = super.onSaveInstanceState(); SavedState ss = new SavedState(superState); ss.checked = isChecked(); return ss;&#125;@Overridepublic void onRestoreInstanceState(Parcelable state) &#123; SavedState ss = (SavedState) state; super.onRestoreInstanceState(ss.getSuperState()); setChecked(ss.checked); requestLayout();&#125; 保存状态是自定义一个SavedState，继承自BaseSavedState，然后Parcelable 将Boobean 类型checked 属性序列化，判断是否选中，在onSaveInstanceState() 中，保存，然后在onRestoreInstanceState() 获取序列化的属性，重新调用setChecked() 设置属性。 Checkbox/ToggleButtonCheckbox 和ToggleButton 的实现那都是继承自CompoundButton，可以看下面这两篇文章。 ToggleButton/Checkbox 的源码分析 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"bindService源码分析","date":"2017-07-26T11:46:44.000Z","path":"2017/07/26/bindService源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 bindService 源码分析 【进行中】简介客户端通过 ContextWrapper.bindService() 方法来绑定服务，本地对 bindService 的过程进行源码分析。 整体时序图 源码分析1. 客户端调用 bindService() 绑定服务 1234567891011// MainActivity.java@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent().setComponent(new ComponentName( \"org.xdty.remoteservice\", \"org.xdty.remoteservice.RemoteService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125; Activity.bindService() 最终调用的是 ContextImpl.bindService() 方法 2. ContextImpl.bindService() 1234567891011121314151617181920212223242526272829// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); ... try &#123; IBinder token = getActivityToken(); ... int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); ... return res != 0; &#125; catch (RemoteException e) &#123; ... &#125;&#125; 可见接着调用了 ActivityManagerNative.getDefault().bindService() 方法 这里的 mPackageInfo 是一个 LoadedApk 实例。mMainThread 则是一个 ActivityThread。 3. ActivityManagerNative.getDefault().bindService() 注意 ActivityManagerNative.java 文件中有两个类 ActivityManagerNative ActivityManagerProxy, 他们都实现了 IActivityManager接口，而 ActivityManagerNative 则继承了 Binder 对象，相当于 AIDL 中的 Stub，`ActivityManagerProxy 则相当于 Proxy。 首先看 ActivityManagerNative.getDefault() 123static public IActivityManager getDefault() &#123; return gDefault.get();&#125; 再找 gDefault 1234567private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); IActivityManager am = asInterface(b); return am; &#125;&#125;; 再来看 asInterface() 方法 123456789101112static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; 很容易发现其返回了一个 ActivityManagerProxy 对象，所以调用的 bindService() 方法实现在 ActivityManagerProxy 类中。注意这里不要和抽象类 ActivityManagerNative.class 继承的 bindService() 方法混淆，它的实现在子类 ActivityManagerService 中。接下来我们继续看 Proxy 中的实现： 123456789101112131415161718192021222324// ActivityManagerNative.java// ActivityManagerProxy.classpublic int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeStrongBinder(token); service.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(connection.asBinder()); data.writeInt(flags); data.writeString(callingPackage); data.writeInt(userId); mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); reply.readException(); int res = reply.readInt(); data.recycle(); reply.recycle(); return res;&#125; 可见这里将要绑定的服务信息打包，通过一个 binder 对象，发送了 BIND_SERVICE_TRANSACTION 命令给 ActivityManager 的服务端。而 ActivityManager 的服务端就是 ActivityManagerNative，所以接着命令会被 ActivityManagerNative.onTransact() 处理 4. ActivityManagerNative.onTransact() ActivityManagerNative 对 BIND_SERVICE_TRANSACTION 命令重新解包并通过子类实现的 ActivityManagerNative.bindService() 处理，注意这里的 bindService() 和上文的 ActivityManagerProxy.bindService() 不同。 1234567891011121314151617181920212223242526 public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; ... case BIND_SERVICE_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); IBinder token = data.readStrongBinder(); Intent service = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); b = data.readStrongBinder(); int fl = data.readInt(); String callingPackage = data.readString(); int userId = data.readInt(); IServiceConnection conn = IServiceConnection.Stub.asInterface(b); int res = bindService(app, token, service, resolvedType, conn, fl, callingPackage, userId); reply.writeNoException(); reply.writeInt(res); return true; &#125; ...&#125; 5. ActivityManagerService.bindService() 我们继续看 ActivityManagerNative 的子类 ActivityManagerService 对 bindService() 方法的实现： 123456789public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; ... synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId); &#125;&#125; 可见通过 mServices.bindServiceLocked() 方法又传递给了下一层，这里的 mServices 则是一个 ActiveServices 实例。我们继续追踪 ActiveServices.bindServiceLocked() 6. ActiveServices.bindServiceLocked() 接下来看 bindServiceLocked() 关键代码片断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException &#123; // 获取当前应用的进程记录 final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); // 获取当前 Activity 记录 ActivityRecord activity = null; if (token != null) &#123; activity = ActivityRecord.isInStackLocked(token); &#125; ... // 获取 ServiceLookupResult，其中 res.record 就是我们要启动的 service ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg); ServiceRecord s = res.record; mAm.startAssociationLocked(callerApp.uid, callerApp.processName, s.appInfo.uid, s.name, s.processName); AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); // 封装客户端传入的 IServiceConnection，用于绑定后回调 ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent); // 保存 connection 记录到列表中 IBinder binder = connection.asBinder(); ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); s.connections.put(binder, clist); &#125; clist.add(c); b.connections.add(c); if (activity != null) &#123; if (activity.connections == null) &#123; activity.connections = new HashSet&lt;ConnectionRecord&gt;(); &#125; activity.connections.add(c); &#125; b.client.connections.add(c); if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true; &#125; if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; clist = mServiceConnections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;ConnectionRecord&gt;(); mServiceConnections.put(binder, clist); &#125; clist.add(c); // 继续进入 bringUpServiceLocked() 处理 if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); if (bringUpServiceLocked(s, service.getFlags(), callerFg, false) != null) &#123; return 0; &#125; &#125; ...&#125; 7. ActiveServices.bringUpServiceLocked() 继续查看 bringUpServiceLocked() 方法 1234567891011121314151617181920212223private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123; ... final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; final String procName = r.processName; ProcessRecord app; // 获取进程记录 app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); // 启动服务 realStartServiceLocked(r, app, execInFg); return null; &#125; catch (TransactionTooLargeException e) &#123; ... &#125; &#125; ...&#125; 8. ActiveServices.realStartServiceLocked() 继续追踪 ActiveServices.realStartServiceLocked() 123456789101112131415161718private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; ... try &#123; ... // 创建服务，服务端最终会响应 onCreate() 方法。 app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); ... &#125; catch (DeadObjectException e) &#123; ... &#125; // 绑定服务， 服务最终端会响应 onBind() 方法 requestServiceBindingsLocked(r, execInFg); ...&#125; 参考Android应用程序绑定服务（bindService）的过程源代码分析 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"Binder源码分析","date":"2017-07-26T11:44:18.000Z","path":"2017/07/26/Binder源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 本文是基于 Android 6.0.0 和 kernel 3.4 源码 及 Android SDK 23 展开的 1. 简介Binder 是一种 Android 进程间通信机制，提供远程过程调用(Remote Procedure Call)功能。我们最直接的使用是调用 Context.getSystemService() 来获取系统服务，或直接使用 AIDL 来实现多个程序(APP)间数据交互。 Binder 是非常重要的 Android 基础组件，几乎所有的进程间通信都是使用 Binder 机制实现的。本文将结合源码展开讲述 Binder ，同时对一些重要知识点提供扩展阅读的参考。 不管是 Android 系统服务(System services)还是用户的应用进程(User apps)，最终都会通过 binder 来实现进程间通信。上层应用首先通过 IBinder 的 transcate 方法发送命令给 libbinder， libbinder 再通过系统调用(ioctl) 发送命令到内核中的 binder 驱动，之后再由驱动完成进程间数据的交互。 我们经常使用的 Intent，Messager 数据传递也是对 Binder 更高层次的抽象和封装，最终还是会由内核中的 binder 驱动完成数据的传递。 2. Binder 与 AIDLAIDL (Android Interface definition language) 是接口描述语言，用于生成在两个进程间进行通信的代码。先看 AIDL 概念图 Stub.Proxy 和 Stub 代码由 Android Sdk 自动生成，客户端通过 Stub.Proxy 与远程服务交互。 Stub 包含对 IBinder 对象操作的封装，需要远程服务实现具体功能。 接下来再看具体实现， 完整源代码见 AidlExample。在这个工程中，我们新建了两个应用， app 是客户端代码， remoteservice 则是服务端代码。 2.1 AIDL 客户端在 Android Studio 项目上右键， New -&gt; AIDL -&gt; AIDL File 输入文件名后可以快速创建一个 AIDL 的代码结构。例如我们新建一个 IRemoteService.aidl 文件 12345678// IRemoteService.aidlpackage com.android.aidltest;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 从生成的示例代码可以看出，AIDL 的语法类似 Java， basicTypes() 方法传递的参数只是基本类型。 如果要传递自定义类型如 User，则需要实现 Parcelable 接口。Parcelable 是一个与 Java Serializable 类似的序列化接口。 这样类 User 的实例就可以储存到 Parcel 中，而 Parcel 则是一个可以通过 IBinder 发送数据或对象引用的容器。 1234567891011121314151617181920212223242526272829303132// User.javapublic class User implements Parcelable &#123; private int uid; private String name; // 从 Parcel 中读取数据，顺序需要和写入保持一致 protected User(Parcel in) &#123; uid = in.readInt(); name = in.readString(); &#125; // 必须实现，用于从 Parcel 对象中生成类实例 public static final Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel in) &#123; return new User(in); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; // 将数据写入到 Parcel 中， 顺序需要与读取保持一致 @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(uid); dest.writeString(name); &#125;&#125; 再向 IRemoteService.aidl 中添加一个 addUser() 方法，同时新建一个 User.aidl 文件。 1234567891011121314151617// IRemoteService.aidlpackage com.android.aidltest;import com.android.aidltest.User;interface IRemoteService &#123; void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); // in 表示传入数据， out 表示传出数据， inout 表示双向传递。注意含有 out 时 User 类需要实现 readFromParcel() 方法 void addUser(in User user);&#125;// User.aidlpackage com.android.aidltest;parcelable User; 运行编译后，会在 generated 文件夹中生成一个 IRemoteService.java 接口文件。这个接口中有两个内部类 Stub 和 Stub.Proxy。注意客户端生成的IRemoteService.java 文件和在后文服务端生成的文件内容是相同的。 客户端会从 Stub.asInterface() 得到 IRemoteService (Stub.Proxy) 的实例，这个实例就是一个通过 Binder 传递回来的 远程对象 的包装。而服务端则需要实现 IRemoteService.addUser() 方法。 1234567891011// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof org.xdty.remoteservice.IRemoteService))) &#123; return ((org.xdty.remoteservice.IRemoteService) iin); &#125; return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125; 2.2 AIDL 服务端为了演示进程间通信，我们新建一个模块（应用） RemoteService 来实现功能，并在客户端绑定服务。 按客户端的结构新建 IRemoteService.aidl User.aidl User.java 文件，并拷贝内容，注意如果需要请修改包名。 新建服务 RemoteService ，覆盖(Override) onBind() 方法并返回 IRemoteService.Stub 实例 mBinder： 123456789101112131415161718192021// RemoteService.javapublic class RemoteService extends Service &#123; private static final String TAG = RemoteService.class.getSimpleName(); private IBinder mBinder = new IRemoteService.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; Log.d(TAG, \"basicTypes: \"); &#125; @Override public void addUser(User user) throws RemoteException &#123; Log.d(TAG, \"addUser: \" + user.name); &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 这样服务端就实现了 addUser() 方法，当客户端通过远程对象调用 IRemoteService.Stub.Proxy.addUser() 时，远程对象 mRemote 就会通过 transact() 发送命令给服务端，服务端收到命令后在 Stub.onTransact() 中读取数据并执行 addUser() 方法。更多细节我们将在 3. Binder 框架及 Native 层 小节讲述。 123456789101112131415161718192021// IRemoteService.java@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 2.3 远程服务的获取与使用客户端要使用远程服务，需要绑定服务 (bindService) 并建立服务连接 (ServiceConnection)。 123456789101112131415161718192021222324// MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; IRemoteService remoteService = IRemoteService.Stub.asInterface(service); try &#123; remoteService.addUser(new User(1, \"neo\")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; ... &#125;; ... @Override protected void onCreate(Bundle savedInstanceState) &#123; ... Intent intent = new Intent().setComponent(new ComponentName( \"org.xdty.remoteservice\", \"org.xdty.remoteservice.RemoteService\")); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125;&#125; 我们可以看出，客户端通过 binderService() 方法，获取远程服务并在服务连接 ServiceConnection 中 onServiceConnected() 回调中得到了 IBinder service 实例， 最后通过上文提到的 IRemoteService.Stub.asInterface(service) 方法得到远程服务 IRemoteService 的实例。通过 IRemoteService.addUser() 方法我们可以像调用本地方法一样调用远程方法。在来看 IRemoteService.addUser() 的实现： 123456789101112131415161718192021222324252627282930313233343536373839// IRemoteService.javapublic static org.xdty.remoteservice.IRemoteService asInterface(android.os.IBinder obj) &#123; ... return new org.xdty.remoteservice.IRemoteService.Stub.Proxy(obj);&#125;private static class Proxy implements org.xdty.remoteservice.IRemoteService &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; ... @Override public void addUser(org.xdty.remoteservice.User user) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((user != null)) &#123; _data.writeInt(1); user.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addUser, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; 可以看到客户端调用 remoteService.addUser(new User(1, “neo”)) 方法实际上是通过 IBinder service 实例的 transact() 方法，发送了与服务端约定好的命令 Stub.TRANSACTION_addUser，并将参数按格式打包进 Parcel 对象。 服务端则在 onTransact() 方法中收到命令后会对命令和参数重新解析： 1234567891011121314151617181920// IRemoteService.javapublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 可以看到在 onTransact() 中，最终 this.addUser(_arg0) 调用了上文提到的服务端的实现 IRemoteService.Stub.addUser() 。 远程 Binder 对象 mRemote 是由客户端绑定服务时 onServiceConnected() 返回的。继续追踪 bindService() 1234567// ContextImpl.java@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, Process.myUserHandle());&#125; 可以看到最后是通过 ActivityManagerNative.getDefault().bindService() 来绑定服务 12345678910111213141516// bindServiceCommon()int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier());// ActivityManagerNative.getDefault().bindService()public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws RemoteException &#123; ... data.writeStrongBinder(connection.asBinder()); ... mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0); ...&#125; 追踪到 ActivityManagerNative.getDefault().bindService() ，可以发现 ActivityManager 和 IServiceConnection也是一个 AIDL 实现。通过它的 ActivityManagerProxy.bindService() 将绑定请求发送给本地层。 再从 onServiceConnected() 回调追踪， onServiceConnected() 是由 LoadedApk.ServiceDispatcher.doConnected() 回调的。 关于更多的 bindService() 远程服务创建及 ServiceConnection 回调， 请参考 Android应用程序绑定服务（bindService）的过程源代码分析 利用进程间通信，我们可以实现简单的应用插件功能。关于 AIDL 在实际项目中的应用，可以参考 CallerInfo Plugin 的实现 从上面分析可以看出， AIDL 的本质是对 Binder 的又一次抽象和封装，实际的进程间通信仍是由 Binder 完成的。 3. Binder 框架及 Native 层Binder机制使本地对象可以像操作当前对象一样调用远程对象，可以使不同的进程间互相通信。Binder 使用 Client/Server 架构，客户端通过服务端代理，经过 Binder 驱动与服务端交互。 Binder 机制实现进程间通信的奥秘在于 kernel 中的 Binder 驱动，将在 4. Binder 驱动 小节详细讲述。 JNI 的代码位于 frameworks/base/core/jni 目录下，主要是 android_util_Binder.cpp 文件和头文件 android_util_Binder.h Binder JNI 代码是 Binder Java 层操作到 Binder Native 层的接口封装，最后会被编译进 libandroid_runtime.so 系统库。 Binder 本地层的代码在 frameworks/native/libs/binder 目录下， 此目录在 Android 系统编译后会生成 libbinder.so 文件，供 JNI 调用。libbinder 封装了所有对 binder 驱动的操作，是上层应用与驱动交互的桥梁。头文件则在 frameworks/native/include/binder 目录下。 3.1 Binder Native 的入口IInterface.cpp 是 Binder 本地层入口，与 java 层的 android.os.IInterface 对应，提供 asBinder() 的实现，返回 IBinder 对象。 在头文件中有两个类 BnInterface (Binder Native Interface) 和 BpInterface (Binder Proxy Interface), 对应于 java 层的 Stub 和 Proxy 12345sp&lt;IBinder&gt; IInterface::asBinder(const IInterface* iface)&#123; if (iface == NULL) return NULL; return const_cast&lt;IInterface*&gt;(iface)-&gt;onAsBinder();&#125; 12345678910111213141516171819202122template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;;// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; 其中 BnInterface 是实现Stub功能的模板，扩展BBinder的onTransact()方法实现Binder命令的解析和执行。BpInterface 是实现Proxy功能的模板，BpRefBase里有个mRemote对象指向一个BpBinder对象。 3.2 Binder 本地层的整个函数/方法调用过程 1. Java 层 IRemoteService.Stub.Proxy 调用 android.os.IBinder (实现在 android.os.Binder.BinderProxy) 的 transact() 发送 Stub.TRANSACTION_addUser 命令。 2. 由 BinderProxy.transact() 进入 native 层。 3. 由 jni 转到 android_os_BinderProxy_transact() 函数。 4. 调用 IBinder-&gt;transact 函数。 1234567static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject); status_t err = target-&gt;transact(code, *data, reply, flags);&#125; 而 gBinderProxyOffsets.mObject 则是在 java 层调用 IBinder.getContextObject() 时在 javaObjectForIBinder 函数中设置的 123456789101112131415static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125;jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... LOGDEATH(\"objectForBinder %p: created new proxy %p !\\n\", val.get(), object); // The proxy holds a reference to the native object. env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get()); val-&gt;incStrong((void*)javaObjectForIBinder); ...&#125; 经过 ProcessState::getContextObject() 和 ProcessState::getStrongProxyForHandle() 1234567891011121314sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; ... b = new BpBinder(handle); result = b; ... return result;&#125; 可见 android_os_BinderProxy_transact() 函数实际上调用的是 BpBinder::transact() 函数。 5. BpBinder::transact() 则又调用了 IPCThreadState::self()-&gt;transact() 函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; if (err == NO_ERROR) &#123; LOG_ONEWAY(\"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s\", getpid(), getuid(), (flags &amp; TF_ONE_WAY) == 0 ? \"READ REPLY\" : \"ONE WAY\"); err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125;status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; ... mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 由函数内容可以看出， 数据再一次通过 writeTransactionData() 传递给 mOut 进行写入操作。 mOut 是一个 Parcel 对象， 声明在 IPCThreadState.h 文件中。之后则调用 waitForResponse() 函数。 6. IPCThreadState::waitForResponse() 在一个 while 循环里不断的调用 talkWithDriver() 并检查是否有数据返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(NULL, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; &#125; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125; ...&#125; 7. IPCThreadState::talkWithDriver() 函数是真正与 binder 驱动交互的实现。ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 就是使用系统调用函数 ioctl 向 binder 设备文件 /dev/binder 发送 BINDER_WRITE_READ 命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don't want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // Return immediately if there is nothing to do. if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err;#if defined(HAVE_ANDROID_OS) // 使用系统调用 ioctl 向 /dev/binder 发送 BINDER_WRITE_READ 命令 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno;#else err = INVALID_OPERATION;#endif do &#123; if (mProcess-&gt;mDriverFD &lt;= 0) &#123; err = -EBADF; &#125; &#125; while (err == -EINTR); if (err &gt;= NO_ERROR) &#123; if (bwr.write_consumed &gt; 0) &#123; if (bwr.write_consumed &lt; mOut.dataSize()) mOut.remove(0, bwr.write_consumed); else mOut.setDataSize(0); &#125; if (bwr.read_consumed &gt; 0) &#123; mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; return NO_ERROR; &#125; return err;&#125; 经过 IPCThreadState::talkWithDriver() ,就将数据发送给了 Binder 驱动。 继续追踪 IPCThreadState::waitForResponse() ，可以从 第6步 发现 IPCThreadState 不断的循环读取 Binder 驱动返回，获取到返回命令后执行了 executeCommand(cmd) 函数。 8. IPCThreadState::executeCommand() 处理 Binder 驱动返回命令 123456789101112131415161718192021222324252627282930313233343536status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION: &#123; binder_transaction_data tr; result = mIn.read(&amp;tr, sizeof(tr)); ... Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); ... Parcel reply; status_t error; if (tr.target.ptr) &#123; sp&lt;BBinder&gt; b((BBinder*)tr.cookie); error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; else &#123; error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; ... &#125; break; ...&#125; 9. 可以看出其调用了 BBinder::transact() 函数，将数据返回给上层。 123456789101112131415161718192021status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); status_t err = NO_ERROR; switch (code) &#123; case PING_TRANSACTION: reply-&gt;writeInt32(pingBinder()); break; default: err = onTransact(code, data, reply, flags); break; &#125; if (reply != NULL) &#123; reply-&gt;setDataPosition(0); &#125; return err;&#125; 10. 而这里的 b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags) 中的 b (BBinder) 是 JavaBBinder 的实例，所以会调用 JavaBBinder::onTransact() 函数 12345678910111213141516// frameworks/base/core/jni/android_util_Binder.cppvirtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) &#123; JNIEnv* env = javavm_to_jnienv(mVM); ... jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); &#125;static int int_register_android_os_Binder(JNIEnv* env)&#123; ... gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, \"execTransact\", \"(IJJI)Z\"); ...&#125; 11. 可见 JNI 通过 gBinderOffsets.mExecTransact 最后执行了 android.os.Binder 的 execTransact() 方法。 execTransact() 方法是 jni 回调的入口。 1234567891011// Entry point from android_util_Binder.cpp's onTransact private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); ... try &#123; res = onTransact(code, data, reply, flags); &#125; ... &#125; 12. 而我们则在服务端 IRemoteService.Stub 重载了 onTransact() 方法，所以数据最后会回到我们的服务端并执行服务端实现的 addUser() 方法。 12345678910111213141516171819202122232425262728293031public static abstract class Stub extends android.os.Binder implements org.xdty.remoteservice.IRemoteService &#123; ... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_basicTypes: &#123; ... return true; &#125; case TRANSACTION_addUser: &#123; data.enforceInterface(DESCRIPTOR); org.xdty.remoteservice.User _arg0; if ((0 != data.readInt())) &#123; _arg0 = org.xdty.remoteservice.User.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addUser(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125;&#125; 上述过程就是所有的 Native 层客户端到服务端的调用过程，总结下来就是 客户端进程发送 BC_TRANSACTION 到 Binder 驱动，服务端进程监听返回的 BR_TRANSACTION 命令并处理。如果是服务端向客户端返回数据，类似的是服务端发送 BC_REPLY 命令， 客户端监听 BR_REPLY 命令。 3.3 Binder 设备文件的打开和读写1. 设备的打开 在上一小节中我们看到 JNI 过程中调用了 ProcessState::getContextObject() 函数， 在 ProcessState 初始化时会打开 binder 设备 1234567// ProcessState.cppProcessState::ProcessState() : mDriverFD(open_driver()) ...&#123; ...&#125; open_driver() 函数内容如下 1234567891011121314151617181920212223242526272829303132// ProcessState.cppstatic int open_driver()&#123; // 打开设备文件 int fd = open(\"/dev/binder\", O_RDWR); if (fd &gt;= 0) &#123; fcntl(fd, F_SETFD, FD_CLOEXEC); int vers = 0; // 获取驱动版本 status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) &#123; ALOGE(\"Binder ioctl to obtain version failed: %s\", strerror(errno)); close(fd); fd = -1; &#125; // 检查驱动版本是否一致 if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ALOGE(\"Binder driver protocol does not match user space protocol!\"); close(fd); fd = -1; &#125; // 设置最多 15 个 binder 线程 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); &#125; &#125; else &#123; ALOGW(\"Opening '/dev/binder' failed: %s\\n\", strerror(errno)); &#125; return fd;&#125; 2. 设备的读写 打开设备文件后，文件描述符被保存在 mDriverFD， 通过系统调用 ioctl 函数操作 mDriverFD 就可以实现和 binder 驱动的交互。 对 Binder 设备文件的所有读写及关闭操作则都在 IPCThreadState 中，如上一小节提及到的 IPCThreadState::talkWithDriver 函数 talkWithDriver() 函数封装了 BINDER_WRITE_READ 命令，会从 binder 驱动读取或写入封装在 binder_write_read 结构体中的本地或远程对象。 12345678910111213141516171819202122232425// IPCThreadState.cppstatus_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; // 写入数据 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // 读取数据 if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; ... // 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; ...&#125; 可以看出，本地层是对应用与 binder 驱动交互的直接封装与实现，最终的数据传输仍是由驱动来完成的。本地层对底层驱动进行了完整的封装，上层应用只关心 transact() 和 onTransact() 回调，察觉不到 binder 驱动的存在，减轻了上层应用进程间通信开发的复杂度。 4. Binder 驱动关于 binder 驱动建议参考另一篇文章 深入分析Android Binder 驱动 原文，本小节仍需要完善。 Binder 驱动是 Binder 的最终实现， ServiceManager 和 Client/Service 进程间通信最终都是由 Binder 驱动投递的。 Binder 驱动的代码位于 kernel 代码的 drivers/staging/android 目录下。主文件是 binder.h 和 binder.c 进程间传输的数据被称为 Binder 对象，它是一个 flat_binder_object，结构如下 1234567891011121314struct flat_binder_object &#123; /* 8 bytes for large_flat_header. */ unsigned long type; unsigned long flags; /* 8 bytes of data. */ union &#123; void *binder; /* local object */ signed long handle; /* remote object */ &#125;; /* extra data associated with local object */ void *cookie;&#125;; 其中 类型 type 描述了 Binder 对象的类型，包含 BINDER(本地对象)、HANDLE(远程对象)、 FD 三大类(五种) 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; flags 则表述了传输方式，如异步、无返回等 123456enum transaction_flags &#123; TF_ONE_WAY = 0x01, /* this is a one-way call: async, no return */ TF_ROOT_OBJECT = 0x04, /* contents are the component's root object */ TF_STATUS_CODE = 0x08, /* contents are a 32-bit status code */ TF_ACCEPT_FDS = 0x10, /* allow replies with file descriptors */&#125;; 而 flat_binder_object 中的 union 联合体 就是要传输的数据，当类型为 BINDER 时， 数据就是一个本地对象 *binder，而类型为 HANDLE 时，数据则是一个远程对象 handle。 当 flat_binder_object 在进程间传递时， Binder 驱动会修改它的类型和数据，交换的代码参考 binder_transaction 的实现。 该如何理解本地 BINDER 对象和远程 HANDLE 对象呢？其实它们都代表同一个对象，不过是从不同的角度来看。举例来说，假如进程 RemoteService 有个对象 mBinder，对于 RemoteService 来说，mBinder 就是一个本地的 BINDER 对象；如果进程 app 通过 Binder 驱动访问 RemoteService 的 mBinder 对象，对于 app 来说， mBinder 就是一个 HANDLE。因此，从根本上来说 handle 和 binder 都指向 RemoteService 的 mBinder。本地对象还可以带有额外的数据，保存在 cookie 中。 Binder 驱动直接操作的最外层数据结构是 binder_transaction_data， Binder 对象 flat_binder_object 被封装在 binder_transaction_data 结构体中。 binder_transaction_data 数据结构才是真正传输的数据，其定义如下 1234567891011121314151617181920212223242526272829303132struct binder_transaction_data &#123; /* The first two are only used for bcTRANSACTION and brTRANSACTION, * identifying the target and contents of the transaction. */ union &#123; size_t handle; /* target descriptor of command transaction */ void *ptr; /* target descriptor of return transaction */ &#125; target; void *cookie; /* target object cookie */ unsigned int code; /* transaction command */ /* General information about the transaction. */ unsigned int flags; pid_t sender_pid; uid_t sender_euid; size_t data_size; /* number of bytes of data */ size_t offsets_size; /* number of bytes of offsets */ /* If this transaction is inline, the data immediately * follows here; otherwise, it ends with a pointer to * the data buffer. */ union &#123; struct &#123; /* transaction data */ const void *buffer; /* offsets from buffer to flat_binder_object structs */ const void *offsets; &#125; ptr; uint8_t buf[8]; &#125; data;&#125;; flat_binder_object 就被封装在 *buffer中，其中的 unsigned int code; 则是传输命令，描述了 Binder 对象执行的操作。 4.1 binder 设备的创建device_initcall() 函数是内核加载驱动的入口函数，我们先来看这个函数的调用过程。 12345678910111213141516171819202122232425262728static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, // 设备文件 /dev/binder .name = \"binder\", // 设备文件操作 .fops = &amp;binder_fops&#125;;static int __init binder_init(void)&#123; int ret; ... // 注册字符设备 ret = misc_register(&amp;binder_miscdev); ... // 调试文件， 在 /sys/kernel/debug/binder 目录下 if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(\"state\", S_IRUGO, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); ... &#125; return ret;&#125;device_initcall(binder_init); 可以看出 binder_init() 使用 misc_register() 函数创建了 binder 设备。从 misc_register(&amp;binder_miscdev); 及 .name = “binder” 可以看出， binder 向 kernel 注册了一个 /dev/binder 的字符设备，而文件操作都在 binder_fops 结构体中定义。 123456789static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 从上面 binder_fops 结构体可以看出，主要的操作是 binder_ioctl() binder_mmap() binder_open() 等函数实现的。 4.2 binder 协议和数据结构binder.h 文件中定义了 binder 协议和重要的数据结构。 首先在 enum 中定义了 binder 处理的类型，引用或是句柄 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; 下面这段宏定义则是在 ioctl 函数调用时可用的具体命令。 1234567#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_IDLE_TIMEOUT _IOW('b', 3, int64_t)#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)#define BINDER_SET_IDLE_PRIORITY _IOW('b', 6, int)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)#define BINDER_THREAD_EXIT _IOW('b', 8, int)#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 在 BinderDriverReturnProtocol 和 BinderDriverCommandProtocol 中 则分别定义了 客户端调用 和 服务端 返回的命令。 4.3 binder 驱动文件操作上文已经提到，所有的操作定义在 binder_fops 结构体中，下面讲述这些操作。 设备的打开 - binder_open() 函数 用户空间在打开 /dev/binder 设备时，驱动会出发 binder_open() 函数的响应。 123456789101112131415161718192021222324252627282930313233static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // 分配 binder_proc 数据结构内存 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; // 增加当前线程/进程的引用计数并赋值给tsk get_task_struct(current); proc-&gt;tsk = current; // 初始化队列 INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); binder_lock(__func__); // 增加BINDER_STAT_PROC的对象计数 binder_stats_created(BINDER_STAT_PROC); // 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); // 保存进程 id proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); // 驱动文件 private_data 指向 proc filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; 驱动文件释放 - binder_release() 函数 在用户空间关闭驱动设备文件时，会调用 binder_release() 函数，清理 binder_proc 对象，释放占用的内存。 123456789101112131415161718192021static int binder_release(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc = filp-&gt;private_data; binder_defer_work(proc, BINDER_DEFERRED_RELEASE); return 0;&#125;static voidbinder_defer_work(struct binder_proc *proc, enum binder_deferred_state defer)&#123; mutex_lock(&amp;binder_deferred_lock); proc-&gt;deferred_work |= defer; if (hlist_unhashed(&amp;proc-&gt;deferred_work_node)) &#123; // 添加到释放队列中 hlist_add_head(&amp;proc-&gt;deferred_work_node, &amp;binder_deferred_list); queue_work(binder_deferred_workqueue, &amp;binder_deferred_work); &#125; mutex_unlock(&amp;binder_deferred_lock);&#125; 内存映射 - binder_mmap() 函数 binder_mmap() 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; // 获得 binder_proc 对象 struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; // 最多只分配 4M 的内存 if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; // 检查 flags if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE; mutex_lock(&amp;binder_mmap_lock); // 检查是否已经映射 if (proc-&gt;buffer) &#123; ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; &#125; // 申请内核虚拟内存空间 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; // 将申请到的内存地址保存到 binder_proc 对象中 proc-&gt;buffer = area-&gt;addr; proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); // 根据请求到的内存空间大小，分配给 binder_proc 对象的 pages， 用于保存指向物理页的指针 proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (proc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; // 分配一个页的物理内存 if (binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123; ret = -ENOMEM; failure_string = \"alloc small buf\"; goto err_alloc_small_buf_failed; &#125; // 内存提供给 binder_buffer buffer = proc-&gt;buffer; // 初始化 proc-&gt;buffers 链表 INIT_LIST_HEAD(&amp;proc-&gt;buffers); // 将 binder_buffer 对象放入到 proc-&gt;buffers 链表中 list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); buffer-&gt;free = 1; binder_insert_free_buffer(proc, buffer); proc-&gt;free_async_space = proc-&gt;buffer_size / 2; barrier(); proc-&gt;files = get_files_struct(proc-&gt;tsk); proc-&gt;vma = vma; proc-&gt;vma_vm_mm = vma-&gt;vm_mm; return 0;&#125; 驱动命令接口 - binder_ioctl() 函数 用户态程序调用 ioctl 系统函数向 /dev/binder 设备发送数据时，会触发 binder_ioctl() 函数响应。 上文数据结构中已经提到了 binder_ioctl 可以处理的 命令 12345678910// 核心命令，数据的读写#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)// 设置最大线程数#define BINDER_SET_MAX_THREADS _IOW('b', 5, size_t)// 设置 context manager#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)// 线程退出命令#define BINDER_THREAD_EXIT _IOW('b', 8, int)// binder 驱动的版本#define BINDER_VERSION _IOWR('b', 9, struct binder_version) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // 检查是否有错误 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; binder_lock(__func__); // 获取 binder_thread 对象 thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto err; &#125; // 从用户空间拷贝 binder_write_read 到 binder 驱动，储存在 bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; if (bwr.write_size &gt; 0) &#123; // 执行写入操作 ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); if (ret &lt; 0) &#123; bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; if (bwr.read_size &gt; 0) &#123; // 执行读取操作 ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); if (!list_empty(&amp;proc-&gt;todo)) wake_up_interruptible(&amp;proc-&gt;wait); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto err; &#125; &#125; // 操作完成后将数据返回给用户空间 if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; break; &#125; case BINDER_SET_MAX_THREADS: // 设置最大线程，从用户空间拷贝数据到 proc-&gt;max_threads if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123; ret = -EINVAL; goto err; &#125; break; case BINDER_SET_CONTEXT_MGR: // 检查是否已经设置 if (binder_context_mgr_node != NULL) &#123; ret = -EBUSY; goto err; &#125; // 设置 context manager ret = security_binder_set_context_mgr(proc-&gt;tsk); if (ret &lt; 0) goto err; if (binder_context_mgr_uid != -1) &#123; if (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123; ret = -EPERM; goto err; &#125; &#125; else binder_context_mgr_uid = current-&gt;cred-&gt;euid; // 创建 binder_context_mgr_node 节点 binder_context_mgr_node = binder_new_node(proc, NULL, NULL); if (binder_context_mgr_node == NULL) &#123; ret = -ENOMEM; goto err; &#125; // 初始化节点数据 binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; break; case BINDER_THREAD_EXIT: // 线程退出，释放资源 binder_free_thread(proc, thread); thread = NULL; break; case BINDER_VERSION: // 将 binder 驱动版本号写入到用户空间 ubuf-&gt;protocol_version 中 if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;((struct binder_version *)ubuf)-&gt;protocol_version)) &#123; ret = -EINVAL; goto err; &#125; break; default: ret = -EINVAL; goto err; &#125; ret = 0;...&#125; 123456789101112131415161718192021222324252627282930313233343536373839static struct binder_node *binder_new_node(struct binder_proc *proc, void __user *ptr, void __user *cookie)&#123; struct rb_node **p = &amp;proc-&gt;nodes.rb_node; struct rb_node *parent = NULL; struct binder_node *node; // 查找要插入节点的父节点 while (*p) &#123; parent = *p; node = rb_entry(parent, struct binder_node, rb_node); if (ptr &lt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_left; else if (ptr &gt; node-&gt;ptr) p = &amp;(*p)-&gt;rb_right; else return NULL; &#125; // 为要插入节点分配内存空间 node = kzalloc(sizeof(*node), GFP_KERNEL); if (node == NULL) return NULL; binder_stats_created(BINDER_STAT_NODE); // 插入节点 rb_link_node(&amp;node-&gt;rb_node, parent, p); rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); // 初始化 node-&gt;debug_id = ++binder_last_id; node-&gt;proc = proc; node-&gt;ptr = ptr; node-&gt;cookie = cookie; node-&gt;work.type = BINDER_WORK_NODE; INIT_LIST_HEAD(&amp;node-&gt;work.entry); INIT_LIST_HEAD(&amp;node-&gt;async_todo); return node;&#125; BINDER_WRITE_READ 处理过程 在 binder 本地层中，我们看到在 IPCThreadState::talkWithDriver() 函数中， binder 本地层通过 ioctl()(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) 命令的形式，与 binder 驱动交互。 可以看出 ioctl() 的第三个参数是一个 binder_write_read 结构体 binder.h 头文件中定义了两个数据类型, 一个是 binder_write_read 12345678struct binder_write_read &#123; signed long write_size; /* bytes to write */ signed long write_consumed; /* bytes consumed by driver */ unsigned long write_buffer; signed long read_size; /* bytes to read */ signed long read_consumed; /* bytes consumed by driver */ unsigned long read_buffer;&#125;; 其中 write_size 和 read_size 表示需要被读写的字节数， write_consumed 和 read_consumed 表示已经被 binder 驱动读写的字节数， write_buffer 和 read_buffer 则是指向被读写数据的指针。 具体的读写操作被 binder_thread_write 和 binder_thread_read 实现。 数据写入 - binder_thread_write() 函数 将用户空间数据写入到 binder 驱动，从驱动角度来看是读取的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; // 用户空间数据，起始地址和结束地址 void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // 循环读取 while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // 从用户空间获取操作命令 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123; // 增加命令计数器 binder_stats.bc[_IOC_NR(cmd)]++; proc-&gt;stats.bc[_IOC_NR(cmd)]++; thread-&gt;stats.bc[_IOC_NR(cmd)]++; &#125; switch (cmd) &#123; // 这四个命令用来增加或减少对象的引用计数， 操作目标 binder_ref case BC_INCREFS: case BC_ACQUIRE: case BC_RELEASE: case BC_DECREFS: &#123; uint32_t target; struct binder_ref *ref; const char *debug_string; // 获取目标进程节点描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 索描述为 0 表示 context manager 进程 if (target == 0 &amp;&amp; binder_context_mgr_node &amp;&amp; (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123; // 在 proc-&gt;refs_by_node.rb_node 红黑树中查找引用 ref = binder_get_ref_for_node(proc, binder_context_mgr_node); &#125; else // 在 proc-&gt;refs_by_desc.rb_node 红黑树中查找引用 ref = binder_get_ref(proc, target); switch (cmd) &#123; case BC_INCREFS: debug_string = \"IncRefs\"; // 增加弱引用计数 binder_inc_ref(ref, 0, NULL); break; case BC_ACQUIRE: debug_string = \"Acquire\"; // 增加强引用计数 binder_inc_ref(ref, 1, NULL); break; case BC_RELEASE: debug_string = \"Release\"; // 减少强引用计数 binder_dec_ref(ref, 1); break; case BC_DECREFS: default: debug_string = \"DecRefs\"; // 减少弱引用计数 binder_dec_ref(ref, 0); break; &#125; break; &#125; case BC_INCREFS_DONE: case BC_ACQUIRE_DONE: &#123; void __user *node_ptr; void *cookie; struct binder_node *node; // 从用户空间读取 node_ptr if (get_user(node_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 从用户空间读取 cookie if (get_user(cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获得节点 node = binder_get_node(proc, node_ptr); // 没有找到则返回 if (node == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"%s u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr); break; &#125; // cookie 不匹配则返回 if (cookie != node-&gt;cookie) &#123; binder_user_error(\"binder: %d:%d %s u%p node %d\" \" cookie mismatch %p != %p\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_INCREFS_DONE ? \"BC_INCREFS_DONE\" : \"BC_ACQUIRE_DONE\", node_ptr, node-&gt;debug_id, cookie, node-&gt;cookie); break; &#125; if (cmd == BC_ACQUIRE_DONE) &#123; node-&gt;pending_strong_ref = 0; &#125; else &#123; node-&gt;pending_weak_ref = 0; &#125; // 减少节点使用计数 binder_dec_node(node, cmd == BC_ACQUIRE_DONE, 0); break; &#125; // 释放 binder_bffer case BC_FREE_BUFFER: &#123; void __user *data_ptr; struct binder_buffer *buffer; // 从用户空间获取 data_ptr if (get_user(data_ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 查找 binder_buffer buffer = binder_buffer_lookup(proc, data_ptr); // 没有找到则返回 if (buffer == NULL) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p no match\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 不允许用户释放则返回 if (!buffer-&gt;allow_user_free) &#123; binder_user_error(\"binder: %d:%d \" \"BC_FREE_BUFFER u%p matched \" \"unreturned buffer\\n\", proc-&gt;pid, thread-&gt;pid, data_ptr); break; &#125; // 将 buffer-&gt;transaction 置空 if (buffer-&gt;transaction) &#123; buffer-&gt;transaction-&gt;buffer = NULL; buffer-&gt;transaction = NULL; &#125; if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123; if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo)) buffer-&gt;target_node-&gt;has_async_transaction = 0; else list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo); &#125; // 释放 binder_buffer 对象 trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, buffer, NULL); binder_free_buf(proc, buffer); break; &#125; // binder 数据传递处理 case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; // 从用户空间拷贝 binder_transaction_data 对象 if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); // 实际的传输函数，在下文讲解 binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; // 设置 looper 为 BINDER_LOOPER_STATE_REGISTERED 状态 case BC_REGISTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"after BC_ENTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else if (proc-&gt;requested_threads == 0) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_REGISTER_LOOPER called \" \"without request\\n\", proc-&gt;pid, thread-&gt;pid); &#125; else &#123; proc-&gt;requested_threads--; proc-&gt;requested_threads_started++; &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_ENTERED 状态 case BC_ENTER_LOOPER: if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123; thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID; binder_user_error(\"binder: %d:%d ERROR:\" \" BC_ENTER_LOOPER called after \" \"BC_REGISTER_LOOPER\\n\", proc-&gt;pid, thread-&gt;pid); &#125; thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; // 设置 looper 为 BINDER_LOOPER_STATE_EXITED 状态 case BC_EXIT_LOOPER: thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED; break; // 发送 REQUEST_DEATH 或 CLEAR_DEATH 通知 case BC_REQUEST_DEATH_NOTIFICATION: case BC_CLEAR_DEATH_NOTIFICATION: &#123; uint32_t target; void __user *cookie; struct binder_ref *ref; struct binder_ref_death *death; // 从用户空间获取 binder_ref 描述 desc if (get_user(target, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); // 获取 binder_ref 引用 ref = binder_get_ref(proc, target); if (ref == NULL) &#123; binder_user_error(\"binder: %d:%d %s \" \"invalid ref %d\\n\", proc-&gt;pid, thread-&gt;pid, cmd == BC_REQUEST_DEATH_NOTIFICATION ? \"BC_REQUEST_DEATH_NOTIFICATION\" : \"BC_CLEAR_DEATH_NOTIFICATION\", target); break; &#125; if (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123; if (ref-&gt;death) &#123; binder_user_error(\"binder: %d:%\" \"d BC_REQUEST_DEATH_NOTI\" \"FICATION death notific\" \"ation already set\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; // 为 binder_ref_death 对象分配内存空间 death = kzalloc(sizeof(*death), GFP_KERNEL); if (death == NULL) &#123; thread-&gt;return_error = BR_ERROR; break; &#125; // 初始化 binder_ref_death 对象 binder_stats_created(BINDER_STAT_DEATH); INIT_LIST_HEAD(&amp;death-&gt;work.entry); death-&gt;cookie = cookie; ref-&gt;death = death; if (ref-&gt;node-&gt;proc == NULL) &#123; ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; else &#123; if (ref-&gt;death == NULL) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion not active\\n\", proc-&gt;pid, thread-&gt;pid); break; &#125; death = ref-&gt;death; if (death-&gt;cookie != cookie) &#123; binder_user_error(\"binder: %d:%\" \"d BC_CLEAR_DEATH_NOTIFI\" \"CATION death notificat\" \"ion cookie mismatch \" \"%p != %p\\n\", proc-&gt;pid, thread-&gt;pid, death-&gt;cookie, cookie); break; &#125; // 将 ref-&gt;death 置空 ref-&gt;death = NULL; if (list_empty(&amp;death-&gt;work.entry)) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; else &#123; BUG_ON(death-&gt;work.type != BINDER_WORK_DEAD_BINDER); death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR; &#125; &#125; &#125; break; case BC_DEAD_BINDER_DONE: &#123; struct binder_work *w; void __user *cookie; struct binder_ref_death *death = NULL; // 从用户空间获取 cookie if (get_user(cookie, (void __user * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123; struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work); if (tmp_death-&gt;cookie == cookie) &#123; death = tmp_death; break; &#125; &#125; if (death == NULL) &#123; binder_user_error(\"binder: %d:%d BC_DEAD\" \"_BINDER_DONE %p not found\\n\", proc-&gt;pid, thread-&gt;pid, cookie); break; &#125; list_del_init(&amp;death-&gt;work.entry); // 如果 death-&gt;work.t 为 BINDER_WORK_DEAD_BINDER_AND_CLEAR 则修改为 BINDER_WORK_CLEAR_DEATH_NOTIFICATION if (death-&gt;work.t == BINDER_WORK_DEAD_BINDER_AND_CLEAR ) &#123; death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION; if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo); &#125; else &#123; list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo); // 唤醒目标进程 wake_up_interruptible(&amp;proc-&gt;wait); &#125; &#125; &#125; break; default: return -EINVAL; &#125; *consumed = ptr - buffer; &#125; return 0;&#125; binder_transaction() 函数 在上文处理 BC_TRANSACTION 和 BC_REPLY 时，调用了 binder_transaction() 函数。我们继续追踪 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; if (reply) &#123; // BC_REPLY 处理流程 // 得到 binder_transaction 对象 in_reply_to = thread-&gt;transaction_stack; if (in_reply_to == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_empty_call_stack; &#125; binder_set_nice(in_reply_to-&gt;saved_priority); thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // 获取目标线程 target_thread = in_reply_to-&gt;from; target_proc = target_thread-&gt;proc; &#125; else &#123; // BC_TRANSACTION 处理流程 // 查找目标节点 if (tr-&gt;target.handle) &#123; struct binder_ref *ref; // 获取 binder_ref 对象 ref = binder_get_ref(proc, tr-&gt;target.handle); target_node = ref-&gt;node; &#125; else &#123; // 索引为 0 则返回 context manager target_node = binder_context_mgr_node; &#125; // 得到目标进程 target_proc = target_node-&gt;proc; if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123; struct binder_transaction *tmp; tmp = thread-&gt;transaction_stack; while (tmp) &#123; if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc) // 获得目标线程 target_thread = tmp-&gt;from; tmp = tmp-&gt;from_parent; &#125; &#125; &#125; // 设置要处理的目标进程或目标线程任务 if (target_thread) &#123; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; // 为 binder_transaction 对象分配内存空间 t = kzalloc(sizeof(*t), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION); tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); // 如果是同步传输(双向)，则将当前的 binder_thread 对象保存在 binder_transaction 对象的 from 中。 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // 设置 binder_transaction 对象 t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; t-&gt;to_proc = target_proc; t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; t-&gt;flags = tr-&gt;flags; t-&gt;priority = task_nice(current); // 为 binder_buffer 分配内存空间 t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); // 设置 binder_buffer t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; t-&gt;buffer-&gt;transaction = t; t-&gt;buffer-&gt;target_node = target_node; if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // 从用户空间拷贝数据到 binder_buffer if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; return_error = BR_FAILED_REPLY; goto err_copy_data_failed; &#125; off_end = (void *)offp + tr-&gt;offsets_size; for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; // 为 flat_binder_object 赋值 fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); // 转换 binder 类型，如果是 BINDER 则转换为 HANDLE， 如果是 HANDLE 则转为 BANDLE switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; // 获取 binder_node 节点 struct binder_node *node = binder_get_node(proc, fp-&gt;binder); if (node == NULL) &#123; node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); if (node == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_binder_new_node_failed; &#125; node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK; node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS); &#125; if (fp-&gt;cookie != node-&gt;cookie) &#123; goto err_binder_get_ref_for_node_failed; &#125; // 获取 binder_ref 对象 ref = binder_get_ref_for_node(target_proc, node); // 转换类型 if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;handle = ref-&gt;desc; binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); &#125; break; case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; // 获取 binder_ref 对象 struct binder_ref*ref = binder_get_ref(proc, fp-&gt;handle); // 转换类型 if (ref-&gt;node-&gt;proc == target_proc) &#123; if (fp-&gt;type == BINDER_TYPE_HANDLE) fp-&gt;type = BINDER_TYPE_BINDER; else fp-&gt;type = BINDER_TYPE_WEAK_BINDER; fp-&gt;binder = ref-&gt;node-&gt;ptr; fp-&gt;cookie = ref-&gt;node-&gt;cookie; binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, 0, NULL); &#125; else &#123; struct binder_ref *new_ref; new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); &#125; &#125; break; // 文件类型 case BINDER_TYPE_FD: &#123; int target_fd; struct file *file; // 获得文件对象 file = fget(fp-&gt;handle); // 分配一个新的文件描述符 target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC); task_fd_install(target_proc, target_fd, file); fp-&gt;handle = target_fd; &#125; break; default: return_error = BR_FAILED_REPLY; goto err_bad_object_type; &#125; &#125; if (reply) &#123; // BC_REPLY 处理流程, binder_transaction 中释放 binder_transaction 对象 binder_pop_transaction(target_thread, in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; // 同步状态(双向)需要设置回复 t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; thread-&gt;transaction_stack = t; &#125; else &#123; // 异步传输不需要设置回复 if (target_node-&gt;has_async_transaction) &#123; target_list = &amp;target_node-&gt;async_todo; target_wait = NULL; &#125; else target_node-&gt;has_async_transaction = 1; &#125; t-&gt;work.type = BINDER_WORK_TRANSACTION; list_add_tail(&amp;t-&gt;work.entry, target_list); tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); if (target_wait) // 唤醒目标线程 wake_up_interruptible(target_wait); return;&#125; 数据读取 - binder_thread_read() 函数 用户空间从 binder 驱动读取数据，从驱动角度来看是写出的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; if (*consumed == 0) &#123; // 第一次操作时向用户空间返回 BR_NOOP 命令 if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: // 获取将要处理的任务 wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); if (wait_for_proc_work) &#123; if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; binder_user_error(\"binder: %d:%d ERROR: Thread waiting \" \"for process work before calling BC_REGISTER_\" \"LOOPER or BC_ENTER_LOOPER (state %x)\\n\", proc-&gt;pid, thread-&gt;pid, thread-&gt;looper); wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); &#125; binder_set_nice(proc-&gt;default_priority); if (non_block) &#123; // 非阻塞且没有数据则返回 EAGAIN if (!binder_has_proc_work(proc, thread)) ret = -EAGAIN; &#125; else // 阻塞则进入睡眠状态，等待可操作的任务 ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread)); &#125; else &#123; if (non_block) &#123; if (!binder_has_thread_work(thread)) ret = -EAGAIN; &#125; else ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread)); &#125; binder_lock(__func__); if (wait_for_proc_work) proc-&gt;ready_threads--; thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; if (ret) return ret; while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // 获取 binder_work 对象 if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry); else &#123; if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; &#125; if (end - ptr &lt; sizeof(tr) + 4) break; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; // 获取 binder_transaction 对象 t = container_of(w, struct binder_transaction, work); &#125; break; case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // 返回 BR_TRANSACTION_COMPLETE 命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); binder_stat_br(proc, thread, cmd); // 从 work 链表中删除并释放内存 list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; case BINDER_WORK_NODE: &#123; // 获得 binder_node 节点 struct binder_node *node = container_of(w, struct binder_node, work); uint32_t cmd = BR_NOOP; const char *cmd_name; // 根据节点类型，增加/获取、减少/释放节点索引 int strong = node-&gt;internal_strong_refs || node-&gt;local_strong_refs; int weak = !hlist_empty(&amp;node-&gt;refs) || node-&gt;local_weak_refs || strong; // 构造 BR_* 命令 if (weak &amp;&amp; !node-&gt;has_weak_ref) &#123; cmd = BR_INCREFS; cmd_name = \"BR_INCREFS\"; node-&gt;has_weak_ref = 1; node-&gt;pending_weak_ref = 1; node-&gt;local_weak_refs++; &#125; else if (strong &amp;&amp; !node-&gt;has_strong_ref) &#123; cmd = BR_ACQUIRE; cmd_name = \"BR_ACQUIRE\"; node-&gt;has_strong_ref = 1; node-&gt;pending_strong_ref = 1; node-&gt;local_strong_refs++; &#125; else if (!strong &amp;&amp; node-&gt;has_strong_ref) &#123; cmd = BR_RELEASE; cmd_name = \"BR_RELEASE\"; node-&gt;has_strong_ref = 0; &#125; else if (!weak &amp;&amp; node-&gt;has_weak_ref) &#123; cmd = BR_DECREFS; cmd_name = \"BR_DECREFS\"; node-&gt;has_weak_ref = 0; &#125; // 向用户空间返回命令 if (cmd != BR_NOOP) &#123; if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); if (put_user(node-&gt;ptr, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); if (put_user(node-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); &#125; else &#123; list_del_init(&amp;w-&gt;entry); if (!weak &amp;&amp; !strong) &#123; rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes); kfree(node); binder_stats_deleted(BINDER_STAT_NODE); &#125; &#125; &#125; break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; struct binder_ref_death *death; uint32_t cmd; // 获取 binder_ref_death 对象 death = container_of(w, struct binder_ref_death, work); // 构造返回命令 if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE; else cmd = BR_DEAD_BINDER; // 向用户空间返回命令 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 将 cookie 返回给用户空间 if (put_user(death-&gt;cookie, (void * __user *)ptr)) return -EFAULT; ptr += sizeof(void *); binder_stat_br(proc, thread, cmd); if (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123; list_del(&amp;w-&gt;entry); kfree(death); binder_stats_deleted(BINDER_STAT_DEATH); &#125; else list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death); if (cmd == BR_DEAD_BINDER) goto done; /* DEAD_BINDER notifications can cause transactions */ &#125; break; &#125; if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; // 获得 binder_node 节点 struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // 将数据封装到 binder_transaction_data 对象 tr.target.ptr = target_node-&gt;ptr; tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); // 设置返回的命令类型 cmd = BR_TRANSACTION; &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; &#125; tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; tr.sender_pid = 0; &#125; tr.data_size = t-&gt;buffer-&gt;data_size; tr.offsets_size = t-&gt;buffer-&gt;offsets_size; tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); // 拷贝 binder_transaction_data 对象到用户空间 if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_stat_br(proc, thread, cmd); // 移除 binder_transaction 并释放空间 list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // 如果是同步操作，则将 thread 对象保存在 binder_transaction 中，返回给发送方进程, 否则释放 binder_transaction 对象 if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; t-&gt;to_parent = thread-&gt;transaction_stack; t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; &#125; else &#123; t-&gt;buffer-&gt;transaction = NULL; kfree(t); binder_stats_deleted(BINDER_STAT_TRANSACTION); &#125; break; &#125;&#125; 从上述代码可以看出 binder 驱动的具体实现，以及是如何发送和接收数据的。 5. Binder 与系统服务5.1 Context.getSystemService()Android 系统在启动后会在后台运行很多系统服务提供给应用使用，这些 服务) 主要有 WindowManager, LayoutInflater, ActivityManager, PowerManager, AlarmManager, NotificationManager, KeyguardManager, LocationManager, SearchManager, Vibrator, ConnectivityManager, WifiManager, AudioManager, MediaRouter, TelephonyManager, SubscriptionManager, InputMethodManager, UiModeManager, DownloadManager, BatteryManager, JobScheduler, NetworkStatsManager 我们可以通过 Context.getSystemService(String name) 来获取 服务)。 例如 可以通过如下方法从 xml 中插入新的视图 LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE); inflater.inflate(R.layout.view, root, true); 5.2 Context.getSystemService() 源码分析追踪 ContextImpl getSystemService() 源代码 1234@Overridepublic Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name);&#125; 继续追踪 SystemServiceRegistry 源代码 1234567/** * Gets a system service from a given context. */public static Object getSystemService(ContextImpl ctx, String name) &#123; ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null;&#125; 追踪 SYSTEM_SERVICE_FETCHERS 可以发现在 SystemServiceRegistry 静态区中注册了几乎所有的系统服务 1234567891011121314registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher&lt;LayoutInflater&gt;() &#123; @Override public LayoutInflater createService(ContextImpl ctx) &#123; return new PhoneLayoutInflater(ctx.getOuterContext()); &#125;&#125;);registerService(Context.LOCATION_SERVICE, LocationManager.class, new CachedServiceFetcher&lt;LocationManager&gt;() &#123; @Override public LocationManager createService(ContextImpl ctx) &#123; IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE); return new LocationManager(ctx, ILocationManager.Stub.asInterface(b)); &#125;&#125;); 上面代码片断中，PhoneLayoutInflater 最终回到了 LayoutInflater。而 LocationManager 则是对 ILocationManager 的封装。可以发现，在 frameworks/base/location/java/android/location 包下含有大量的 AIDL 文件。 继续追踪 ServiceManager.getService(Context.LOCATION_SERVICE) 1234567891011121314151617181920212223242526272829private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125;/** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn't exist */public static IBinder getService(String name) &#123; try &#123; IBinder service = sCache.get(name); if (service != null) &#123; return service; &#125; else &#123; return getIServiceManager().getService(name); &#125; &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in getService\", e); &#125; return null;&#125; 从上面代码片断可以看出，ServiceManager 会从 sCache 缓存或 IServiceManager 中查找服务并返回一个 IBinder 对象。这个 IBinder 就是一个远程对象，可以通过它与其他进程交互。 继续深入 getIServiceManager().getService(name) , 进入 ServiceManagerNative 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125;class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; &#125; public IBinder asBinder() &#123; return mRemote; &#125; public IBinder getService(String name) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; &#125; private IBinder mRemote;&#125; 从上边代码片断可以看到，ServiceManager.getIServiceManager() 返回的是一个 ServiceManagerProxy, 而 ServiceManager.getService() 则是在 ServiceManagerProxy 中通过 ServiceManager 的远程 Binder 对象 mRemote，操作 Parcel 数据，调用 IBinder.transact(int code, Parcel data, Parcel reply, int flags) 方法来发送请求，并通过 reply.readStrongBinder() 返回了要查找的服务的远程对象。 可以看到，系统服务的获取方式也是通过 AIDL 的方式实现的。 6. 结论1. Binder 的实现涉及到 kernel 驱动，本地层，JNI 和应用层，贯穿了整个 Ａndroid 系统。系统服务获取、Activity/Service 启动、Intent的传递等都离不开 binder,要掌握 binder 的原理需要深入到系统的每一层代码。 2. 上层的 android.os.Binder 只是对 binder 的又一次抽象封装，我们在应用中一般也不会直接使用。 3. AIDL 本质上是一个用于封装 Binder 操作的工具，最终的进程间通信由 Binder 的 transact 和 onTransact 完成。我们在应用中实现 AIDL 接口，可以快速实现进程间通信。 7. 参考Android Binder机制 Android进程间通信（IPC）机制Binder Android Binder Android Architecture Binder AIDL与Binder框架浅谈 Binder框架解析 Deep Dive into Android IPC/Binder Framework at Android Builders Summit 2013 Android Builders Summit 2013 - Deep Dive into Android IPC/Binder Framework (video) Binder源码分析之驱动层（原） 深入分析Android Binder 驱动 构造IOCTL命令的学习心得—–_IO, _IOR, _IOW, _IOWR 幻数的理解 Service与Android系统设计（7）— Binder驱动 Android Binder Binder机制，从Java到C （7. Native Service） 待补充的内容 1. 客户端 bindService() 流程及源码分析 2. Binder Native 层其他源码文件分析 3. 系统服务（SystemService）详细列表及在本地层的源码分析 4. SystemManager 源码分析 5. 完善 binder 驱动内容，补充关系图 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"AsyncTask源码分析","date":"2017-07-26T11:36:58.000Z","path":"2017/07/26/AsyncTask源码分析/","text":"项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 1. 简介AsyncTask是android提供的一种异步消息处理的解决方案，能简化我们在子线程中更新UI控件，使用AsyncTask你将看不到任何关于操作线程的代码 2. 版本差别2.1 线程池配置 android3.0以前线程池配置，代码如下所示 12345678private static final int CORE_POOL_SIZE = 5;//核心线程数量private static final int MAXIMUM_POOL_SIZE = 128;//线程池中允许的最大线程数目//当线程数目大于核心线程数目时，如果超过这个keepAliveTime时间，那么空闲的线程会被终止private static final it KEEP_ALIVE = 10;…… private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory); android3.0以后更加灵活，根据cpu核数配置CORE_POOL_SIZE和MAXIMUM_POOL_SIZE 123456//根据cpu的大小来配置核心的线程private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;//核心线程数量//线程池中允许的最大线程数目private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;//空闲线程的超时时间 2.2 串行和并行，引用来自这篇文章 android 1.5以前的时候execute是串行执行的 android 1.6直到android 2.3.2被修改为并行执行，执行任务的线程池就是THREAD_POOL_EXECUTOR android 3.0以后，默认任务是串行执行的，如果想要并行执行任务可调用executeOnExecutor(Executor exec, Params.. params) 具体用法可参照Android AsyncTask的骗术 3. 基本用法3.1 继承AsyncTask，设置子类三个泛型的参数 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; Params 异步任务处理的参数 Progress 异步任务执行过程中返回给主线程的进度值，通过publishProgress()方法发送出去 Result 异步任务执行结束返回的结果的结果类型，可以为boolean，或者bitmap等类型 3.2 子类必须实现的抽象方法 onPreExecute 执行后台耗时操作前被调用，通常用于完成一些初始化操作，比如2.3例子中初始化dialog的操作，或者一些集合容器 doInBackGround 必须实现，异步执行后台线程将要完成的任务(该方法在子线程运行，下面源码会分析到) onProgressUpdate 在doInBackGround方法中调用publishProgress方法，AsyncTask就会主动调用onProgressUpdate实现更新 任务的执行进度 onPostExecute 当doInBackGround完成后，系统会自动调用，销毁一些dialog的操作，并将doInBackGround方法返回的值传给该方法 执行的大致流程是： onPreExecute-&gt; doInBackGround-&gt;onProgressUpdate(调用publishProgress的时候)-&gt;onPostExecute 3.3 用法案例1、实例化子类1234//串行实例化new DownAsyncTask().extcute();//并行实例化new DownAsyncTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,\"\"); 2、点击查看，代码案例 3.4 取消异步任务1AsyncTask.cancel(mayInterruptIfRunning); mayInterruptIfRunning是boolean类型的(注意这里true和false的区别)，其调用流程：AsyncTask.cancel() -&gt; FutureTask.cancel()。FutureTask.cancel()的源码如下：123456789101112131415161718192021222324public boolean cancel(boolean mayInterruptIfRunning) &#123; //检测当前状态是否是NEW,如果不是，说明任务已经完成或取消或中断，所以直接返回。 if (!(state == NEW &amp;&amp; U.compareAndSwapInt(this, STATE, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception //如果mayInterruptIfRunning为true的时候，线程就会调用interrupt()方法，抛出异常。 if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) //调用interrupt方法，状态设置为INTERRUPTING，然后试着中断线程，完成后设置状态为INTERRUPTED t.interrupt(); &#125; finally &#123; // final state U.putOrderedInt(this, STATE, INTERRUPTED); &#125; &#125; &#125; finally &#123; //通知等待线程的结果（因为FutureTask.get()法获得计算结果的唯一方法，如果计算没有完成，此方法会堵塞直到计算完成） finishCompletion(); &#125; return true; &#125; 以下是我代码例子中doInBackground()中注释的，这里主要是为了强调true和false的区别 123456try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; 如果线程处于休眠状态，为true则正在执行的线程将会中断，抛出异常，但执行的任务线程会继续执行完毕调用onCanceled()。为false则正在执行的线程不会中断，任务线程执行完毕调用onCanceled() 如果线程不处于休眠状态，为true和false都没有区别，任务线程执行完毕后调用onCanceled()正确地取消要在doInBackground(Void... params)使用isCancelled()来判断，退出循环操作。如下面的 1234567891011121314@Overrideprotected Boolean doInBackground(Void... params) &#123; while (progress &lt; 10000) &#123; progress = progress + 2; Log.i(\"当前的进度\", \"progress==\" + progress); publishProgress(progress); //判断是不是调用了AsyncTask.cancel(mayInterruptIfRunning)，如果已经调用了， if(isCancelled()) &#123; break;//跳出循环，马上调用onCancelled()方法，不需要等doInBackground执行完任务 &#125; &#125; return true;&#125; 4. AsyncTask源码分析(基于android3.0以后分析)4.1 AsyncTask构造函数12345678910111213141516171819202122232425262728293031323334/**AsyncTask的构造函数源码片段**/public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; //异步任务执行的时候回调call方法 public Result call() throws Exception &#123; mTaskInvoked.set(true); //设置线程的优先级 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); //将结果发送出去 return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; //任务执行完毕后会调用done方法 @Override protected void done() &#123; try &#123; //get()表示获取mWorker的call的返回值，即Result.然后看postResultIfNotInvoked方法 postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occurred while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; AsyncTask的实例化是在UI线程中。12345//@MainThread表示这个动作是在UI线程中完成@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; 构造函数初始化了两个成员变量mWorker和mFuture。mWorker为WorkerRunnable类型的匿名内部类实例对象（实现了Callable接口），mFuture为FutureTask类型的匿名内部类实例对象，将mWorker作为mFuture的形参（重写了FutureTask类的done方法）。 WorkerRunnable是一个实现了Callable的抽象类，扩展了Callable多了一个Params参数 1234private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt;&#123; Params[] mParams;&#125; 下面讲述下Callable和Runnable的区别 Callable的接口方法是call，Runnable是run Callable可以带返回值，Runnable不行，结果通过Future.get()获取 Callable可以捕获异常，Runnable不行 123456789101112131415161718192021public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; //那WorkerRunnable的回调方法call肯定是在FutureTask中调用的 FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable) ); new Thread(future).start(); try &#123; Thread.sleep(5000);// 可能做一些事情 System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FutureTask的构造函数如下，1234567public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); //将AsyncTask里面初始化的callable赋值给FutureTask里面的callable，证实了WorkerRunnable的回调方法call肯定是在FutureTask中调用的 this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 查看FutureTask类，它实现了接口Runnable1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; // 实现了RunnableFuture接口 作为Runnable被线程执行，同时将Callable作为构造函数的参数传入，这样组合的好处是，假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到。FutureTask的run方法要开始回调WorkerRunable的call方法了，call里面调用doInBackground(mParams)，终于回到我们后台任务了，调用我们AsyncTask子类的doInBackground()，由此可以看出doInBackground()是在子线程中执行的，如下图所示 4.2 核心方法1、execute()方法12345678private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); /** AsyncTask类的execute方法**/ public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; //调用executeOnExecutor方法 return executeOnExecutor(sDefaultExecutor, params);&#125; 当执行execute方法时，实际上是调用了executeOnExecutor方法。这里传递了两个参数，一个是sDefaultExecutor，一个是params。从上面的源码可以看出，sDefaultExecutor其实是一个SerialExecutor对象，实现了串行线程队列。params其实最终会赋给doInBackground方法去处理。 2、executeOnExecutor()方法1234567891011121314151617181920212223242526//exec执行AsyncTask.execute()方法时传递进来的参数sDefaultExecutor，这个sDefaultExecutor其实就是SerialExecutor对象。默认是串行执行的//若想变成并发执行exec可以传入AsyncTask.THREAD_POOL_EXECUTOR。public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; //如果一个任务已经进入执行的状态，再执行就会抛异常。这就决定了一个AsyncTask只能执行一次 if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; //一旦executeOnExecutor调用了就标记为运行状态 mStatus = Status.RUNNING; //实际是调用子类里面的onPreExecute onPreExecute(); //将处理的参数类型赋值给mWorker mWorker.mParams = params; //execute是调用SERIAL_EXECUTOR的execute，mFuture就是之前AsyncTask构造初始化赋值的FutureTask。 exec.execute(mFuture); return this; &#125; 这里要说明一下，AsyncTask的异步任务有三种状态 PENDING 待执行状态。当AsyncTask被创建时，就进入了PENDING状态。 RUNNING 运行状态。当调用executeOnExecutor，就进入了RUNNING状态。 FINISHED 结束状态。当AsyncTask完成(用户cancel()或任务执行完毕)时，就进入了FINISHED状态。 3、SerialExecutor的execute方法1234567891011121314151617181920212223242526272829303132333435private static class SerialExecutor implements Executor &#123; //循环数组实现的双向Queue。大小是2的倍数，默认是16。有队头队尾两个下标 final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); //当前正在运行的runnable Runnable mActive; public synchronized void execute(final Runnable r) &#123; //添加到双端队列里面去 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; //执行的是mFuture就是之前AsyncTask构造初始化赋值的FutureTask的run()方法 r.run(); &#125; finally &#123; //无论执行结果如何都会取出下一个任务执行 scheduleNext(); &#125; &#125; &#125;); //如果没有活动的runnable，从双端队列里面取出一个runnable放到线程池中运行 //第一个请求任务过来的时候mActive是空的 if (mActive == null) &#123; //取出下一个任务来执行 scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; //从双端队列中取出一个任务 if ((mActive = mTasks.poll()) != null) &#123; //线程池执行取出来的任务，真正执行任务的 THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125;//java exec.execute(mFuture)执行时，SerialExecutor将FutureTask作为参数执行execute方法。在execute方法中，假设FutureTask插入进了两个以上的任务队列到mTasks中，第一次过来mActive==null，通过mTasks.poll()取出一个任务丢给线程池运行，线程池执行r.run，其实就是执行FutureTask的run方法，因为传递进来的r参数就是mFuture。等到上一个线程执完r.run()完之后，这里是通过一个try-finally代码块，并在finally中调用了scheduleNext()方法，保证无论发生什么情况，scheduleNext()都会取出下一个任务执行。接着因为mActive不为空了，不会再执行`scheduleNext()，由于存在一个循环队列，每个 Runnable 被执行的时候，都进入去队列，然后在执行完后出队，才会进入下一个 Runnable 的执行流程。由此可知道这是一个串行的执行过程，同一时刻只会有一个线程正在执行，其余的均处于等待状态。 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams);//调用子类的doInBackground Binder.flushPendingCommands(); return postResult(result);//执行完后通过postResult结果传递出去 &#125; &#125;; 上文中提到调用call()的流程：SerialExecutor.execute() -&gt; FutureTask.run() -&gt; WorkerRunnable.call() 如果回调了call()方法，就会调用了doInBackground(mParams)方法，这都是在子线程中执行的。执行完后，将结果通过postResult(result)发送出去。 4、AsyncTask的postResult方法123456789private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") //获取一个handler，等到一个消息，将结果封装在Message Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result));//new AsyncTaskResult&lt;Result&gt;(this, result)将得到的结果再做了一层封装 //将消息发送到主线程，会回调handleMessage()方法 message.sendToTarget(); return result;&#125; 因为postResult(Result result)还是在子线程中调用的，如果要发送给主线程，必须通过Handler。源码中使用sHandler并带着MESSAGE_POST_RESULT和封装了任务执行结果的对象AsyncTaskResult，然后message.sendToTarget()开始发消息。123456789private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; //初始化一个InternalHandler，用与将结果发送给主线程 sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125; 并在InternalHandler的handleMessage中开始处理消息，InternalHandler的源码如下所示：123456789101112131415161718192021 private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; // 这个handler是关联到主线程的 super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 这里根据消息的类型进行了判断，如果是MESSAGE_POST_RESULT消息，就会去执行finish()方法，finish()源码如下文所示：12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED; &#125; 如果任务已经取消了，调用onCancelled方法，如果没被取消，则调用onPostExecute()方法。 如果doInBackground(Void... params)调用publishProgress()方法，实际就是发送一条MESSAGE_POST_PROGRESS消息，就会去执行onProgressUpdate()方法。publishProgress()的源码如下文所示： 1234567@WorkerThreadprotected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125;&#125; 如果你还不够清晰，请看下面的这个流程图 5. AsyncTask需要注意的坑 AsyncTask的对象必须在主线程中实例化，execute方法也要在主线程调用(查看3.1节-AsyncTask构造函数) 同一个AsyncTask任务只能被执行一次，即只能调用一次execute方法，多次调用时将会抛异常（查看3.2里面的第二小节） cancel()方法无法直接中断子线程，只是更改了中断的标志位。控制异步任务执行结束后不会回调onPostExecute()。正确的取消异步任务要cancel()方法+doInbacground()做判断跳出循环 AsyncTask在Activity通常作为匿名的内部类来使用，如果 AsyncTask 中的异步任务在 Activity 退出时还没执行完或者阻塞了，那么这个保持的外部的 Activity 实例得不到释放（内部类保持隐式外部类的实例的引用），最后导致会引起OOM，解决办法是：在 AsyncTask 使用弱引用外部实例，或者保证在 Activity 退出时，所有的 AsyncTask 已执行完成或被取消 会产生阻塞问题，尤其是单任务顺序执行的情况下，一个任务执行时间过长会阻塞其他任务的执行 不建议使用AsyncTask进行网络操作 AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time, it is highly recommended you use the various APIs。 Android文档中有写到AsyncTask应该处理几秒钟的操作（通常为轻量的本地IO操作），由于网络操作存在不确定性，可能达到几秒以上，所以不建议使用。 6. 版本兼容AsyncTaskCompat有兴趣的可以看这篇文章 7. 总结尽管AsyncTask现在已经很少使用了，但是它的一些设计思路可以借鉴到我们的框架中。比如我们的代码中尽量设计灵活一些，就像AysnTask里面存在串行、并行的操作一样，提供用户同的api，让用户在不同的场景下选择不同的业务逻辑处理。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"AndroidStudio插件大全","date":"2017-07-25T13:30:45.000Z","path":"2017/07/25/AndroidStudio插件大全/","text":"#1.GsonFormat快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。 使用方法：快捷键Alt+S也可以使用Alt+Insert选择GsonFormat 2.Android ButterKnife Zelezny配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。 使用方法：Ctrl+Shift+B选择图上所示选项 3.Android Code Generator根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。 4.Android Parcelable code generatorJavaBean序列化，快速实现Parcelable接口。 5.Android Methods Count显示依赖库中得方法数 6.Lifecycle Sorter可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K 7.CodeGlance在右边可以预览代码，实现快速定位 8.findBugs-IDEA查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…） 9.ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI 10.AndroidPixelDimenGeneratorAndroid Studio自动生成dimen.xml文件插件 11.JsonOnlineViewer在Android Studio中请求、调试接口 12.Android Styler根据xml自动生成style代码的插件 Usage:a. copy lines with future style from your layout.xml fileb. paste it to styles.xml file with Ctrl+Shift+D (or context menu)c. enter name of new style in the modal windowd. your style is prepared! 13.Android Drawable Importer这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片） 14.SelectorChapek for Android通过资源文件命名自动生成Selector文件。 15.GenerateSerialVersionUID实现Serializable序列化bean Adds a new action ‘SerialVersionUID’ in the generate menu (alt + ins). The action adds an serialVersionUID field in the current class or updates it if it already exists, and assigns it the same value the standard ‘serialver’ JDK tool would return. The action is only visible when IDEA is not rebuilding its indexes, the class is serializable and either no serialVersionUID field exists or its value is different from the one the ‘serialver’ tool would return. 16.genymotion速度较快的android模拟器 17.LeakCanary帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。可以参考以下文章：LeakCanary 中文使用说明 18.Android Postfix Completion可根据后缀快速完成代码，这个属于拓展吧，系统已经有这些功能，如sout、notnull等，这个插件在原有的基础上增添了一些新的功能，我更想做的是通过原作者的代码自己定制功能，那就更爽了 19.Android Holo Colors Generator通过自定义Holo主题颜色生成对应的Drawable和布局文件 20.dagger-intellij-plugindagger可视化辅助工具 21.GradleDependenciesHelperPluginmaven gradle 依赖支持自动补全 22.RemoveButterKnifeButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。 具体介绍 23.AndroidProguardPlugin一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全) 24.otto-intellij-pluginotto事件导航工具。 25.eventbus-intellij-plugineventbus导航插件(对于最新版的 EventBus 3.0.0 好像无效,请替换为eventbus3-intellij-plugin此插件地址在本文第51个) 26.idea-markdownmarkdown插件 27.Sexy Editor设置AS代码编辑区的背景图 首先点击界面的设置按钮 进入设置界面，选中Plugins,右边选择 Browser … ，输入Sexy … 下面自动弹出候选插件，右边点击Install 安装安装成功 后需要重启AS重启完成之后 进入设置界面 选择other Setting 下的Sexy Editor ， 右侧 insert 一张或多张图片即可，上面的其他设置可以设置方位 间隔时间 透明度等等，设置完成后，要关闭打开的文件，重新打开项目文件即可在代码编辑区显示插入的图片，作为代码编辑区的背景图。 28.folding-plugin布局文件分组的插件 29.Android-DPI-CalculatorDPI计算插件 使用：或者 30.gradle-retrolambda在java 6 7中使用 lambda表达式插件 修改编译的jdk为java8: 31.Android Studio Prettify可以将代码中的字符串写在string.xml文件中 选中字符串鼠标右键选择图中所示 这个插件还可以自动书写findViewById 32.Material Theme UI添加Material主题到你的AS 33..ignore我们都知道在Git 中想要过滤掉一些不想提交的文件，可以把相应的文件添加到.gitignore 中，而.gitignore 这个Android Studio 插件根据不同的语言来选择模板，就不用自己在费事添加一些文件了，而且还有自动补全功能，过滤文件再也不要复制文件名了。我们做项目的时候，并不是所有文件都是要提交的，比如构建的build 文件夹，本地配置文件，每个Module 生成的iml 文件，但是我们每次add，commit 都会不小心把它们添加上去，而gitignore 就是解决这种痛点的，如果你不想提交的文件，就可以在创建项目的时候将这个文件中添加即可，将一些通用的东西屏蔽掉。 34.CheckStyle-IDEACheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。 35.Markdown Navigatorgithub:Markdown NavigatorMarkdown插件 36.ECTranslationAndroid Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。 37.PermissionsDispatcher plugingithub:PermissionsDispatcher plugin自动生成6.0权限的代码 38.WakaTimegithub:WakaTime记录你在IDE上的工作时间 39.AndroidWiFiADB无线调试应用 40.AndroidLocalizationer可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 41.TranslationPlugin又一翻译插件,可中英互译。 42.SingletonTest快速生成单例模式的预设 43.BorePluginAndroid Studio 自动生成布局代码插件 代码生成规则a.自动遍历目标布局中所有带id的文件, 无id的不会识别处理b.控件生成的变量名默认为id名称, 可以在弹出确认框右侧的名称输入栏中自行修改c.所有的Button或者带clickable=true的控件, 都会自动在代码中生成setOnClickListener相关代码d.所有EditText控件, 都会在代码中生成非空判断代码, 如果为空会提示EditText的hint内容, 如果hint为空则提示xxx字符串不能为空字样, 最后会把所有输入框的验证合并到一个submit方法中e.会自动识别布局中的include标签, 并读取对应布局中的控件 44.jimu Mirror能够实时预览Android布局，它会监听布局文件的改动，如果有代码变化，就会立即刷新UI。 45.jRebel For Android不仅能够做到UI布局的实时预览，它甚至做到了让你更改java代码后就能实时替换apk中的类文件，达到应用实时刷新，官网的介绍是：Skip build, install and run，因此它可以节约我们很多很多的时间，它的效果也十分不错。 46.sdk-manager-pluginSDK管理插件，自动检测更新并下载。(图片与插件无关哈) 47.Codota搜索最好的Android代码。(Studio里面直接可以搜到此插件) 48.LayoutFormatterdrakeet 开发一个一键格式化你的 XML 文件的 Android Studio 插件，至于为什么不用 Android Studio 自带的格式化功能而用这个插件，可以看下作者的一篇 Blog -&gt; 当我们谈 XML 布局文件代码的优雅性 49.android-strings-search-plugin一个可以通过输入文字找到strings.xml资源的插件 50.ideaVimvim 本身就是一款很优秀的文本编辑器，而Android Studio 更是一款编写APP应用的神器。如果两个款优秀的软件结合在一起感觉会怎样呢？详细请看文章:Android Studio ＋Vim 51.eventbus3-intellij-plugin引导 EventBus 的 post 和 event(对于最新版的 EventBus 3.0.0 有效)主要Bug修复工作：修改包名和方法名以适应 EventBus 3.X替换一个在新版的 intellij plugin SDK 已经不存在的类增加若干 try-catch ，防止插件崩溃 52.ExynapExynap 一个帮助开发者自动生成样板代码的 AndroidStudio 插件 53.gradle-cleaner-intellij-pluginForce clear delaying &amp; no longer needed Gradle tasks. 54.MVPHelper一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。具体请查看Android Studio插件之MVPHelper，一键生成MVP代码一文 如果还有更好玩更好用的插件欢迎fork + pull request 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"Android进阶资料大全","date":"2017-07-22T09:29:25.000Z","path":"2017/07/22/Android进阶资料大全/","text":"目录 书籍 开发环境/工具 博客 社区 开源项目学习 Android 开发者杂志周刊 Awesome 系列 动画系列 Material Design 设计 素材 开源库收集 设计模式 实践篇 Git 教程 文档 其它资料收集 知乎上的讨论 贡献者 License ============================================================= 书籍 书籍名称 推荐理由 Thinking In Java 中文版 学习 Android 开发, 首先需要 Java 基础, 这里推荐 Thinking In Java, Thinking In Java 是 Java 的经典书籍, 是学习 Java 语言必备书籍 第一行代码 郭霖大神的杰作, 郭神在CSDN中的博客文章非常不错, 书我看了, 非常适合新手, 里面的内容非常棒, 建议结合郭神博客文章一起来学习 疯狂Android讲义第三版 作者是李刚, 这本书是基于 Android 5.0 来讲的, 我看过第二版, 这本书给我第一感觉就是很厚, 但里面内容写的还是很详细的, 代码很多, 可以跟着代码一步步敲 Android群英传 本书作者 @Tomcat 的猫, 曾就职于上海 TCL 通讯, 从事 Alcatel(阿尔卡特) Android 手机系统的定制工作, 活跃于 CSDN, 目前就职于上海沪江网 Android 开发部RD项目组, 负责沪江 App 的功能预研 Android开发艺术探索 由@任玉刚Coder所著, 是一本 Android 进阶类书籍, 采用理论, 源码和实践相结合的方式来阐述高水准的 Android 应用开发要点. 本书从三个方面来组织内容: 第一, 介绍 Android 开发者不容易掌握的一些知识点: 第二,结合Android源代码和应用层开发过程, 融会贯通, 介绍一些比较深入的知识点: 第三, 介绍一些核心技术和Android的性能优化思想. App 研发录 本书作者是包建强, 本书是作者多年 App 开发的经验总结, 从 App 架构的角度, 重点总结了 Android 应用开发中常见的实用技巧和疑难问题解决方法, 为打造高质量 App 提供有价值的实践指导, 迅速提升应用开发能力和解决疑难问题的能力. 这本书非常有利于 Android 开发者进阶. Android 设计模式源码分析 本书作者是开发技术前线创立者之一 Mr.Simple, 该书从 Android 源码的角度由浅入深地剖析设计模式的运用, 让工程师们把设计与模式重视起来, 提升自己的设计能力与代码质量 开发环境/工具(附上: 由 @脉脉不得语 收集维护超多开发工具下载地址 AndroidDevTools, 后五个工具资料在 stormzhang 博客中找到的,地址) 环境/工具 简述 Android Studio 这个开发工具上手需要一定的时间, 自从 Google 推出1.0正式版, 这个工具一直火爆, 目前 github 上面的绝大多数开源项目都是使用 Android Studio 工具, 这就是 Android 开发工具的未来, 所以极力推荐 Android 开发人员使用这个工具, 该工具已更新到 2.0 预览版, 性能逐渐稳定提高, 没有之前那么卡了 Genymotion 强大好用高性能的 Android 模拟器, 自带的那个模拟器简直不忍直视, 启动超慢的, 跟这个没法比, 无论你是用 Eclipse 还是 Android Studio 里面都有 Genymotion 插件 jadx 一个 Android 反编译神器, 不同于常见的 dex2jar, 这个反编译器生成代码的 try/catch 次数更少, View也不再是数字 id 了, 可读性更高 android-selector 可以根据指定颜色生成 Selector Drawable 的插件 GradleDependenciesHelperPlugin Gradle 依赖自动补全插件 Smali Viewer sv 是一款免费 APK 分析软件, 对你感兴趣的 APP 分析看看它们都用了些什么, 对你学习借鉴有一定帮助 folding-plugin layout 文件夹里的布局文件一般很长很长没有目录, 这个插件就可以把 layout 分好层级结构, 类似 src 下目录结构 CodeGlance 在编辑代码最右侧, 显示一块代码小地图 Statistic 统计整个项目行数的插件, 这可表示我们日日夜夜辛辛苦苦必备插件 idea-markdown 在 AS 中编写 Markdown 文件, 可以直接预览网页显示效果, 对于你经常编写 Markdown 文件的你值得拥有这个插件 Stetho Stetho 是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools 查看 App 的布局, 网络请求(仅限使用 Volley, okhttp 的网络请求库), sqlite, preference, 一切都是可视化的操作,无须自己在去使用 adb, 也不需要 root 你的设备 ClassyShark ClassyShark 是 Google 发布的一款可以查看 Android 可执行文件的浏览工具, 支持.dex, .aar, .so, .apk, .jar, .class, .xml 等文件格式, 分析里面的内容包括 classes.dex 文件, 包方法数量, 类, 字符串, 使用的 NativeLibrary 等 AndroidWiFiADB 使用 WiFi 连接而不需要 USB 连接 Android 设备达到安装, 运行, 调试应用的目的 checkstyle-idea Checkstyle-idea 是一款检查自己写的代码是否符合规范的插件, 该插件是根据 checkstyle.xml 文件来检查的, checkstyle.xml 文件可以由自己自己定义, 也可以使用一些大公司定义的规范, 如果不懂得如何定义, 可以查看 官方文档, 该插件的详细介绍以及使用, 可以看一下咕咚大侠写的 文章 ECTranslation ECTranslation 是 Android Studio 开发工具的一个翻译插件, 可以将英文翻译为中文, 英语基础差的童鞋装上它就可以轻松阅读 Android 源码啦 Android Methods Count 统计 Android 依赖库中方法的总个数, 避免应用方法数超过 65K 问题 AndroidLocalizationer 可用于将项目中的 string 资源自动翻译为其他语言的插件, 其翻译支持使用 Microsoft Translator 或 Google Translation ButterKnife Zelezny ButterKnife 生成器, 使用起来非常简单方便, 为你简写了很多 findViewId 代码, 如果你不了解 ButterKnife 的可以到这里看看 SelectorChapek 设计师给我们提供好了各种资源, 每个按钮都要写一个selector是不是很麻烦? 这么这个插件就为解决这个问题而生, 你只需要做的是告诉设计师们按照规范命名就好了, 其他一键搞定 GsonFormat 现在大多数服务端 api 都以 json 数据格式返回, 而客户端需要根据 api 接口生成相应的实体类, 这个插件把这个过程自动化了, 赶紧使用起来吧 ParcelableGenerator Android中的序列化有两种方式, 分别是实现 Serializable 接口和 Parcelable 接口, 但在 Android 中是推荐使用 Parcelable, 只不过我们这种方式要比Serializable方式要繁琐, 那么有了这个插件一切就ok了 LeakCanary 良心企业 Square 最近刚开源的一个非常有用的工具, 强烈推荐, 帮助你在开发阶段方便的检测出内存泄露的问题, 使用起来更简单方便, 而且我们团队第一时间使用帮助我们发现了不少问题, 英文不好的这里有雷锋同志翻译的中文版 LeakCanary 中文使用说明 更多 该作者收集整理了 40 个插件, 可以说是史上最全的了 博客 博客地址 博主信息 Android Developers Blog Android官网博客, 在上面可以关注 Android 最新的进展与最权威的博客(需翻墙) stormzhang 博主是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 Android学习之路 帮助了无数人, 里面还有很多好的文章非常适合新手入门, 并且是微信公众号「AndroidDeveloper」的运营者, 可以算是 Android 界最有影响力的公众号之一了, 强烈推荐关注 胡凯 目前就职于腾讯上海从事 Android 开发的工作, 发起 Google Android 官方培训课程中文版翻译, 这课程是学习 Android 应用开发的绝佳资料 Trinea 目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库上面都有, 并且发起 Android 开源项目源码解析, 在使用开源库的同时也可以知道其中原理, 大家可以去关注一下, 地址 郭霖 博主郭霖是大神, 人人都称”郭神”, 是第一行代码的作者, 博主在 CSDN 上所写的文章都非常值得学习 代码家 90后 Android 大神, 称作库达人, 博主收集了很多 Android 开源库, 博主自己也做了很多开源库, 非常值得学习 light_sky Android 开发工程师, 目前在北京工作. Google big fan, 热爱开源, 热爱分享, 活跃于 GitHub, G+, Twitter, 捕捉Android最新资讯和技术, ViewPagerIndicator 开源项目分析者 张鸿洋 张鴻洋是 CSDN 博客专家, 博主在 CSDN 所发布的每一篇文章都是干货, 都很值得大家去学习 张兴业 张兴业同样也是 CSDN 博客专家, 博主专注移动互联网开发, 关注移动支付业务 hi大头鬼hi hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 擅长 Android, RxJava, RxAndroid, ReactNative, Node.js, 大前端, 可谓是全栈工程师, 如果你对 RxJava 技术感兴趣, 不妨到他的博客看看, 他写了一系列有关 RxJava 的介绍 更多 这里面收集了很多国内外开发者的信息, 大家可以去看看 社区 名称 简介 StackOverFlow IT 界的问答社区, 你开发当中所遇到的问题基本上都能在这里能寻找到你想要的答案 SegmentFault SegmentFault 是一个专注于解决编程问题, 提高开发技能的社区 CSDN CSDN 是全球最大中文IT技术社区 稀土掘金 高质量的技术分享社区 谷歌开发者社区(GDG) GDG 是 Google Developer Groups 的缩写, 中文名称是谷歌开发者社区 开源项目学习 项目名称 项目简介 Google I/O 2014 Google I/O Android App 使用了当时最新推出的 Material Design 设计 Google play music 一个跨多个平台音乐播放器 Google Santa Tracker for Android Google 开源的一个儿童教育和娱乐的 App github客户端 开源者 github 团队, 支持项目的 lssues 和 Gists 并集成了新闻 feed 以便及时获取来自组织好友和资料库的更新信息, 还提供了一个用于快速访问你创建,监控以及发布 issue 面板, 可查看并将问题加到收藏夹 Talon-for-Twitter 一个完整版 Twitter 第三方客户端, 属于顶级水平, 而且在源代码 100% 开源, 学习资源让你取之不尽 Anime Taste 开发者是代码家为 AnimeTaste 全球动画精选开发的 Android 客户端, 国内很少见的精彩而且开源的 APP, 获得豌豆荚110期设计奖 EverMemo 开发者是代码家, EverMemo 是一款让你快速记录与分享灵感的随身便签, 极简的界面与卡片式布局, 让你记录与查找便签更有效率 9GAG 开发者是 stormzhang 博主,这个开源项目教你使用 Studio, Gradle 以及一些流行的开源库快速开发一个不错的 Android 客户端 MIUI 便签 MiCode 便签是小米便签的社区开源版, 由 MIUI 团队（ww.miui.com）发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议 贝壳单词 开发者是许晓峰(Drakeet), 获得豌豆荚设计奖, 这个是初期版本, 新版没有开源, 但是在博主的博客当中将一些新版的内容都剥离出来写成了文章,可以去学习一下 Muzei Live Wallpaper 开发者是 Ian Lake , 就职于 Google, 这款是定时更换桌面精美壁纸 App 四次元-新浪微博客户端 一个仿新浪微博客户端 App, 基本都含有新浪微博的功能, 开源团队写了一份 wiki 文档, 可以去学习一下该 App 是如何实现的 知乎专栏 开发者是白瓦力, 项目结构清晰, 代码分包合理, 很棒. 很适合新手去学习如何搭建一个 App 结构, 熟悉开发一个完整 App 的流程 eoe 客户端 eoe 社区Android客户端 oschina 开源中国社区 Android 客户端, 此开源的是 v1 版本, v2 版本将在 2015 年年中开源 v2ex 开发者是杨辉, 这个是 v2ex Android 第三方客户端 Tweet Lanes 功能比较完整的 Twitter 客户端 Financius 一款简单易用个人理财 Android 程序 Coding Coding 类似于 github 一个代码托管平台, 这个是 Coding 的 Android 版客户端 ZXing 二维码扫描工具,市场上许多应用的二维码扫描工具都是从这个修改得到的 photup 编辑机批量上传照片到 facebook 上,代码分包合理,很棒,不过这个项目依赖的开源项目比较多, 比较难编译 todo.txt-android todo.txt 官方 Android 应用, 一个极简的将待办事件记录在 .txt 文件中 扫扫图书 一个让你懂得如何去选择一本书的 APP, 具有扫描搜索查询图书的信息功能 ChaseWhisplyProject 开启摄像头在你所在位置寻找鬼魂, 进行打鬼游戏 AntennaPod AntennaPod 是一个自由, 开源的播客客户端, 支持 Atom 和 RSS Feed 干柴 开发者是冯建, 一个专注收集 android 相关干货(文摘,名博,github等等)资源 App Hacker News 一个查看黑客新闻报道和评论的 App proxydroid ProxyDroid 是一个帮助你在你的 Android 设备上设置代理 (HTTP / SOCKS4 / SOCKS5) AliGesture Android平台手势识别应用, 简单的手势就可以进入预置的应用, 方便快捷 指读 指读顾名思义就是用手指去阅读浩瀚的书海 KJ 音乐 开发者是张涛, 快捷音乐使用到KJFrameForAndroid开发框架, 拥有界面绚丽, 操作简单, 播放手机本地音乐, 在线收听音乐等功能, 还支持: 新浪微博, 百度账号, QQ 账号的一键登录 哎嘛 OSCHINA 第三方客户端, 这个版本界面比官方版本界面好看多了, 使用的是 Material Design, 界面看上去非常清爽舒服 码厩 博客园第三方客户端, 使用到缓存技术, 当你打开一次之后的博客内容, 会自动保存到设备中, 下次打开阅读同一文章时不需要再利用网络加载, 大家如果想为自己 App 搞缓存的, 可以研究一下该 App 是如何实现的喔 cnBeta 第三方阅读器 该 App 是 cnBeta(中文业界资讯站) 第三方阅读客户端, 界面也是使用 Material Design, 还加上一些动画效果, 让人阅读文章起来不会感觉枯燥, 值得去研究学习一下 BlackLight BlackLight是由纸飞机开发团队开发的一款Android上的新浪微博第三方轻量级客户端 Actor Actor(优聆) 是一款即时通讯 App, 解决网络通讯差的情况, 支持离线消息和文件存储, 自动与手机联系人建立联系等等 Plaid 一个遵循 Material Design 的一个设计新闻客户端，里面的一些完全MD的一些特效很棒，同时整个客户端的框架设计也很有参考意义 SimplifyReader 一款基于 Google Material Design 设计开发的 Android 客户端, 包括新闻简读, 图片浏览, 视频爽看, 音乐轻听以及二维码扫描五个子模块, 项目采取的是MVP架构开发 PHPHub-Android PHPHub Android 客户端, 项目架构使用 nucleus 简化 MVP 架构, API 请求返回数据使用 RxJava 进行处理, 客户端使用了独特的二维码扫码登录, 有兴趣的可以去研究一下 Leisure 闲暇(Leisure)是一款集”知乎日报”, “果壳科学人”, “新华网新闻”以及”豆瓣图书”于一体的阅读类 Android 应用, 项目里面有多语言切换、夜间模式以及无图模式, 如果你还不知道这些技术怎么实现, 不妨参考一下这个项目 Meizhi 开发者是许晓峰(Drakeet), 该 app 是数据来自代码家干货网站 gank.io, 有很多开发者都纷纷为这网站做客户端 app, 因为代码家大神开放该网站的 Api, 更重要的是该网站每天除了有干货还有漂亮妹子看呢, 该 App 使用到的技术有 RxJava + Retrofit, 代码结构非常清晰, 值得一看的开源 App. Bingo 开发者是孙福生, Bingo 是一款 IT 阅读学习类的开源软件, 作者收集一些干货学习内容, 你也可以在 App 上分享你的认为干货文章, 该项目使用动态代理 AOP 编程框架, 使开发起来更简洁, 更高效. 里面有一个功能就是多种主题切换, 感兴趣的可以看看怎么实现 Android 开发者杂志周刊( 前五个资料来自 Drakeet 收集整理的, 资料原链接 地址 ) 周刊名 周刊简介 Android Weekly Android Weekly 是由Android 团队的成员和国外知名的 Android 开发者维护, 分享的内容不仅仅只有干货, 而且还有最新的技术分享, 也是Android 开发圈子最早, 最有名的周报 Android 开发技术周报 Android 开发技术周报是由@脉脉不嘚語 维护更新, 截止到现在, 已经发布了28 期, 分享的都是高质量的文章教程, 代码库, 工具, 新闻视频, 设计等 Android 科学院 由 @duguguiyu和豌豆荚一小撮工程师组成, 分享的都是最新的 Android 技术: 虽然更新频率不是很高, 但是质量确是很高的, 值得一看的 开发技术前线 开发技术前线是一个高质量技术文章的聚合网站, 主要分享 Android, iOS, 以及招聘等内容 App 开发日报 App 开发日报主要关注移动应用的开发, 它每天一刊, 分享的内容主要来自微博上知名的开发者推荐的内容, 因此质量基本上是有保证的 Android 开发周报 Android 开发周报是郭亮在连载更新在 Infoq 的周刊, 它不仅分享 Android 的相关新闻, 新工具, 而且还有更加深入的, 所以对于新生老人都很适合 干货集中营 由 代码家 维护更新, 周一到周五每天中午分享, 分享内容有漂亮妹子, Android 干货, iOS 干货, App, 技术以外推荐, 还有休息视频 Android Blog 周刊 AndroidBlog 是由 Jomeslu 收录的, 目前就职于搜狐, 该周刊分享内容主要有一周国内外热门技术博客, 优秀的类库, 以及一些有趣的新闻, 看了前几期分享的内容质量都是很高的, 因此值得推荐给大家 Awesome 系列 awesome android(1) awesome_android(2) awesome_android_UI awesome_android_libraries awesome_java awesome_materialdesign awesome 系列之终极版 android-dynamic-load-awesome 动画系列 animate awesome-animation Material-Animations AndroidViewAnimations Material Design 设计 Material Design 教程 Material Design 教程(中文版) Material Design Android Library (Material Design 开源库, 很多效果可以直接拿来用) 十大Material Design开源项目 素材 常用色彩搭配表 ColorHunt-色彩搭配 在线 Material Design 界面调色板 Material Design设计模板与素材 App Icon 图标 Icon Store Material icons Iconfont 开源库收集 Android Libraries and Resources Android Arsenal (一个专门收集 android 开源库的网站, 网站经常更新) Android 开源项目汇总 (Trinea 大神收集的) Android 开源项目源码分析 (在懂得使用这些开源项目同时, 也应该了解当中的原理) 泡在网上的日子 android-gems(国内外很多开发者都在这里上传他们最新的项目, 还带有 apk 下载) 设计模式 java-design-patterns Android源码设计模式分析项目 Java之美[从菜鸟到高手演变]之设计模式 实践篇 Android 开发最佳实践 Android 开发最佳实践 (来自胡凯总结) Android 最佳实践之 UI 篇 Android 屏幕适配全攻略 给半新人的app开发指南 Android 一些重要知识点解析整理 Android 开发人员应避免的 10 个误区 Java 反射最佳实践 Android 内存优化之 OOM Android 命名规范 Adapter 优化方案的探索 Android-Tips 最全 Android ADB Shell AndroidNote Android 常用工具类 创建安卓 app 的 30 个经验教训 Android 三大图片缓存原理、特性对比 Android 性能优化总结 Android 实用代码片段整合 36 个 Android 开发常用代码片段 收集了大家常用的一些 Android 的模板代码 Android 技术积累: 开发规范 App 架构设计经验谈 关于 Android 开发的 40 条优化建议 如何提高安卓代码的质量和语法 我的 Android 开发实战经验总结 Android Tips 系列 如何自学 Android 国内一线互联网公司内部面试题库 Git 教程新手看完这几份教程基本上知道怎么使用 Git 了 GitHub 团队美女写的一套 Git 使用教程 ProGit 中文版 廖雪峰的 Git 教程 Git 简易指南 文档 Android 官方 API 文档(网站需要翻墙，不翻墙可以下载离线文件) Android 官方培训课程中文版(由胡凯发起对 Google Android 官方培训课程翻译的中文版) 其它资料收集 10 个很棒的学习 Android 开发的网站 Android 开发, 你应该知道的学习资源 AndroidCat 安卓书签网 每个 Android 开发者都应该了解的资源列表 Android 开发者网址导航 Android 开发收藏夹 TimLiu-Android(TimLiu 总结的 Android 开源项目及库) AndroidTips 知乎上的讨论 有哪些 Android 大牛的 blog 值得推荐? GitHub 上都有哪些值得关注学习的 Android项目? GitHub 上有哪些适合新人围观的 Android 项目? 2015 年移动设备界面设计有哪些趋势? Android开发中, 有哪些让你觉得相见恨晚的方法,类或接口? Android Studio有哪些非常好用的插件? Android 开发有哪些新技术出现? 有哪些优秀的 Android 应用开源项目, 特效, 设计资料推荐? 有没有适合 Android 开发初学者的 App 源码推荐? Android有什么好的技术点适合进行技术分享? Android Studio有什么奇技淫巧? Android 开发: 开始一个项目前, 做好哪些准备可以事半功倍? 贡献者点击该链接查看该项目所有贡献者 License以上内容采用 CC BY-NC-SA 3.0 进行许可, 转载请注明出处, 版权归本人及所有贡献者所有 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"String、StringBuffer、StringBuilder的区别","date":"2017-07-06T15:45:01.000Z","path":"2017/07/06/String、StringBuffer、StringBuilder的区别/","text":"一、区别String ：字符串常量StringBuffer ：字符串变量StringBuilder ：字符串变量 二、速度StringBuilder &gt; StringBuffer &gt; String 分析原因： String类是不可变类，任何对String的改变都 会引发新的String对象的生成； String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String。 而StringBuffer与StringBuilder就不一样了，他们是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，这样就不会像String一样创建一些而外的对象进行操作了，当然速度就快了。 又因为StringBuilder是线程不安全的，StringBuffer是线程安全的，所以StringBuilder比StringBuffer要快。 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"}]},{"title":"Kotlin","date":"2017-06-23T12:13:26.000Z","path":"2017/06/23/Kotlin/","text":"项目地址：https://github.com/JetBrains/kotlin 简介：Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。[2]2012年1月，著名期刊《Dr. Dobb’s Journal（英语：Dr. Dobb’s Journal）》中Kotlin被认定为该月的最佳语言。[3]虽然与Java语法并不兼容，但Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java类库。 更多：The Kotlin Programming Language http://kotlinlang.org/ Kotlin Programming LanguageWelcome to Kotlin! Some handy links: Kotlin Site Getting Started Guide Try Kotlin Kotlin Standard Library Issue Tracker Forum Kotlin Blog Follow Kotlin on Twitter Public Slack channel TeamCity CI build Editing Kotlin Kotlin IntelliJ IDEA Plugin Kotlin Eclipse Plugin Kotlin TextMate Bundle Build environment requirementsIn order to build Kotlin distribution you need to have: Apache Ant 1.9.4 and higher JDK 1.6, 1.7 and 1.8 Setup environment variables as following: JAVA_HOME=&quot;path to JDK 1.8&quot; JDK_16=&quot;path to JDK 1.6&quot; JDK_17=&quot;path to JDK 1.7&quot; JDK_18=&quot;path to JDK 1.8&quot; BuildingTo build this project, first time you try to build you need to run this: ant -f update_dependencies.xml which will setup the dependencies on intellij-core is a part of command line compiler and contains only necessary APIs. idea-full is a full blown IntelliJ IDEA Community Edition to be used in the plugin module. Then, you need to run ant -f build.xml which will build the binaries of the compiler and put them into the dist directory. You may need to increase the heap size for Ant usingANT_OPTS. OPTIONAL: Maven artifact distribution is built separately, go into libraries directory after building the compiler and run: ./gradlew build install mvn install Note: on Windows type gradlew without the leading ./ Refer to libraries/ReadMe.md for details. Working with the project in IntelliJ IDEAThe root kotlin project already has an IntelliJ IDEA project, you can just open it in IntelliJ IDEA. You may need to set the Project SDK (File -&gt; Project Structure -&gt; Project).You may also need to add tools.jar to your SDK: File -&gt; Project Structure -&gt; SDKs -&gt; &lt;Your JDK&gt; -&gt; Classpath then choose the tools.jar in the JDK’s lib directory. If you are not dealing with Android, you may need to disable the Android Plugin in order to compile the project. Installing the latest Kotlin pluginSince Kotlin project contains code written in Kotlin itself, you will also need a Kotlin plugin to build the project in IntelliJ IDEA. You probably want to have locally the same version of plugin that build server is using for building.As this version is constantly moving, the best way to always be updated is to let IntelliJ IDEA notify you when it is time to renew your plugin. To keep the plugin version in sync with the rest of the team and our Continuous Integration serveryou should setup IDEA to update the plugin directly from the build server. Open: Preferences -&gt; Plugins -&gt; Browse Repositories -&gt; Manage Repositories... and add the following URL to your repositories: https://teamcity.jetbrains.com/guestAuth/repository/download/bt345/bootstrap.tcbuildtag/updatePlugins.xml Then update the list of plugins in “Browse Repositories”, you’ll see two versions of Kotlin there, install the one with the higher version number. If you want to keep an IntelliJ IDEA installation with that bleeding edge Kotlin plugin for working Kotlin project sources only separate to your default IntelliJ IDEA installation with the stable Kotlinplugin see this document, which describes how to have multiple IntelliJ IDEA installations using different configurations and plugin directories. Compiling and runningFrom this root project there are Run/Debug Configurations for running IDEA or the Compiler Tests for example; so if you want to try out the latest and greatest IDEA plugin VCS -&gt; Git -&gt; Pull Run IntelliJ IDEA a child IntelliJ IDEA with the Kotlin plugin will then startup you can now open the kotlin libraries project to then work with the various kotlin libraries etc. ContributingWe love contributions! There’s lots to do on Kotlin and on thestandard library) so why not chat with usabout what you’re interested in doing? Please join the #kontributors channel in our Slack chatand let us know about your plans. If you want to find some issues to start off with, try this query which should find all Kotlin issues that marked as “up-for-grabs”. Currently only committers can assign issues to themselves so just add a comment if you’re starting work on it. A nice gentle way to contribute would be to review the standard library docsand find classes or functions which are not documented very well and submit a patch. In particular it’d be great if all functions included a nice example of how to use it such as for thehashMapOf() function.This is implemented using the @samplemacro to include code from a test function. The benefits of this approach are twofold; First, the API’s documentation is improved via beneficial examples that help new users and second, the code coverage is increased. Also the JavaScript translation could really use your help. See the JavaScript contribution section for more details. If you want to work on the compilerThe Kotlin compiler is written in Java and Kotlin (we gradually migrate more and more of it to pure Kotlin). So the easiest way to work on the compiler or IntelliJ IDEA plugin is download a recent IntelliJ IDEA, Community edition is enough install the Kotlin plugin open the root kotlin project in IDEA (opening the kotlin directory) You can now run the various Run/Debug Configurations such as IDEA All Compiler Tests All IDEA Plugin Tests If you want to work on the Kotlin libraries download a recent IntelliJ IDEA, Community edition is enough install the Kotlin plugin open the kotlin libraries project Then build via cd libraries ./gradlew build install mvn install Note: on Windows type gradlew without the leading ./ Some of the code in the standard library is created by generating code from templates. See the README in the stdlib section for how run the code generator. The existing templates can be used as examples for creating new ones. Submitting patchesThe best way to submit a patch is to fork the project on github then send us apull request via github. If you create your own fork, it might help to enable rebase by defaultwhen you pull by executing1git config --global pull.rebase true This will avoid your local repo having too many merge commitswhich will help keep your pull request simple and easy to apply. Commit commentsIf you include in your comment this text (where KT-1234 is the Issue ID in the Issue Tracker, the issue will get automatically marked as fixed. #KT-1234 Fixed 如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1.2 is out","date":"2017-04-25T13:19:00.000Z","path":"2017/04/25/Kotlin 1.1.2 is out/","text":"我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了与Android Gradle插件版本2.4.0-alpha的兼容性。本次发布版本的所有更新可在更新日志中查看。在这里要感谢所有外部的贡献者，他们提交的pull request也包含于该版本中：Yoshinori Isogai，Jonathan Leitschuh和Kirill Rakhman 。感谢所有尝试EAP构建并向我们发送反馈意见的人！ 迁移说明Kotlin编译器现在也需要基于JDK 8运行。但您应该不需要在意这一点改变，因为大多数其他Java开发工具（比如Gradle和Android工具）也需要JDK 8，因此您肯定已经安装了JDK 8。对于由编译器生成的代码，仍然默认兼容Java 1.6，而且我们也没有计划要放弃对生成的Java 1.6兼容性字节码的支持。 内部类当中不能再声明 object，因为这个 object 将能够访问外部类的实例，我们知道 object 始终是一个单例，因此这在理论上是行不通的。同样的，内部密封类也是不被允许的。然而这只是临时方案，在我们添加了在其外部类而非内部类中声明内部密封类的子类的可能性时，将会删除该限制。(KT-16232，KT-16233） 现在使用一个名称完全由下划线字符组成的声明时将必须使用反引号。(KT-16264） Maven增量编译从Kotlin 1.1.2开始，以前用于IntelliJ IDEA和Gradle构建的增量编译现在也支持Maven。启用该功能时，需要使用-D命令行参数或proterties标记设置kotlin.compiler.incremental属性为true： 123&lt;properties&gt; &lt;kotlin.compiler.incremental&gt;true&lt;/kotlin.compiler.incremental&gt;&lt;/properties&gt; Maven注解处理现在可以从Maven构建中调用Kotlin的注解处理工具kapt了，只需要在compile前，从kotlin-maven-plugin中添加kapt的执行目标： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Specify your annotation processors here. --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 在这里查看具有Java-Kotlin代码支持和测试的POM文件完整示例。 请注意，IntelliJ IDEA自己的构建系统仍然不支持kapt。当您要重新运行注解处理时，需要从“Maven Projects”工具栏中启动构建。 内联方法重构我们终于在Kotlin代码中实现了Inline方法（Function）的支持。 其他IDE改进在1.1.x时间范围内，我们很大一部分的工作是致力于提高IntelliJ IDEA插件的性能。在此次发布的1.1.2版本中，我们对几项主要性能进行了改进，主要涉及输入响应，同时我们也已经为后续1.1.3版本进行了额外的重大改进。 除此之外，我们还在此版本中进行了大量新的检测，快速解决方案和小型IDE功能。特别值得一提的是，在编辑器中支持折叠Android String资源引用，以及新的用于处理Android API版本问题的问题解决方案。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们来吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event Report","date":"2017-04-06T15:21:00.000Z","path":"2017/04/06/Kotlin 1.1 Event Report/","text":"Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;A 环节获得他们关心的问题的答案。这激发了许多当地社区组织见面会：超过 30 个用户组在 21 个国家举办了线下活动。你可以在这里找到完整的活动列表 Kotlin社区网页 。活动当天有 3000 多人参加了线上直播。演示和 Q&amp;A 视频可以在 YouTube 上查看： Kotlin 1.1 活动反馈如果你看了直播，我们想知道你的想法！请 填写此表格 分享您的反馈。它只需要大约7-10分钟。您的投入对于帮助我们改进未来的 Kotlin 活动非常重要。 Kotlin 未来特性调查 我们还向所有社区提供了对 Kotlin 未来的影响。活动组织者收到了调查表，活动参与者可以在线下对最期望的功能发表看法。调查得到很多关注，我们现在已经把它放在网上，以听取更广泛的社区建议。现在你可以在线给 Kotlin 的未来提供你的建议 ！请注意，你在 v1.2 中有很大可能看不到这些功能，但我们会在确定工作优先级时考虑您的意见。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 也适用于 Android 开发者","date":"2017-04-05T08:13:00.000Z","path":"2017/04/05/Kotlin 1.1 is also for Android Developers/","text":"Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。 但有些新功能，如 coroutine 和 type alias（下文有几个例子）对于 Android 开发者来说就像科幻小说。 我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。 所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！ 所有新特性仍然兼容 Java 6 为 Android 开发者所用。 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。 type alias 使你的 listener 更易读当然 type alias 有很多不同的应用场景，不过我首先想到的是使用 lambda 作为 listener 的类型时会使代码更易读。 如果没接触过 type alias 的话，可以简单的理解为给复杂的类型名起个别名，使其更为可读。 例如你有个接收 listener 的 RecyclerViewAdapter。RecyclerView 没有 ListView 那样 标准的方式来处理条目点击事件，必须由开发者自己实现。 假如我们希望有一个可以访问 view 的 listener，那 adapter 可能如下所示： 123class MyAdapter(val items: List&lt;Item&gt;, val listener: (View) -&gt; Unit) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; ...&#125; 而你的 ViewHolder 可能需要接收该 listener，才能将其分配给 view： 12345class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; fun bind(item: Item, listener: (View) -&gt; Unit) &#123; itemView.setOnClickListener(listener) &#125;&#125; 这不是一个复杂的例子，但是正如你所看到的我们需要重复定义这个 lambda ，会导致这段代码不太好阅读。 但是现在我们可以创建一个代表点击 listener 的 type alias：typealias ClickListener = (View) -&gt; Unit然后在需要的每一个地方使用它：class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener)或者fun bind(item: Item, listener: ClickListener) { ... } data class 更强大了data class 可以为我们避免大量的样板代码，但是它不能继承其它类所以某些情况下不可用。 Kotlin 1.1 取消了这个限制，例如 data class 可以定义为 sealed class 的子类了： 12345sealed class UiOp &#123; object Show : UiOp() object Hide : UiOp() data class Translate(val axis: Axis, val amount: Int): UiOp()&#125; 同时 sealed class 可以在父类之外定义，就像这样的： 1234sealed class UiOpobject Show : UiOp()object Hide : UiOp()data class Translate(val axis: Axis, val amount: Int) : UiOp() 在 lambda 中使用 destructuring从 Kotlin 最早的版本开始 data class 就能够使用 destructuring declarations 了，因为它会自动生成 componentX() 方法，借助这些方法可以将 data class 对象拆分成若干变量，如下所示： 123data class Item(val text: String, val url: String) val (text, url) = item 可是在 Kotlin 1.1 之前你并不能在 lambda 上这么做。不过等待结束了！现在可以这么写： 1234fun bind(item: Item) = item.let &#123; (text, url) -&gt; textView.text = text imageView.loadUrl(url)&#125; 这个改进十分适用于操作 Pair 和 Map 等类型的对象 适用与局部变量的 delegated propertydelegated property 已被证明是非常有用的，可以为类中的 property 提供附加的能力。 例如最有用的一个是 lazy property，它会推迟赋值操作，直到变量第一次使用。 但其实 lazy 对于局部变量来说也是十分有用的，而之前 Kotlin 缺乏这个功能。 现在通过 delegated property，我们可以做到： 12345678910fun testLocalDelegation() &#123; val database by lazy &#123; createDatabase() &#125; val cache by lazy &#123; createMemoryCache() &#125; if (mustUseDatabase()) &#123; database.use &#123; ... &#125; &#125; else &#123; cache.use &#123; ... &#125; &#125;&#125; 虽然这个例子可以在没有使用 lazy 的情况下解决，但它有助于理解这个概念。 有一些占用比较多的对象不一定会被使用，可以通过使用 lazy 延迟实例化，直到我们初次使用它。 这时大括号内的代码会被执行，并且将结果缓存下来以备稍后再次使用。 再也不用在 lambda 中定义未使用的变量了在 lambda 中定义了变量但最终没使用情况很常见。 这是因为在 Kotlin 1.0 中没有办法丢弃 lambda 中未使用的参数。 例如使用 delegated property 更新 RecyclerView adapter，我使用了以下代码： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; prop, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; prop 变量从未被使用过，这时我们就可以使用下划线来替换它： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; _, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 还有种更糟的情况，如果 lambda 有多个参数，即使你一个也不用还是需要写上所有参数。现在我们可以忽略它们了： 1234var items: List&lt;Item&gt; by Delegates.observable(emptyList()) &#123; _, _, _ -&gt; notifyDataSetChanged()&#125; 不仅可以定义较少的变量，而且代码还变得更易读了，那些有用的变量一眼就能看到。 Coroutinecoroutine 是 Kotlin 1.1 中最令人兴奋的特性。尽管在此版本中带着“实验性”的标签，但 coroutine 功能齐全，你完全可以开始在项目中使用它们。 coroutine 能让你以同步的方式编写异步代码，允许你在某些时候暂停执行并等待结果，同时写下顺序相连代码。 您可能已经知道在 Kotlin 中 coroutine 并不是指一个库或者具体的实现，而是一种能力，通过它能够创建具有 coroutine 特性的库。 因此尽管某些代码看起来可能相似，但重要的是要知道创建这些辅助线程并返回主线程的“齿轮”是什么，这在 Android 中非常重要。 幸运的是 Kotlin 社区的动作很快，已经有几个库引入了 coroutine 方便我们在 Android 上使用。 首先来看看 Jetbrains 官方提供的： kotlinx-coroutines-android 提供了在 Android 上使用 coroutine 的实现。 Anko 在其最新的 beta 版中改写了部分框架引入 coroutine。 还有许多其他第三方库实现了自己的 coroutine 版本： AsyncAwait-Android by Niek Haarman Async / Await by Metalab 如果你在寻找 Retrofit 的 coroutine 版本，那么可以试试 kotlin-coroutines-retrofit by Andrey Mischenko 建议你们使用的时候看看它们是如何实现的，这就是开源的好处。 其它对 Android 开发者有用的东西这个版本还有更多的改进，但是我更想强调一些侧重于 Android 开发的内容。 首先，现在可以通过使用以下配置来启用 Jack 编译器的支持了：jackOptions {true}。虽然 Google 已经宣布放弃 Jack 工具链了，但是如果你对 Java 8 有需求那么会有一点用处，然后等到 Android Studio 2.4 的正式版发布就可以彻底弃用 Jack 了。（从 Android Studio 2.4 Preview 4 版本开始支持所有 Java 7 语言特性，部分 Java 8 语言特性） 另外介绍一个小技巧，就是用 @JvmOverloads 来实现自定义 View 的构造函数，在 Kotlin 中借助参数默认值一个构造函数就能满足自定义 View 的多种构造需求（嗯，很长的一个构造函数） 12345class CustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; ...&#125; 结论Kotlin 1.1 带来了大量的新功能，不禁让人产生为什么还要使用 Java 的想法。 Kotlin 为 Android 开发者带来的好处是毋庸置疑的，从现在开始使用 Kotlin 编写你的 Android 应用吧。 如果你想从头开始学习使用 Kotlin 开发 Android 应用，那么你应该会对 Kotlin for Android Developers 这本书感兴趣。","tags":[{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event in Your City","date":"2017-03-21T13:51:00.000Z","path":"2017/03/21/Kotlin 1.1 Event in Your City/","text":"我们将于2017年3月23日进行Kotlin 1.1活动 线上直播。您可以通过JetBrains TV观看Andrey Breslav的演讲，了解Kotlin 1.1的关键特性，包括协程(coroutines)，JavaScript后端等。您也可以使用#kotlinqa在twitter上提出问题，我们将在3月23日直播中的Q&amp;A环节进行解答。为适应不同的时区我们共准备了2个直播流，详情可在博客日志中参阅详细计划与指导 。从下图中了解您所在的城市是否有Kotlin 1.1活动，如果您所在的城市尚未出现在下图中，请单独加入直播。 请注意，美国的直播时间已经更改为PDT(太平洋夏季时间)时间。第一个直播流将于上午9点开始，第二个上午11点开始。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.0.7 is out","date":"2017-03-15T14:21:00.000Z","path":"2017/03/15/Kotlin 1.0.7 is out/","text":"我们很高兴地宣布Kotlin 1.0.x系列的最后一个更新，Kotlin 1.0.7已经发布了。需要重点关注的是该补丁针对Gradle和annotation processing进行修复，此前无法升级到1.1版本的用户现在可以正常使用了。完整的修复列表可以在更新日志查看。要在Maven或Gradle版本中更新版本，只需在构建脚本中更改Kotlin版本号。命令行编译器会在Github发行页面中下载。在IntelliJ IDEA和Android Studio中，如果您使用Kotlin 1.0.7构建项目，我们建议使用1.1版本的插件，并将语言版本切换为1.0。如果您确实想要安装1.0.7版本的插件，可以在Kotlin插件页面下载相应版本，并通过IDE的“从磁盘安装插件…”按钮进行安装。一如既往，如果您在新版本中遇到任何问题，欢迎您在讨论组或者Slack（在这里获得邀请）里寻求帮助，或在这里提交issue。让我们来享受Kotlin吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1.1 is out","date":"2017-03-14T12:29:00.000Z","path":"2017/03/14/Kotlin 1.1.1 is out/","text":"今天我们发布了针对 Kotlin 1.1 的第一个bug修复更新。此更新的重点是解决导致错误代码生成的回归；我们希望尽可能快地修复此问题。详细内容请查看更新日志 。重点更新如下： 默认情况下，已启用Gradle增量编译。如果需要，您仍然可以按照文档描述禁用此功能。 Kotlin插件现已可以通过Gradle插件依赖添加使用。详情可参阅相关文档。 禁用使用带有接收器的函数类型作为JavaScript外部声明的参数类型。在此之前，传递给这些参数的lambdas没有被正确的参数调用，并且在这个问题上没有简单的解决方法，所以现在我们决定禁用这个功能。 更新后的Kotlin Eclipse 和 NetBeans 插件将支持Kotlin 1.1.1，所以您可以尽情享受Kotlin新版本的优点而无需关注IDE。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们开始吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 Event","date":"2017-03-06T09:43:00.000Z","path":"2017/03/06/Kotlin 1.1 Event/","text":"Kotlin 1.1除了为您的项目带来新特性之外，还是您与当地社区进行线下交流学习、了解Kotlin的未来与发展的绝好机会。您可以组织社区的小伙伴们，一起参与Jetbrains团队在3月23日举办的Kotlin直播活动。为了适应不同时区，我们准备了两个直播流，分别是欧洲中部时间[CET]下午5点/7点(太平洋夏季时间[PDT]上午9点/11点)。 告诉我们，我们将在博客上公布。 Kotlin 1.1活动时间： CET时间下午5点/7点(PDT时间上午9点/11点) - Andrey Breslav演讲(Youtube上直播30分钟)，链接将稍候放出。 CET时间下午5点30分/7点30分(PDT时间上午9点30分/11点30分) - 休息30分钟，期间可以自由讨论关于在Kotlin未来版本中您最希望加入的功能或特性，并在Twitter上分享和评论。 CET时间下午6点/8点(PDT时间上午10点/12点) - 与Kotlin团队的互动问答环节(45分钟，直播); 欢迎各位参与讨论与发言。 互动问答环节 从3月21日开始，至3月23日互动环节结束期间，您可以在Twitter上使用#kotlinQA标签向我们提出任何您想要问的问题； Kotlin团队将对问题进行分类; 团队将在Q＆A环节现场回答问题; 如果在会议期间有问题没有答复，我们仍将通过Twitter进行回复 优先回答提问频率最高的问题 Future Features kit本次调查的目的是收集社区用户对语言特征的偏好和需求。您可以提出在Kotlin后续版本中最希望看到的特征或功能；不过这些内容并不保证能在1.2版本中发布，但我们会在确定工作优先级时考虑您的意见。 Kotlin Future Feature Kit包含20张写有功能名称和描述的卡片以及用于投票的贴纸; 将功能卡片粘贴到白板（或墙壁）上; 每位参加者可获得3张（3张）贴纸，可以在功能中自由分配：最多为三种不同的功能进行投票，或者对某一功能投出两票甚至三票; 参加者可以通过阅读卡片的说明了解功能，然后按上所述规则进行投票; 将结果进行拍照; 使用#kotlinevent标签在Twitter上发布 在这里提交你的答案吧","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"Kotlin 1.1","date":"2017-03-04T00:46:34.000Z","path":"2017/03/04/Kotlin 1.1/","text":"上周一的文章里面提到 Kotlin 1.1 rc了，还没正式发布，我在周三的时候把文章转到掘金以后，好多小伙伴告诉我，1.1 已经发布了~ tips: 本文有较多外链，公众号阅读时无法跳转，如有需要，请大家点击”阅读原文”。 1、更新要点1.1 Coroutine1.1 最大的更新一定必须毫无疑问的要数 Coroutine 了，尽管在正式发版之前，Kotlin Team 突然虚了，决定把这个特性定为 Experimental，不过这似乎并没有改变什么。不就是改个包名么！！ 早在春节放假那几天，我就在公众号连续两周发文介绍 Coroutine，本来还计划有第三篇的，不过开工以后个项目有点儿累，每天翻 Android 系统 C++ 层的代码翻到吐，也没精力去写第三篇文章，真是抱歉，如果大家有兴趣，可以参考前两篇： 深入理解 Kotlin Coroutine (一) 深入理解 Kotlin Coroutine (二） 其中，第一篇文章写于 experimental 之前，不过大家只要在包名当中加上 experimental 就没问题了。 Kotlin 的 Coroutine 实现主要分为两个层面，第一个层面就是标准库以及语言特性的支持，这里面主要包括最基本的 suspend 关键字以及诸如 startCoroutine 这样的方法扩展，上述第一篇文章对此做了详细的介绍。第二层面则主要是基于前面的基础封装的库，目前主要是 kotlinx.coroutine ，其中封装了 runBlock、launch 这样方便的操作 Coroutine 的 api，这在第二篇文章做了详细地介绍。所以大家在了解 Coroutine 的时候，可以从这两个角度来入手，以免没有头绪。 我们再来简单说说 Coroutine 的运行机制。Coroutine 是用来解决并发问题的，它甚至有个中文名叫“协程”，它看上去跟线程似乎是并发问题的两种独立的解决方案，其实不然。要并发的执行任务，从根本上说，就是要解决 Cpu 的调度问题，Cpu 究竟是如何调度，取决于操作系统，我们在应用程序编写的过程中用到的 Thread 也好，Coroutine 也好，本质上也是对操作系统并发 api 的封装。知道了这一点，我们再来想想 Thread 是如何做到两个线程并发执行的呢？Java 虚拟机的实现主要采用了对内核线程映射的方式，换句话说，我们通常用到的 Thread 的真正直接调度者可以理解为是操作系统本身。那我们在 Kotlin 当中支持 Coroutine 是不是也要把每一个 Coroutine 映射到内核呢？显然不能，不然那跟 Thread 还有啥区别呢？再者，Coroutine 的核心在 Co 上，即各个 Coroutine 是协作运行的，有一种“你唱罢来我登场”的感觉，就是说，Coroutine 的调度权是要掌握在程序自己手中的。于是，如果你去了解 kotlinx.coroutine 的实现，你就会发现 CommonPool 这么个东西，它不是别的，它的背后正是线程池。 线程是轻量级进程，而协程则是轻量级线程。 Coroutine 的出现让 Kotlin 如虎添翼，如果你之前在写 Go，Lua，python，或者 C#，这回 Java 虚拟机家族可不会让你失望了。自从有了协程，你也可以写出这样的代码： 12345678910111213141516val fibonacci = buildSequence &#123; yield(1) // first Fibonacci number var cur = 1 var next = 1 while (true) &#123; yield(next) // next Fibonacci number val tmp = cur + next cur = next next = tmp &#125; &#125; ... for (i in fibonacci)&#123; println(i) if(i &gt; 100) break //大于100就停止循环 &#125; 序列生成器，记得我刚学 python 那会儿看到这样的语法，简直惊呆了。 123val imageA = loadImage(urlA) val imageB = loadImage(urlB) onImageGet(imageA, imageB) 这样的代码也是没有压力的，看上去就如同步代码一般，殊不知人家做的可是异步的事情呐。 协程的出现，让我们可以用看似同步的代码做着异步的事情。 这篇文章我们主要说说 1.1 的发版，Coroutine 的更多内容，建议大家直接点击前面的链接去读我的另外两篇文章~ 1.2 JavaScript 支持真是媳妇儿终于熬成婆，Js 终于被正式支持了。看官方的意思，他们已经用这一特性做了不少尝试，从 Kotlin 从头到尾写一个站点，似乎毫无压力，尽管类似反射这一的特性还没有支持，不过面包会有的嘛。 从我个人的角度来说，也可能我对前端了解太少吧，我觉得应用在前端比起移动端、服务端来说，Kotlin 的前景相对不明朗。我用 JavaScript 用得好好的，为啥要切换 Kotlin 呢？动态特性玩起来挺爽的，虽然回调写多了容易蛋疼，但这也不是不可以规避的。关于 Kotlin 开发前端这个问题，我需要多了解一下前端开发者的看法，相比他们是否愿意接触 Kotlin，我更关心有几个做前端的人知道这门语言。不瞒各位说，前几天跟一个支付宝客户端的大哥聊了一会儿，他问我这个 k o t 什么的，是干啥的。。。我当时在想，看来阿里人对 Kotlin 还不是很熟悉啊。 Whatever，Kotlin 现在都可以支持 node.js 了，还有什么不可能的呢？作为吃瓜群众，且让我观望一阵子。 1.3 中文支持你放心，这一段内容你绝对在其他人那里看不到，因为没人会这么蛋疼。我前几天为了做一个案例用中文写了段代码，想着 Java 支持中文标识符，Kotlin 应该也问题不大。没曾想，写的时候一点儿问题的没，可编译的时候却直接狗带了。 123456789101112package 中国.北京.回龙观 class G6出口&#123; fun 下高速()&#123; println(\"前方堵死, 请开启飞行模式 :)\") &#125;&#125; fun main(args: Array&lt;String&gt;) &#123; val 回龙观出口 = G6出口() 回龙观出口.下高速()&#125; 注意，包名、代码文件名都是中文的，如果用 1.0.6 版编译，结果就是万里江山一片红哇。 1234567Error:Kotlin: [Internal Error] java.io.FileNotFoundException: /Users/benny/temp/testKotlin/out/production/testKotlin/??/??/???/G6??.class (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at kotlin.io.FilesKt__FileReadWriteKt.readBytes(FileReadWrite.kt:52) at org.jetbrains.kotlin.incremental.LocalFileKotlinClass ... 注意到，汉字都变成了 ??，瞧瞧编译器那小眼神，真是看得我都醉了。 如果我们用 1.1 的编译器来编译这段代码，结果就可以正常输出： 1前方堵死, 请开启飞行模式。 1.4 其他特性1.1 还新增了不少特性，我在之前的一篇文章就做过介绍：喜大普奔！Kotlin 1.1 Beta 降临~ tpyealias 绑定调用者的函数引用 data class 可以继承其他类 sealed class 子类定义的位置放宽 _ 作为占位，替代不需要的变量 provideDelegate 2、Kotlin 元年2016 年是 Kotlin “元年（First year of Kotlin）”，官网给出了这样一幅图来展示它一年来的成绩： Github 上面的代码量都破千万了，使用 Kotlin 的公司也逐渐增多，除了 JetBrains 自己以外，我觉得在 Java 界比较有分量的就是 Square 了，如果 Google 能够稍微提一句 Kotlin ，显然这个故事就会有另外一个令人兴奋的版本——好啦，不要 yy 啦。 据说，比较著名的主要有Amazon Web Services, Pinterest, Coursera, Netflix, Uber, Square, Trello, Basecamp 这些公司将 Kotlin 投入了生产实践当中。国内资料较少，估计接触的人也不是很多，像百度、腾讯、阿里巴巴、滴滴、新美大、小米、京东这样的公司可能还没有太多的动力去将 Kotlin 应用到开发中，就算开始尝试，也多是在 Android 开发上面试水；而敢于尝试 Kotlin 的，更多是没有什么历史包袱且富于创新和挑战精神的创业团队，对于他们而言 Kotlin 为开发带来的效率是非常诱人的。 说到这里，有两个令人兴奋的消息需要同步给大家： Gradle 开始尝试用 Kotlin 作为其脚本语言，目前已经发到了 0.4.0。这个真的可以有，groovy 虽然是一门很灵活的语言，不过写配置的时候如果没有 IDE 的提示，实在是太痛苦了。大家有兴趣也可以关注一下这个项目：gradle-script-kotlin Spring 5.0 加入 Kotlin 支持，Spring 的地位可想而知，Spring 为 Kotlin 站台，这分量还是很重的。 不知道 2017 年会发生什么，且让我们准备好爆米花饮料，拭目以待吧。 关于 Kotlin 的资料，英文版的图书已经出版了几本，主要有： Kotlin in Action：这部书已经有了纸质版，是官方自己人写的，算是一本比较权威的参考书了。 Kotlin for Android Developers：这本书也算是老资历了，稍微看几眼你就会为 Kotlin 有趣的特性所吸引。另外，它还有一个中文的翻译版本 Modern Web Development with Kotlin：这本书我没有读过，如果你需要用 Kotlin 开发 web 应用，它应该会给予你一些帮助。 Programming Kotlin：这本书涉及内容非常全面，内容也算是言简意赅，快速入门 Kotlin 可以选择它。 除了图书以外， Kotlin 的首席布道师 Hadi Hariri 已经在 O’Reilly 上面发布了两套视频教程： Introduction to Kotlin Programming Advanced Kotlin Programming 里面有免费的几段，且不说内容怎么样，反正考验大家英语听力的时候到了，嗯，老爷子讲得还是很清楚的。 国内的资料，很少。除了有个别小伙伴写的一些博客之外，较为系统的学习资料几乎没有。也难怪大家都不知道它呢。也正是为了弥补这一空白，我在 16 年 10 月的时候开始每周 10 分钟的节奏连续录了 15 期视频，如果你有 Java 基础，那么看这些视频基本上可以让你知道 Kotlin 是怎么一回事了。 Kotlin 中文视频教程 另外，如果你想要对 Kotlin 持续了解，建议你关注微信公众号 Kotlin，每周一推送的 Kotlin 的相关文章，基本上会覆盖了 Kotlin 的各种最新动态。也欢迎大家跟我交流开发中遇到的问题~ 3、Kotlin 时代1.1 的重要的更新其实就 Coroutine 以及 JavaScript 支持，毕竟 Kotlin 对 Java 的兼容支持已经做得非常不错了（别老提 apt 的事儿，1.0.4 之后的 kapt 不就基本上很好用了么）。别人问我，Kotlin 到底是写啥的，这个问题我通常说很官方的说，Kotlin 是一门运行在 Java虚拟机、Android、浏览器上的静态语言，可是，Kotlin Team 的节奏已经让这句话显得要过时了。他们用短短几年时间搞出这么个全栈的语言，各方面特性都还很棒，然而他们并不能感到满足，他们已经开始走 C++ 的路线，也许 Kotlin Native 要不了多久就会出现了。 第一次听到这消息的时候，我瞬间就凌乱了，那感觉就好像王者荣耀里面队友选了大乔一样，秒回泉水加满血，秒回战场收人头啊。 前不久，我很荣幸地跟一位创业公司 CEO 坐下来聊理想，他问我的第一句话就是：你觉得 Kotlin 是未来么？我当时就蒙了，不得不说，他对 Kotlin 的期待跟 Kotlin Team 如出一辙呀。我当时实在不知道该怎么回答他，回来仔细想了想，答案其实也是有的。 十几年前，东家缺钱，急需投资，投资人坐下来“拷问”小马哥：“这个东西（指当时的 OICQ）怎么赚钱？” 小马哥说自己只知道这个东西大家喜欢，但不知道向谁收钱。对于 Kotlin 来说，我只知道它好用，尽管大家都还看不太懂，不过它的时代正在悄悄的到来。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 发布啦！JavaScript，Coroutine 还有更多你想要的","date":"2017-03-01T09:12:00.000Z","path":"2017/03/01/Kotlin 1.1 Released with JavaScript Support, Coroutines and more/","text":"Kotlin 1.1 今天正式发布了，这让 Kotlin 有能力适用于更多的应用场景，希望大家能够喜欢。 我们希望 Kotlin 能够在应用的任何组件中成为独立的、富有表现力且性能强大的强类型语言，Kotlin1.1 为了实现这一目标迈出了巨大的两步。 首先，JavaScript 支持的“试验性”标签已被移除，并且支持所有 Kotlin 语言特性、标准库的大部分内容以及 JavaScript 互操作性。这意味着开发者可以完全使用 Kotlin 来编写整个 WEB 应用，同时继续使用 JavaScript 的开发框架（比如 React）。 其次，我们引入了协程(coroutines)的概念。作为线程的轻量级替代方案，协程在应用程序后端可以具有更大可扩展性，从而支持单个 JVM 实例上的大量工作负载。除此之外，协程对于实现异步行为具有强大的表现力，这对于在任何平台上构建响应式用户交互界面而言极其重要。 下面我们将进一步介绍这两大功能。其他部分如type aliases，callable references，destructuring in lambdas等详情可在最新消息查看，试试完整的可运行示例代码！ 协程(Coroutines)在 Kotlin 中协程使非阻塞式异步代码与同步代码一样易于理解。 异步编程正当风靡，唯一让我们思虑的是，非阻塞式代码大量增加了系统的复杂性。 而 Kotlin 现在提供了简化这种复杂性的方法，通过单原子让协程在语言中成为一等公民：挂起函数。这种类型的函数（或 lambda）表示在计算运行中可以被挂起（不阻塞任何线程），而后也能继续恢复运行。 从技术上说，协程是多任务协作的轻量级解决方案（类似于fibers)）。换言之，他们只是更好的线程：可以任意的启动和保留，且挂起的消耗极其之低（挂起之于协程，如阻塞之于线程），非常易于组合与订制。 我们对于协程的设计以实现最大的灵活性为目标：在语言中固化的部分少，而且可以作为库来实现很多功能。kotlinx.coroutines项目在 Rx，CompletableFuture，NIO，JavaFx 和 Swing 上均有设计功能库，甚至可以为 Android 和 JavaScript 编写类似的库。即使在其​​他语言中许多内置构建现在也可以用 Kotlin 库来编写。包括 Python 的 generators/yield，来自 Go 的 channels/select 以及 C＃的 async/await: 12345678910111213141516// runs the code in the background thread poolfun asyncOverlay() = async(CommonPool) &#123; // start two async operations val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // and then apply overlay to both results applyOverlay(original.await(), overlay.await())&#125; // launches new coroutine in UI contextlaunch(UI) &#123; // wait for async overlay to complete val image = asyncOverlay().await() // and then show it in UI showImage(image)&#125; 查看完整内容。 重要提示：凭借上述的这些优势，Kotlin 协程近乎全新的设计，在我们能确定这是 100％正确和完整之前，仍然需要大量的实践和测试。因此我们才选择在“实验性”标志下发布。我们不希望语言规则发生变化，但 API 可能需要在 Kotlin 1.2 中进行调整。 JavaScript 支持如上所述，Kotlin 1.1 中的所有语言特性（包括协程）都适用于 JVM / Android 和 JavaScript（JavaScript 的反射目前不可用，但我们正在这方面努力）。这意味着 Web 应用程序可以完全使用 Kotlin 编写，而且我们已经在 JetBrains 内部有一些尝试，相信很快就会发布教程和其他资料。 Kotlin for JavaScript 具有与“源生”JavaScript 代码进行互相操作的动态类型，通过类型 API 可以使用ts2kt converter以及DefinitelyTyped等知名库。 我们支持 Node.js 和浏览器。 Kotlin 标准库可通过npm使用。文档链接 。 工具Kotlin 1.1 并不是 Kotlin 工具发布的主版本：我们更喜欢具有这些功能的工具就绪后，不会对语言本身产生影响，所以我们在 Kotlin 1.0.x 版本中的有许多这样的改进： 主流 IDE 的 Kotlin 插件：IntelliJ IDEA，Android Studio，Eclipse 和 NetBeans IntelliJ IDEA 和 Gradle 中的增量编译 Spring，JPA 和 Mockito 的编译器插件（all-open 与 no-arg） 注解处理器 kapt 对 Android 项目的支持 Lint 检查 大量的 IDE 代码预测，检查，快速修复，重构和自动完成提升 我们将继续在 1.1.x 版本中进行更新，努力为开发者们提供更好的工具。 Kotlin 元年：迁移与社区总而言之，Kotlin 正在逐渐壮大。去年，我们看到有超过 160,000 人使用，Github 上的 Kotlin 开源项目从 2.4M 增加到 10M（约 4 倍）。我们的 Slack 社区已经从 1,400 人增长到超过 5,700 人（超过 4 倍）。世界各地均有社区组织了众多的线下交流以及用户群组，我们也看到越来越多的 Kotlin 书籍和在线课程发布。 Kotlin 在服务器端和 Android 端（开发人员数量均等）表现异常强大。 Spring 框架 5.0和vert.x 3.4均引入了对 Kotlin 的支持。 Gradle和TeamCity正在使用 Kotlin 构建脚本。更多使用 Kotlin 的项目可以在kotlin.link查看。 许多知名公司也正在使用 Kotlin：Pinterest，Coursera，Netflix，Uber，Square，Trello，Basecamp；除此之外， 由知名银行（如高盛，富国银行，摩根大通，德意志银行，瑞银，汇丰银行，法国巴黎银行，SociétéGénérale）联盟开发的分销账户分类账户Corda，其代码库中有超过 90％的部分使用 Kotlin。我们感谢世界各地的所有用户，贡献者和倡导者。您的支持对我们非常重要！ 组织您自己的 Kotlin 1.1 活动Kotlin 1.1 的发布是与当地社区好友线下聚会的好话题。我们已经准备了一些资料来帮助开发者们举办此类活动。3 月 23 日，我们将以 Kotlin 团队成员的形式进行现场直播，发起人均可获得一个背包，里面有一份关于未来特性的调查问卷和一些小礼物，点击注册即可参与。 后续为了使 Kotlin 成为真正的全栈语言，我们将为多个平台编译相同的代码提供工具和语言支持。这将有助于在客户端和服务器之间进行模块共享。我们将继续致力于改进 JavaScript 工具和库的支持。除此之外，JavaScript 平台的增量编译正在进行中。请继续关注 1.1.x 更新。 Java 9 即将推出，我们将在发布之前为其新功能提供支持。 我们期望在未来几个月内能够收到许多关于协程反馈意见，改进这一领域（在性能和功能方面）对于我们优先级最高。除此之外，下一版本的主要工作将集中在维护，性能改进，基础架构和错误修复方面。P.S 跨平台运行是 Kotlin 的战略方向，伴随着 1.1 的发布，我们可以在服务器，台式机，Android 设备和浏览器上运行，但是未来我们将把 Kotlin 编译为本地代码，并使之能够在更多平台（例如 iOS 和嵌入式设备等）上运行。 目前在 JetBrains 内部，有一个非常棒的团队正在开展这个项目，我们期待很快就会出现有趣的东西，不过尚未计划为此专门发布任何版本。 安装说明与以往一样，开发者可以使用Kotlin 线上编辑器 try.kotlinlang.org。 Maven/Gradle：使用1.1.0作为编译器和标准库的版本号(查看文档)。 IntelliJ IDEA：2017.1 已包含 Kotlin 1.1；旧版本则需要安装 Kotlin 插件或更新到 1.1 版本。 Android Studio：通过Plugin Manager安装或更新插件。 Eclipse：使用Marketplace 安装插件。 命令行编译器可以从Github 发布页面下载。 兼容性：Kotlin 1.1 语言和标准库向后兼容(modulo bugs) ：如果使用 1.0 版本编译运行，1.1 版本仍然可以运行。为了帮助大型团队有规律的更新，我们在编译器中新增禁用新功能的开关。查看踩坑文档。 请尽情享受 Kotlin！ P.S: 在Reddit和Hacker News上加入讨论吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.1 候选版本来啦","date":"2017-02-17T05:37:00.000Z","path":"2017/02/17/Kotlin 1.1 Release Candidate is Here/","text":"截至今天，Kotlin 1.1 终于到了候选版本（RC）阶段。这意味着大部分开发工作都已经完成，我们对此结果感到满意，很快就会发布 Kotlin 1.1 正式版。我们已经在内部对此版本进行了大量测试，但现实世界总是比任何测试环境更加多样化，因此我们需要您的帮助。请尝试这个版本，让我们知道您的体验！ 候选版本中唯一的新功能是 takeUnless 函数，它对应 1.1 之前添加的 takeIf，但判断条件相反。至于错误修复则有很多，完整清单请查看更新日志。除此之外，我们还修复了几个 IDE 中的性能问题，包括长期存在和最近回归才出现的。 迁移说明就像我们之前提到的，预发布版本生成的所有二进制文件不能在当前的编译器下使用：您现在需要重新编译由 1.1-M0x 和 Beta 编译的所有内容。当然，从 1.0.x 开始的所有代码都不需要重新编译。 在这之前，您可以从 Java 6 开始，以任何版本的 Java 运行 Kotlin 编译器，但这从第一个 1.1.x 更新开始有变化，编译器将仅在 Java 8 或 9 下运行。为您准备迁移，编译器现在会在 Java 6 或 7 下运行时发出警告。请注意，这仅影响构建环境；编译代码默认情况下仍然与 Java 6 兼容，我们没有计划删除对它的支持。 现在不推荐使用 .javaClass 扩展属性。作为替代，请使用 ::class.java。IDE 提供了一个 quickfix 来更新写法，单独的修改或者更新整个项目。 为了减小 JavaScript 标准库的大小，我们已经将 kotlin.dom 和 kotlin.dom.build 包中的大量辅助函数注解为不推荐使用了，然后在将来的更新中删除它们。 如何尝鲜在 Maven/Gradle 中： 将 http://dl.bintray.com/kotlin/kotlin-eap-1.1 添加为构建脚本和项目的仓库；使用 1.1.0-rc-91 作为编译器和标准库的版本号。 在 IntelliJ IDEA 中： 点击菜单 Tools → Kotlin → Configure Kotlin Plugin Updates，然后在 Update channel 的下拉列表中选择 “Early Access Preview 1.1”，接着点击 Check for updates。 在 Eclipse 中： 从以下更新站点安装插件https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.0 The command-line compiler 可以从 Github 发布页面下载。最后，让我们开启 Kotlin 之旅吧！try.kotlinlang.org。","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"Kotlin 1.1 Beta 2 发布~","date":"2017-02-06T00:14:15.000Z","path":"2017/02/06/Kotlin 1.1 Beta 2 发布~/","text":"1 协程改包名风波说真的，看到这个标题的时候我还挺兴奋，离 release 又近了一步。不过，看了这篇文章的时候，我就觉得也是醉醉的。发生了啥呢？ 原来，协程相关的依赖统统被标记为 experimental 了，以前叫： 1package kotlin.coroutines 现在呢？ 1package kotlin.coroutines.experimental 这意味着啥？意味着我们在这次更新之后，还得把原来的协程代码的包重新导入一遍，另外，如果你想使用协程，那么你还需要在配置当中呢启用它，例如 gradle 配置需要加入： 12345kotlin &#123; experimental &#123; coroutines 'enable' &#125;&#125; 你在升级所有的依赖的时候，确保它是兼容 1.1.0-beta-38 的，这一点很重要，不然等着报错吧！ 话说，为啥要这么搞呢？按照官方的说法就是，协程这个特性目前已经实现的非常不错了，内置 API 非常少，灵活扩展性也强，不过他们觉得这个东西还有很大的潜力，也不能就这样作为最终版本给大家放出来，而作为实验特性交给大家使用呢，更多地还是希望大家能提提意见啥的。嗯，说实在的，协程这个特性真不是个小特性。 2 兼容 1.0话说，1.1 的编译器终于声称兼容 1.0 的源码了，这表明我们再也不用搞两个 IntelliJ 分别装 1.0 稳定版的插件和 1.1 Beta 版的插件了。 是的，就算你不用 1.1 的特性，你装 1.1 的插件，用 1.1 的编译器，写 1.0 的代码毫无压力！！ 什么？你问我试了没？当然，我一直用最新的插件，折腾地挺苦的 T T，劝诸君还是装稳定版吧，吃螃蟹要做好心理准备~！ 3 小结浏览了一下 1.1Beta 2 的主要特性，其实就是改改包名，修几个小 Bug，大的改动基本没有了。如果大家想要尽早上手 1.1 的特性，那么就从现在开始吧~","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"Kotlin 1.0.6","date":"2017-01-02T08:22:57.000Z","path":"2017/01/02/Kotlin 1.0.6/","text":"我把所有文章和视频都放到了 Github 上 ，如果你喜欢，请给个 Star，谢谢~ 在上周二，Kotlin 1.0.6 发布啦！这次更新主要是工具更新和bug修复。本文的内容主要来自官方博客。 IDE 插件的更新 try-finally 转换为 use() 通常我们在进行 IO 操作的时候，我们并不希望异常影响我们程序的执行，所以我们需要对异常进行捕获，但捕获的话我们也没有必要处理，所以写下来的就是下面的形式： 12345try&#123; ... do something with \"reader\" ...&#125;finally&#123; reader.close()&#125; 但这样写起来是不是非常的不流畅？如果用 use() 的话，简直一气呵成： 123reader.use&#123; reader -&gt; ... do something with \"reader\" ...&#125; 所以，这次更新 Kotlin 的插件为我们带来了这样的自动转换功能： 补全具名参数 通常我们在编写代码的时候，函数入参都会按照顺序一个一个传入，不过随着代码量的增加，特别是对于参数较多的函数，一长串的代码看上去会让我们感到非常的头疼。所以，这次更新 Kotlin 还为我们带来了自动补全具名参数的功能。 删除空构造方法的声明 合并声明和赋值 inline 函数的问题修复和调试工具的优化 提示、KDoc 和 Quick Doc 相关的较多问题的修复 Android 相关更新 支持 Android Studio 2.3 beta 1 和 Android Gradle Plugin 2.3.0-alpha3及更新的版本 增加 “Create XML resource” 的提示 Android Extensions support 这个功能可以让我们很方便的引用 XML 布局的 View，不过这需要我们主动启用 ‘kotlin-android-extensions’ 才行。在过去，即使不启用这个插件，IDE 也会允许我们直接引用 XML 布局的 View，但这并不能正常编译，所以这次更新修复了这个问题：只有启用了这个插件，IDE 才会允许我们引用对应的 View。 Android Lint 相关的问题修复。 增加 Suppress Lint 提示。 Kapt 优化尽管还不能完全支持增量编译，相比 1.0.4，这次更新较大的提升了 Kapt 的性能。如果需要启用 Kapt，请在 gradle 当中启动它：plugin: 'kotlin-kapt'```123456789101112131415161718192021222324252627282930313233## All-open 插件我们知道 Kotlin 的所有类及其成员默认情况下都是 final 的，也就是说你想要继承一个类，就要不断得写各种 open。刚开始看到这一特性的时候，觉得很赞，它对培养良好的编码意识非常有帮助，不过它也在某些情况下给我们带来麻烦，比如在一些大量依赖继承和覆写的 Java 框架的使用中。这一次 Kotlin 提供了一个妥协的办法，主要某个类被某一个特定注解标注，那么这个类就默认所有成员通通 open，省得一个一个写了。有关 allopen 的讨论，大家可以参考这里 [KEEP](https://github.com/Kotlin/KEEP/pull/40)。那么 allopen 如何使用呢？```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125;buildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 那么所有被 com.your.Annotation 这个注解标注的类成员都会默认 open。除此之外，它还可以作为元注解使用： 12345@com.your.Annotationannotation class MyFrameworkAnnotation@MyFrameworkAnnotationclass MyClass // will be all-open Kotlin 还提供了 “kotlin-spring” 插件，其中包含了 spring 相关的所有注解，这样免得我们一个一个在 allopen 的配置中声明了。 No-arg 插件如果大家看过我的视频，一定对我之前提到的“毁三观”的实例化有印象吧，附上视频连接：12 Json数据引发的血案，其中我们提到对于没有无参构造方法的 Kotlin 类，Gson 反序列化它们的时候，不知道如何实例化它们，只好用到了 这个类。听说 Java 9 要移除这个略显黑科技的类，如果是这样，Gson 是不是会被削弱呢？Java 的心我们还是不操了，从 Kotlin 1.0.6 开始，这个问题将得到一个比较好的解决。1234567891011121314```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot; &#125;&#125;// Or &quot;kotlin-jpa&quot; for the Java Persistence API supportapply plugin: &quot;kotlin-noarg&quot;noArg &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 类似于 allopen 的使用方法，如果某个类需要无参默认构造方法，你只需要用上面声明好的注解 com.your.Annotation 标注即可。当然，这个生成的默认构造方法只能通过反射调用。 如何更新我一直觉得虽然我们出生就被选择了 Hard 模式，但我们没啥感觉啊。可是最近一直访问国外的网站，感觉真的好困难，宽带换成了电信 100M，下载 Kotlin 的插件仍然跟小水管一样，真也是没谁了。为了方便大家我把我下载的几个版本的插件放到百度网盘，供大家使用，请大家点击阅读原文获取下载地址。 小结目前 Kotlin 1.0.x 的版本更新更侧重于稳定性和易用性，因此语言上的特性基本不会更新，主要集中于 IDE 插件和编译器插件。如果大家期待语言特性的更新，那我们就去关注一下 1.1 吧！","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]},{"title":"[译]Kotlin 1.0 Beta 3 发布啦!","date":"2015-12-07T07:45:00.000Z","path":"2015/12/07/Kotlin 1.0 Beta 3 is Out!/","text":"我们很高兴发布了 Kotlin 1.0 Beta 的另一个更新。我们正在努力完善标准库，抛弃了过时已久的设计结构，同时修复了 bugs，改进性能和为下一个版本作准备。完整的更新历史在 这里 。 最新的 issue 在 这里 。 Library 变更我们努力在 1.0 版本到来之前让标准库变得更加完美。这意味着进行一些尝试，所以会有新的部分被弃用，有新的函数被添加。我们计划在 1.0 版本（或 RC）中对标准库进行一次最后的清理：删除所有已过时和其他遗留的东西。这里我们只关心一个需要注意的变化：现在contains()和其他类似的扩展方法接受集合元素的父类型。 1234567// strs: Collection&lt;String&gt;// ns: String?// cs: CharSequence// i: Intstrs.contains(ns) // accepted nowstrs.contains(cs) // accepted nowstr.contains(i) // ERROR (in fact, a deprecation warning, but will be an error soon) 我们发现以前建议的containsRaw方法比较低效，使用contains()更加合适，同时保证了兼容性。请注意，集合接口本身是完整的，所有这些都是通过扩展功能完成的。请使用Code Cleanup来迁移代码。 语言变化一些需要注意的语言变化，完整列表在这里 。 许多我们以前不推荐的实现现在会报错。请使用Code Cleanup进行迁移。 When 表达式这种代码已被证明是有问题的，所以我们决定弃用它： 1234when &#123; foo.isValid(), foo.isReady() -&gt; process(foo) ...&#125; 许多人倾向于认为条件 foo.isValid(), foo.isReady() 表示 foo.isValid() == true and foo.isReady() == true，而实际上逗号是指 or。解决方法很简单：只需使用 ||: 1234when &#123; foo.isValid() || foo.isReady() -&gt; process(foo) ...&#125; Code Cleanup会自动迁移。 注释一个 bug 已被修复，现在我们可以在注解的参数中使用默认值： 12345annotation class Entry(val value: String) annotation class Example( val entries: Array&lt;Entry&gt; = arrayOf(Entry(\"a\"), Entry(\"b\")) // OK now) 枚举值()最近我们将传统的 Java 的Enum.values()更改为一个属性：Enum.values，但现在我们将回滚这个更改，因为有一个没有注意到的角落：枚举中的常量可能被命名为values，然后便没有办法访问其中的任何一个。我们考虑了不同的方案，最后决定将values改回函数是最干净的。所以，现在不推荐使用values属性，也不推荐使用values()函数。 可见性和作用域我们正在清理和修正小问题的可见性和作用域 companion objects 中允许 protected 成员 子类调用非 @JvmStatic 的 protected 对象将被标记为错误（不支持） 对于 open 属性，私有 setters 现在已被标记为过时 local sealed class 已弃用（从不可用） 重写的 setter 不能降低可见性 枚举类中不再允许存在内部类 lambdas / object literals / local 函数中禁止使用未初始化的变量 Android 扩展我们合并了 IntelliJ IDEA 的主要 Kotlin 插件和 Android 的Kotlin扩展插件。后者现在已经过时了，因为它的功能可以从 Kotlin 插件获取。此外，我们还添加了对 Android productFlavors的支持：现在，来自不同 flavors 的属性可以在不同的包中使用。例如，我们可以在build.gradle文件中存在两种 flavors： 12345678productFlavors &#123; free &#123; versionName \"1.0-free\" &#125; pro &#123; versionName \"1.0-pro\" &#125;&#125; 现在，我们不仅可以在main source set中的布局使用合成属性，还可以在 flavor 布局使用合成属性： 1234567891011121314// Import synthetic properties for the `activity_free.xml` layout in the `free` flavorimport kotlinx.android.synthetic.free.activity_free.versionMarker class FreeActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; ... setContentView(R.layout.activity_free) ... versionMarker.text = \"Free version\" &#125;&#125; 请注意，main source set的所有布局现在位于kotlinx.android.synthetic.main包之下，旧的包命名约定已被弃用。 IDE 中的新功能 Android Extensions 插件已被合并到 Kotlin 插件中，不再需要单独安装 创建新的 Gradle 工程时，添加了 Kotlin 的选项以供选择： 调试器：stacktrace 导航功能现在支持跟踪内联函数的堆栈帧。同时对内联函数的步进调试功能进行了一系列的改进。 添加了三个快速初始化新属性的Quick Fixes： Introduce Variable（Ctrl + Alt + V / Cmd + Alt + V）现在支持结构声明(multi-declarations)： 同时Introduce Variable还能使用于 lambda 或匿名函数中： Beta 3 开始支持在字符串模板中使用 Introduce Variable/Parameter/Property/Function 最后，添加了一个实验功能 —— 在 IDE 中对 Kotlin 脚本文件（.kts）做了基本的支持","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://kotlinandroid.net/tags/Kotlin/"}]}]